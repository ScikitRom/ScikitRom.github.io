<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>problem_structure</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-991b1886d3c685c7aa2b62b80640c7af.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../reference/_styles-quartodoc.css">
</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="tutorial-building-a-reduced-order-model-with-scikit-rom" class="level1">
<h1>Tutorial: Building a Reduced-Order Model with <strong>scikit-rom</strong></h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="linear_elastic_image.png" class="img-fluid figure-img"></p>
<figcaption>Linear Elasticity</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>Goal.</strong> This comprehensive hands-on tutorial walks you through every file in <strong>problem_1</strong> and shows how to assemble an <em>affine</em> reduced-order model (ROM) for a 3-D linear-elastic block using <strong>scikit-rom</strong>. We’ll explain the theory behind each step and demonstrate how reduced-order modeling can dramatically accelerate computational mechanics simulations.</p>
</blockquote>
<hr>
<section id="what-is-reduced-order-modeling" class="level2">
<h2 class="anchored" data-anchor-id="what-is-reduced-order-modeling">What is Reduced-Order Modeling?</h2>
<p>Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.</p>
<p>The key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.</p>
<p>This is particularly powerful for:</p>
<ul>
<li><p><strong>Parameter studies</strong>: Exploring how a system responds to different material properties, boundary conditions, or geometry</p></li>
<li><p><strong>Optimization</strong>: Finding optimal designs without expensive repeated full-scale simulations</p></li>
<li><p><strong>Real-time applications</strong>: Control systems, digital twins, and interactive simulations</p></li>
<li><p><strong>Uncertainty quantification</strong>: Monte Carlo studies with thousands of parameter samples</p></li>
</ul>
<hr>
</section>
<section id="prerequisites" class="level2">
<h2 class="anchored" data-anchor-id="prerequisites">Prerequisites</h2>
<p>First, install the required packages:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install scikit-rom scikit-fem numpy scipy matplotlib</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Package Overview:</strong> - <code>scikit-rom</code>: The main ROM framework we’ll be using - <code>scikit-fem</code>: A Python finite element library for discretizing PDEs - <code>numpy</code>/<code>scipy</code>: Numerical computing foundations - <code>matplotlib</code>: For visualization and plotting results</p>
<p>You should also clone the project so that the package layout shown below is on your <code>PYTHONPATH</code>:</p>
<pre><code>problem_1/
├─ domain.py           # Geometry, mesh, and finite element setup
├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)
├─ linear_forms.py     # Right-hand side terms (loads, tractions)
├─ properties.py       # Material property definitions
├─ params.py           # Parameter sampling for training/testing
└─ problem_def.py      # Main problem class that orchestrates everything</code></pre>
<p>This modular structure separates concerns and makes the code maintainable and extensible.</p>
<hr>
</section>
<section id="geometry-finite-element-setup-domain.py" class="level2">
<h2 class="anchored" data-anchor-id="geometry-finite-element-setup-domain.py">1. Geometry &amp; Finite-Element Setup — <strong>domain.py</strong></h2>
<p>The <code>domain.py</code> file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skfem <span class="im">import</span> MeshHex, Basis, ElementVector</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> domain_(lx<span class="op">=</span><span class="fl">1.0</span>, ly<span class="op">=</span><span class="fl">1.0</span>, lz<span class="op">=</span><span class="fl">1.0</span>, factor<span class="op">=</span><span class="dv">10</span>, dirichlet_boundary_value<span class="op">=</span><span class="fl">0.0</span>):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    mesh   <span class="op">=</span> MeshHex().refined(factor) <span class="op">*</span> [lx, ly, lz]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    element <span class="op">=</span> ElementVector(ElementHex1())</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    basis   <span class="op">=</span> Basis(mesh, element)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># facet selectors (λ-functions that return True on selected facets)</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    left  <span class="op">=</span> basis.mesh.facets_satisfying(<span class="kw">lambda</span> x: x[<span class="dv">0</span>] <span class="op">&lt;</span> <span class="fl">1e-12</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> basis.mesh.facets_satisfying(<span class="kw">lambda</span> x: x[<span class="dv">0</span>] <span class="op">&gt;</span> lx <span class="op">-</span> <span class="fl">1e-12</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    fbasis_dirichlet <span class="op">=</span> basis.restrict(left)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    fbasis_neumann   <span class="op">=</span> basis.restrict(right)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">dict</span>(</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        mesh<span class="op">=</span>mesh, basis<span class="op">=</span>basis,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        fbasis_dirichlet<span class="op">=</span>fbasis_dirichlet,</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        fbasis_neumann<span class="op">=</span>fbasis_neumann,</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        dirichlet_boundary_value<span class="op">=</span>dirichlet_boundary_value</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Explanation:</strong></p>
<ol type="1">
<li><p><strong>Mesh Generation</strong>: <code>MeshHex().refined(factor)</code> creates a structured hexahedral mesh. The <code>factor</code> parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions <code>[lx, ly, lz]</code>.</p></li>
<li><p><strong>Element Type</strong>: <code>ElementVector(ElementHex1())</code> specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).</p></li>
<li><p><strong>Basis Functions</strong>: The <code>Basis</code> object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.</p></li>
<li><p><strong>Boundary Identification</strong>: The lambda functions identify mesh facets (faces) on the left and right boundaries:</p>
<ul>
<li><code>left</code>: facets where x-coordinate is approximately 0 (fixed boundary)</li>
<li><code>right</code>: facets where x-coordinate is approximately lx (loaded boundary)</li>
</ul></li>
<li><p><strong>Boundary Bases</strong>: <code>fbasis_dirichlet</code> and <code>fbasis_neumann</code> are restricted function spaces on the boundary facets, used for applying boundary conditions.</p></li>
</ol>
<p><strong>Why This Structure?</strong> The helper returns a <strong>dictionary</strong> so that subsequent stages can be kept in pure-function style, making the code more modular and testable.</p>
<hr>
</section>
<section id="constitutive-law-material-properties-properties.py" class="level2">
<h2 class="anchored" data-anchor-id="constitutive-law-material-properties-properties.py">2. Constitutive Law &amp; Material Properties — <strong>properties.py</strong></h2>
<p>This module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skfem.models.elasticity <span class="im">import</span> lame_parameters</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lame_params(E, nu, region):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    lam, mu <span class="op">=</span> lame_parameters(E, nu)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> region <span class="op">==</span> <span class="st">"region_1"</span>:      <span class="co"># stiffer inclusion</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        lam <span class="op">*=</span> <span class="dv">50</span><span class="op">;</span> mu <span class="op">*=</span> <span class="dv">50</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lam, mu</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Explanation:</strong></p>
<ol type="1">
<li><strong>Lamé Parameters</strong>: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:
<ul>
<li>λ (lambda): relates to bulk compression/expansion</li>
<li>μ (mu): the shear modulus, relates to shape changes</li>
</ul></li>
<li><strong>Conversion from Engineering Constants</strong>: The function <code>lame_parameters(E, nu)</code> converts from the more intuitive engineering constants:
<ul>
<li>E: Young’s modulus (stiffness in uniaxial tension)</li>
<li>ν: Poisson’s ratio (lateral contraction ratio)</li>
</ul></li>
<li><strong>Material Heterogeneity</strong>: The <code>region</code> parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.</li>
</ol>
<p><strong>Physical Interpretation</strong>: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement</p>
<hr>
</section>
<section id="affine-stiffness-tensor-bilinear_forms.py" class="level2">
<h2 class="anchored" data-anchor-id="affine-stiffness-tensor-bilinear_forms.py">3. Affine Stiffness Tensor — <strong>bilinear_forms.py</strong></h2>
<p>This is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.</p>
<p>The weak form of linear elasticity states: Find <span class="math inline">\(u\)</span> such that <span class="math display">\[a(u,v; \lambda,\mu) = \ell(v) \quad \forall v\]</span></p>
<p>where the bilinear form is: <span class="math display">\[
a(u,v; \lambda,\mu) = \int_\Omega
\bigl[
\lambda\,\operatorname{tr}(\varepsilon(u))\operatorname{tr}(\varepsilon(v)) +
2\mu\,\varepsilon(u):\varepsilon(v)
\bigr]\,d\Omega
\]</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skfem.helpers <span class="im">import</span> sym_grad, ddot, trace</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">@BilinearForm</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stiffness_lam(u, v, w):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    lam <span class="op">=</span> w[<span class="st">"lam"</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lam <span class="op">*</span> trace(sym_grad(u)) <span class="op">*</span> trace(sym_grad(v))</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="at">@BilinearForm</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stiffness_mu(u, v, w):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> w[<span class="st">"mu"</span>]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">2.0</span> <span class="op">*</span> mu <span class="op">*</span> ddot(sym_grad(u), sym_grad(v))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Explanation:</strong></p>
<ol type="1">
<li><p><strong>Strain Tensor</strong>: <code>sym_grad(u)</code> computes the symmetric gradient (strain tensor): <span class="math display">\[\varepsilon(u) = \frac{1}{2}(\nabla u + \nabla u^T)\]</span></p></li>
<li><p><strong>Volumetric Term</strong>: <code>trace(sym_grad(u))</code> gives the volumetric strain (dilatation): <span class="math display">\[\operatorname{tr}(\varepsilon) = \varepsilon_{11} + \varepsilon_{22} + \varepsilon_{33}\]</span></p></li>
<li><p><strong>Deviatoric Term</strong>: <code>ddot(sym_grad(u), sym_grad(v))</code> is the double contraction: <span class="math display">\[\varepsilon(u):\varepsilon(v) = \sum_{i,j} \varepsilon_{ij}(u)\varepsilon_{ij}(v)\]</span></p></li>
<li><p><strong>Affine Structure</strong>: The key insight is that the stiffness matrix can be written as: <span class="math display">\[K(\lambda,\mu) = \lambda K_\lambda + \mu K_\mu\]</span> where <span class="math inline">\(K_\lambda\)</span> and <span class="math inline">\(K_\mu\)</span> are parameter-independent matrices.</p></li>
</ol>
<p><strong>Why This Matters for ROM</strong>: Because each term is <em>affine</em> in <span class="math inline">\((\lambda,\mu)\)</span>, the global stiffness matrix can be pre-assembled <strong>offline</strong> as a <strong>linear combination of two parameter-independent blocks</strong>. This is crucial for computational efficiency in the online phase.</p>
<hr>
</section>
<section id="right-hand-side-linear_forms.py" class="level2">
<h2 class="anchored" data-anchor-id="right-hand-side-linear_forms.py">4. Right-Hand Side — <strong>linear_forms.py</strong></h2>
<p>This module defines the loading conditions applied to the structure.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">@LinearForm</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> traction(v, w):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="fl">1e-2</span> <span class="op">*</span> v[<span class="dv">1</span>]   <span class="co"># constant Neumann traction in $y$-direction</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Explanation:</strong></p>
<ol type="1">
<li><p><strong>Neumann Boundary Condition</strong>: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.</p></li>
<li><p><strong>Magnitude</strong>: The factor <code>-1e-2</code> sets the load magnitude. This might represent:</p>
<ul>
<li>Pressure loading (e.g., 0.01 MPa)</li>
<li>Body forces scaled appropriately</li>
<li>Distributed surface tractions</li>
</ul></li>
<li><p><strong>Parameter Independence</strong>: Again, this is a single <em>parameter-independent</em> load vector, which allows for efficient offline precomputation.</p></li>
</ol>
<p><strong>Physical Interpretation</strong>: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads</p>
<hr>
</section>
<section id="parameter-sampling-params.py" class="level2">
<h2 class="anchored" data-anchor-id="parameter-sampling-params.py">5. Parameter Sampling — <strong>params.py</strong></h2>
<p>For ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> src.skrom.rom.rom_utils <span class="im">import</span> generate_sobol</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parameters(N_snap<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sobol over (E, nu) in [100, 200] × [0.25, 0.35]</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> generate_sobol([[<span class="fl">100.</span>,<span class="fl">200.</span>],[<span class="fl">0.25</span>,<span class="fl">0.35</span>]], <span class="dv">2</span><span class="op">*</span>N_snap)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Explanation:</strong></p>
<ol type="1">
<li><p><strong>Sobol Sequences</strong>: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.</p></li>
<li><p><strong>Parameter Ranges</strong>:</p>
<ul>
<li>Young’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)</li>
<li>Poisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)</li>
</ul></li>
<li><p><strong>Sample Size</strong>: <code>2*N_snap</code> samples are generated so they can be split into training and testing sets.</p></li>
</ol>
<p><strong>Usage Pattern:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>E_nu_train, E_nu_test <span class="op">=</span> np.split(parameters(<span class="dv">32</span>), <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This gives you 32 training samples and 32 testing samples for validation.</p>
<p><strong>Why Good Sampling Matters</strong>: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others.</p>
<hr>
</section>
<section id="orchestrating-everything-problem_def.py" class="level2">
<h2 class="anchored" data-anchor-id="orchestrating-everything-problem_def.py">6. Orchestrating Everything — <strong>problem_def.py</strong></h2>
<p>This is the main orchestration file that ties all components together using the scikit-rom framework.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">@register_problem</span>(<span class="st">"problem_1"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ProblemAffine(Problem):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> domain(<span class="va">self</span>):            <span class="co"># geometry + BC</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> .domain <span class="im">import</span> domain_</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> domain_()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bilinear_forms(<span class="va">self</span>):    <span class="co"># tuple of affine blocks</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> .bilinear_forms <span class="im">import</span> stiffness_lam, stiffness_mu</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> stiffness_lam, stiffness_mu</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> linear_forms(<span class="va">self</span>):      <span class="co"># RHS blocks</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> .linear_forms <span class="im">import</span> traction</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (traction,)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parameters(<span class="va">self</span>, n_samples):   <span class="co"># ⇒ array (n, 2)</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> .params <span class="im">import</span> parameters</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parameters(n_samples)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> coeff_funcs(<span class="va">self</span>):       <span class="co"># map (E,nu) → (λ, μ)</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> .properties <span class="im">import</span> lame_params</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lame_params</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Explanation:</strong></p>
<p>The <code>ProblemAffine</code> class inherits from the scikit-rom <code>Problem</code> base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:</p>
<ol type="1">
<li><strong><code>domain()</code></strong>: Returns the mesh, basis functions, and boundary conditions</li>
<li><strong><code>bilinear_forms()</code></strong>: Returns the tuple of affine bilinear form blocks</li>
<li><strong><code>linear_forms()</code></strong>: Returns the right-hand side terms</li>
<li><strong><code>parameters()</code></strong>: Generates parameter samples for training/testing</li>
<li><strong><code>coeff_funcs()</code></strong>: Maps between parameter representations</li>
</ol>
<p><strong>The Master Class Philosophy</strong>: The <strong>master class</strong> supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities</p>
<p>You only override <em>what is problem-specific</em>, following the principle of separation of concerns.</p>
<section id="anatomy-of-problemaffine" class="level3">
<h3 class="anchored" data-anchor-id="anatomy-of-problemaffine">Anatomy of <code>ProblemAffine</code></h3>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 50%">
<col style="width: 10%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Purpose</th>
<th>Offline?</th>
<th>Online?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>domain()</code></td>
<td>build mesh, BCs</td>
<td>✔️</td>
<td></td>
</tr>
<tr class="even">
<td><code>bilinear_forms()</code></td>
<td>return affine bilinear blocks</td>
<td>✔️</td>
<td></td>
</tr>
<tr class="odd">
<td><code>linear_forms()</code></td>
<td>return RHS blocks</td>
<td>✔️</td>
<td></td>
</tr>
<tr class="even">
<td><code>coeff_funcs()</code></td>
<td>convert material params → coefficients</td>
<td></td>
<td>✔️</td>
</tr>
<tr class="odd">
<td><code>parameters()</code></td>
<td>training / test design</td>
<td>✔️</td>
<td></td>
</tr>
<tr class="even">
<td><code>solve(mu)</code> (inherited)</td>
<td>assemble &amp; solve ROM</td>
<td></td>
<td>✔️</td>
</tr>
</tbody>
</table>
<p>This separation enforces the <strong>offline/online</strong> paradigm automatically, which is fundamental to efficient ROM implementations.</p>
<hr>
</section>
</section>
<section id="offline-workflow-building-the-rom" class="level2">
<h2 class="anchored" data-anchor-id="offline-workflow-building-the-rom">7. Offline Workflow — Building the ROM</h2>
<p>The offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> src.skrom.problem_classes <span class="im">import</span> new_problem</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> new_problem(<span class="st">"problem_1"</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) draw parameter samples</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>theta_train <span class="op">=</span> prob.parameters(n_samples<span class="op">=</span><span class="dv">64</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) build snapshots</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> prob.snapshots(theta_train)  <span class="co"># shape (n_dofs, n_snaps)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) compute POD basis</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>rbasis <span class="op">=</span> prob.reduced_basis(U, r<span class="op">=</span><span class="dv">50</span>)  <span class="co"># keep 50 modes</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) assemble reduced operators</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>prob.build_rom(rbasis)               <span class="co"># affine blocks → (A_r^1, A_r^2), f_r</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Detailed Step-by-Step Explanation:</strong></p>
<section id="step-1-parameter-sampling" class="level3">
<h3 class="anchored" data-anchor-id="step-1-parameter-sampling">Step 1: Parameter Sampling</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>theta_train <span class="op">=</span> prob.parameters(n_samples<span class="op">=</span><span class="dv">64</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This generates 64 parameter combinations <span class="math inline">\((E_i, \nu_i)\)</span> using the Sobol sequence. These parameters should span the expected range of operating conditions.</p>
</section>
<section id="step-2-snapshot-generation" class="level3">
<h3 class="anchored" data-anchor-id="step-2-snapshot-generation">Step 2: Snapshot Generation</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> prob.snapshots(theta_train)  <span class="co"># shape (n_dofs, n_snaps)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For each parameter combination, the full finite element problem is solved: <span class="math display">\[K(\theta_i) u_i = f\]</span></p>
<p>The resulting displacement vectors <span class="math inline">\(u_i\)</span> are called “snapshots” and are stored as columns in matrix <span class="math inline">\(U\)</span>. If you have <span class="math inline">\(N\)</span> degrees of freedom and <span class="math inline">\(n_{snap}\)</span> parameter samples, then <span class="math inline">\(U \in \mathbb{R}^{N \times n_{snap}}\)</span>.</p>
</section>
<section id="step-3-proper-orthogonal-decomposition-pod" class="level3">
<h3 class="anchored" data-anchor-id="step-3-proper-orthogonal-decomposition-pod">Step 3: Proper Orthogonal Decomposition (POD)</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>rbasis <span class="op">=</span> prob.reduced_basis(U, r<span class="op">=</span><span class="dv">50</span>)  <span class="co"># keep 50 modes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>POD performs Singular Value Decomposition on the snapshot matrix: <span class="math display">\[U = V \Sigma W^T\]</span></p>
<p>The columns of <span class="math inline">\(V\)</span> are the POD modes, ordered by importance (largest singular values first). We keep only the first <span class="math inline">\(r=50\)</span> modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.</p>
<p><strong>Key Insight</strong>: The POD basis <span class="math inline">\(V\)</span> captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.</p>
</section>
<section id="step-4-reduced-operator-assembly" class="level3">
<h3 class="anchored" data-anchor-id="step-4-reduced-operator-assembly">Step 4: Reduced Operator Assembly</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>prob.build_rom(rbasis)               <span class="co"># affine blocks → (A_r^1, A_r^2), f_r</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The full-order operators are projected onto the reduced space: <span class="math display">\[A_r^q = V^T A^q V, \quad f_r = V^T f\]</span></p>
<p>For our affine case: - <span class="math inline">\(A_r^1 = V^T K_\lambda V\)</span> (reduced volumetric stiffness) - <span class="math inline">\(A_r^2 = V^T K_\mu V\)</span> (reduced deviatoric stiffness) - <span class="math inline">\(f_r = V^T f\)</span> (reduced load vector)</p>
<p>These are small <span class="math inline">\(r \times r\)</span> matrices instead of <span class="math inline">\(N \times N\)</span> matrices, enabling rapid online assembly.</p>
<hr>
</section>
</section>
<section id="online-solve-real-time-evaluation" class="level2">
<h2 class="anchored" data-anchor-id="online-solve-real-time-evaluation">8. Online Solve — Real-Time Evaluation</h2>
<p>Once the ROM is built, evaluating it for new parameters is extremely fast:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>E, nu <span class="op">=</span> <span class="fl">150.0</span>, <span class="fl">0.30</span>          <span class="co"># ← new parameter</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>u_r   <span class="op">=</span> prob.solve((E,nu))   <span class="co"># ≈ 100× faster than full FE!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>What Happens Under the Hood:</strong></p>
<ol type="1">
<li><strong>Parameter Conversion</strong>: <span class="math inline">\((E, \nu) \rightarrow (\lambda, \mu)\)</span> using the coefficient function</li>
<li><strong>Rapid Assembly</strong>: <span class="math inline">\(K_r(\lambda,\mu) = \lambda A_r^1 + \mu A_r^2\)</span></li>
<li><strong>Small System Solve</strong>: <span class="math inline">\(K_r(\lambda,\mu) u_r = f_r\)</span> (only <span class="math inline">\(r \times r\)</span> system!)</li>
<li><strong>Return</strong>: The reduced solution <span class="math inline">\(u_r \in \mathbb{R}^r\)</span></li>
</ol>
<p><strong>Recovery to Full Space:</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>u_full <span class="op">=</span> prob.recover(u_r)   <span class="co"># back-project to FOM space</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This maps the reduced vector back to the full finite element space: <span class="math display">\[u_{full} = V u_r\]</span></p>
<p>Now <span class="math inline">\(u_{full}\)</span> has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.</p>
<p><strong>Speed-Up Mechanisms:</strong> - <strong>Dimension Reduction</strong>: Solving <span class="math inline">\(r \times r\)</span> instead of <span class="math inline">\(N \times N\)</span> systems - <strong>Affine Structure</strong>: Pre-computed operators avoid reassembly - <strong>Optimized Solvers</strong>: Small dense systems can use direct methods</p>
<hr>
</section>
<section id="validation-ensuring-rom-quality" class="level2">
<h2 class="anchored" data-anchor-id="validation-ensuring-rom-quality">9. Validation — Ensuring ROM Quality</h2>
<p>It’s crucial to validate that your ROM maintains accuracy across the parameter space:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>err_rel, speed_up <span class="op">=</span> prob.validate(n_test<span class="op">=</span><span class="dv">20</span>, tol<span class="op">=</span><span class="fl">1e-3</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"median error = </span><span class="sc">{</span>err_rel<span class="sc">:.2e}</span><span class="ss">, speed-up ×</span><span class="sc">{</span>speed_up<span class="sc">:.0f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>What This Does:</strong></p>
<ol type="1">
<li><strong>Test Parameter Generation</strong>: Creates 20 new parameter combinations not used in training</li>
<li><strong>Dual Solve</strong>: For each test parameter:
<ul>
<li>Solves the full finite element problem (slow but accurate)</li>
<li>Solves the ROM problem (fast approximation)</li>
</ul></li>
<li><strong>Error Computation</strong>: Computes relative error in appropriate norm (typically energy norm for mechanics)</li>
<li><strong>Timing Comparison</strong>: Measures computational time for both approaches</li>
</ol>
<p><strong>Error Metrics:</strong> The relative error is typically computed as: <span class="math display">\[\text{error} = \frac{\|u_{FOM} - u_{ROM}\|_E}{\|u_{FOM}\|_E}\]</span></p>
<p>where <span class="math inline">\(\|\cdot\|_E\)</span> is the energy norm: <span class="math inline">\(\|u\|_E^2 = u^T K u\)</span>.</p>
<p><strong>Interpreting Results:</strong> - <strong>Good ROM</strong>: Error &lt; 1e-3, speed-up &gt; 10× - <strong>Excellent ROM</strong>: Error &lt; 1e-5, speed-up &gt; 100× - <strong>Poor ROM</strong>: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension <span class="math inline">\(r\)</span> - Better parameter sampling - Different basis construction</p>
<hr>
</section>
<section id="advanced-topics" class="level2">
<h2 class="anchored" data-anchor-id="advanced-topics">10. Advanced Topics</h2>
<section id="choosing-the-reduced-dimension" class="level3">
<h3 class="anchored" data-anchor-id="choosing-the-reduced-dimension">10.1 Choosing the Reduced Dimension</h3>
<p>The choice of <span class="math inline">\(r\)</span> (number of POD modes) involves a trade-off: - <strong>Too small</strong>: Poor approximation quality - <strong>Too large</strong>: Slow online evaluation</p>
<p><strong>Rule of Thumb</strong>: Plot the singular values and choose <span class="math inline">\(r\)</span> such that: <span class="math display">\[\frac{\sum_{i=1}^r \sigma_i^2}{\sum_{i=1}^{n_{snap}} \sigma_i^2} &gt; 0.999\]</span></p>
<p>This ensures 99.9% of the “energy” is captured.</p>
</section>
<section id="affine-vs.-non-affine-problems" class="level3">
<h3 class="anchored" data-anchor-id="affine-vs.-non-affine-problems">10.2 Affine vs.&nbsp;Non-Affine Problems</h3>
<p>Our example exploits <strong>affine parameter dependence</strong>: <span class="math display">\[K(\mu) = \sum_{q=1}^Q \Theta_q(\mu) K_q\]</span></p>
<p>For non-linear, non-affine problems, hyperreduction techniques are used.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>