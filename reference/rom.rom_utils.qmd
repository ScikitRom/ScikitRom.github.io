# rom.rom_utils { #skrom.rom.rom_utils }

`rom.rom_utils`

General-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,
and Newton solvers in reduced‐order modeling (ROM) workflows.

This module provides:

  - Snapshot train/test splitting routines:
      * `train_test_split`, `latin_hypercube_train_test_split`, `sobol_train_test_split`
  - Sample generators:
      * `generate_sobol`, `generate_lhs`, `generate_gaussian_samples`
  - Basis management:
      * `update_basis` – deflation and augmentation of reduced bases
  - Solution reconstruction:
      * `reconstruct_solution` – expand reduced vectors back to full order
  - ROM data persistence:
      * `rom_data_gen`, `load_rom_data`
  - Newton solvers for ROM systems:
      * `newton_hyper_rom_solver`, `newton_solver_rom`

Together, these functions support data preparation, sampling design,
basis enrichment, I/O, and nonlinear solves in full‐to‐reduced‐order pipelines.

[Authors: Suparno Bhattacharyya, Ali Hamza Abidi Syed]

## Functions

| Name | Description |
| --- | --- |
| [collect_residuals](#skrom.rom.rom_utils.collect_residuals) | Collect reduced evaluations of the ROM residual functional for hyperreduction. |
| [compute_nonlinear_snapshots](#skrom.rom.rom_utils.compute_nonlinear_snapshots) | Evaluate a nonlinear RHS function over a set of FOM snapshots. |
| [generate_gaussian_samples](#skrom.rom.rom_utils.generate_gaussian_samples) | Generate Gaussian-distributed samples based on bounds-derived statistics. |
| [generate_lhs](#skrom.rom.rom_utils.generate_lhs) | Generate a Latin Hypercube Sample (LHS) scaled to given bounds. |
| [generate_sobol](#skrom.rom.rom_utils.generate_sobol) | Generate a Sobol sequence scaled to given bounds. |
| [latin_hypercube_train_test_split](#skrom.rom.rom_utils.latin_hypercube_train_test_split) | Split snapshots into training and testing masks via Latin Hypercube Sampling. |
| [load_rom_data](#skrom.rom.rom_utils.load_rom_data) | Load ROM data from a ROM_data directory or module path. |
| [newton_hyper_rom_solver](#skrom.rom.rom_utils.newton_hyper_rom_solver) | Solve a hyper-reduced ROM system via Newton's method. |
| [newton_solver_rom](#skrom.rom.rom_utils.newton_solver_rom) | Solve nonlinear reduced-order system using Newton's method. |
| [reconstruct_solution](#skrom.rom.rom_utils.reconstruct_solution) | Reconstruct a full-order solution from a reduced solution vector. |
| [rom_data_gen](#skrom.rom.rom_utils.rom_data_gen) | Save ROM simulation data to disk. |
| [select_elements_and_gauss_weights](#skrom.rom.rom_utils.select_elements_and_gauss_weights) | Select elements and corresponding weights from Gauss points, ensuring consistency |
| [sobol_train_test_split](#skrom.rom.rom_utils.sobol_train_test_split) | Split snapshots into training and testing masks via Sobol sequence ordering. |
| [train_test_split](#skrom.rom.rom_utils.train_test_split) | Split snapshot indices into training and testing masks. |
| [update_basis](#skrom.rom.rom_utils.update_basis) | Update a reduced basis by appending new modes from deflated snapshots. |

### collect_residuals { #skrom.rom.rom_utils.collect_residuals }

```python
rom.rom_utils.collect_residuals(
    NLS_train_ms,
    NLS_train_mean,
    V_sel,
    reconstruct_solution,
    Residual,
    training_params,
    assemble_kwargs,
    extra_kwargs=None,
)
```

Collect reduced evaluations of the ROM residual functional for hyperreduction.

This function processes training snapshots to collect residual evaluations that will
be used for hyperreduction (reducing computational cost of nonlinear ROM terms).

#### Parameters {.doc-section .doc-section-parameters}

| Name                 | Type                                  | Description                                                                                                                          | Default    |
|----------------------|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|------------|
| fos_solutions        | ndarray                               | Full order solutions (not directly used but maintained for interface consistency)                                                    | _required_ |
| NLS_train_ms         | (ndarray, shape(n_snapshots, n_dofs)) | Mean-subtracted training snapshots (temperature fluctuations from mean)                                                              | _required_ |
| NLS_train_mean       | (ndarray, shape(n_dofs))              | Mean temperature field across all training snapshots                                                                                 | _required_ |
| V_sel                | (ndarray, shape(n_dofs, n_modes))     | Selected POD basis matrix (reduced basis vectors)                                                                                    | _required_ |
| reconstruct_solution | callable                              | Function to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean) | _required_ |
| Residual             | LinearFormROM object                  | ROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)           | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name   | Type                                                 | Description                                                                                                                          |
|--------|------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| q_mus  | (ndarray, shape(n_snapshots, n_residual_components)) | Collected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter |

### compute_nonlinear_snapshots { #skrom.rom.rom_utils.compute_nonlinear_snapshots }

```python
rom.rom_utils.compute_nonlinear_snapshots(
    non_linear_func,
    fos_solutions,
    param_list,
)
```

Evaluate a nonlinear RHS function over a set of FOM snapshots.

#### Parameters {.doc-section .doc-section-parameters}

| Name            | Type   | Description                                                                     | Default    |
|-----------------|--------|---------------------------------------------------------------------------------|------------|
| non_linear_func |        | A function with signature non_linear_func(u=<solution>, param=<param>) → array. | _required_ |
| fos_solutions   |        | Sequence of full-order solutions (each an ndarray).                             | _required_ |
| param_list      |        | Sequence of parameter values, same length as fos_solutions.                     | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name   | Type    | Description                                                                                                             |
|--------|---------|-------------------------------------------------------------------------------------------------------------------------|
| F_nl   | ndarray | Array of shape (n_snapshots, ...) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]). |

### generate_gaussian_samples { #skrom.rom.rom_utils.generate_gaussian_samples }

```python
rom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)
```

Generate Gaussian-distributed samples based on bounds-derived statistics.

#### Parameters {.doc-section .doc-section-parameters}

| Name       | Type                   | Description                                                                              | Default    |
|------------|------------------------|------------------------------------------------------------------------------------------|------------|
| dimensions | int                    | Number of dimensions.                                                                    | _required_ |
| num_points | int                    | Number of points to generate.                                                            | _required_ |
| bounds     | list of tuple of float | List of (lower, upper) bounds for each dimension; means and stds are derived from these. | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name    | Type                                     | Description                                                           |
|---------|------------------------------------------|-----------------------------------------------------------------------|
| samples | (ndarray, shape(num_points, dimensions)) | Gaussian-distributed samples without clipping to the original bounds. |

### generate_lhs { #skrom.rom.rom_utils.generate_lhs }

```python
rom.rom_utils.generate_lhs(dimensions, num_points, bounds)
```

Generate a Latin Hypercube Sample (LHS) scaled to given bounds.

#### Parameters {.doc-section .doc-section-parameters}

| Name       | Type                   | Description                                       | Default    |
|------------|------------------------|---------------------------------------------------|------------|
| dimensions | int                    | Number of dimensions in the sample.               | _required_ |
| num_points | int                    | Number of points to generate.                     | _required_ |
| bounds     | list of tuple of float | List of (lower, upper) bounds for each dimension. | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name           | Type                                     | Description                                |
|----------------|------------------------------------------|--------------------------------------------|
| scaled_samples | (ndarray, shape(num_points, dimensions)) | LHS samples scaled to the provided bounds. |

### generate_sobol { #skrom.rom.rom_utils.generate_sobol }

```python
rom.rom_utils.generate_sobol(dimensions, num_points, bounds)
```

Generate a Sobol sequence scaled to given bounds.

#### Parameters {.doc-section .doc-section-parameters}

| Name       | Type                   | Description                                                | Default    |
|------------|------------------------|------------------------------------------------------------|------------|
| dimensions | int                    | Number of dimensions in the Sobol sequence.                | _required_ |
| num_points | int                    | Number of points in the sequence (must be a power of two). | _required_ |
| bounds     | list of tuple of float | List of (lower, upper) bounds for each dimension.          | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name           | Type                                     | Description                                           |
|----------------|------------------------------------------|-------------------------------------------------------|
| scaled_samples | (ndarray, shape(num_points, dimensions)) | Sobol sequence samples scaled to the provided bounds. |

### latin_hypercube_train_test_split { #skrom.rom.rom_utils.latin_hypercube_train_test_split }

```python
rom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)
```

Split snapshots into training and testing masks via Latin Hypercube Sampling.

#### Parameters {.doc-section .doc-section-parameters}

| Name             | Type   | Description                                                              | Default    |
|------------------|--------|--------------------------------------------------------------------------|------------|
| N_snap           | int    | Total number of snapshots.                                               | _required_ |
| train_percentage | float  | Proportion of snapshots to include in the training set. Defaults to 0.8. | `0.8`      |

#### Returns {.doc-section .doc-section-returns}

| Name       | Type                             | Description                                 |
|------------|----------------------------------|---------------------------------------------|
| train_mask | ndarray of bool, shape (N_snap,) | Boolean mask indicating training snapshots. |
| test_mask  | ndarray of bool, shape (N_snap,) | Boolean mask indicating testing snapshots.  |

### load_rom_data { #skrom.rom.rom_utils.load_rom_data }

```python
rom.rom_utils.load_rom_data(self, rom_data_dir=None)
```

Load ROM data from a ROM_data directory or module path.

#### Parameters {.doc-section .doc-section-parameters}

| Name         | Type               | Description                                                                            | Default    |
|--------------|--------------------|----------------------------------------------------------------------------------------|------------|
| self         | object or None     | If an instance is provided, data is loaded into attributes; if None, data is returned. | _required_ |
| rom_data_dir | str, Path, or None | Directory or module path to load ROM_data from. Default is None (auto-detect).         | `None`     |

#### Returns {.doc-section .doc-section-returns}

| Name          | Type    | Description                                                                                |
|---------------|---------|--------------------------------------------------------------------------------------------|
| fos_solutions | ndarray | Loaded full-order solution snapshots.                                                      |
| sim_data      | dict    | Dictionary of loaded simulation data when self is None; otherwise sets attributes on self. |

### newton_hyper_rom_solver { #skrom.rom.rom_utils.newton_hyper_rom_solver }

```python
rom.rom_utils.newton_hyper_rom_solver(
    assemble_func,
    u,
    tol=0.03,
    maxit=200,
    param=None,
)
```

Solve a hyper-reduced ROM system via Newton's method.

#### Parameters {.doc-section .doc-section-parameters}

| Name     | Type    | Description                                                               | Default    |
|----------|---------|---------------------------------------------------------------------------|------------|
| instance | object  | Object with method assemble_hyper_rom_system(u, params) returning (A, y). | _required_ |
| u        | ndarray | Initial reduced solution vector, updated in place.                        | _required_ |
| tol      | float   | Convergence tolerance on the norm of the update. Defaults to 1e-2.        | `0.03`     |
| maxit    | int     | Maximum number of Newton iterations. Defaults to 50.                      | `200`      |
| params   | any     | Additional parameters passed to assemble_hyper_rom_system.                | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name   | Type    | Description                 |
|--------|---------|-----------------------------|
| u      | ndarray | Converged reduced solution. |

#### Raises {.doc-section .doc-section-raises}

| Name   | Type         | Description                                             |
|--------|--------------|---------------------------------------------------------|
|        | RuntimeError | If convergence is not achieved within maxit iterations. |

### newton_solver_rom { #skrom.rom.rom_utils.newton_solver_rom }

```python
rom.rom_utils.newton_solver_rom(
    assemble_func,
    u_rom,
    *args,
    alpha=1.0,
    tol=0.001,
    maxit=100,
    use_lu=False,
    jac_tol=0.1,
    **kwargs,
)
```

Solve nonlinear reduced-order system using Newton's method.

Provides two solution strategies: efficient LU refactorization for ROM
systems or direct solving with adaptive step damping.

#### Parameters {.doc-section .doc-section-parameters}

| Name          | Type         | Description                                                                                                                             | Default    |
|---------------|--------------|-----------------------------------------------------------------------------------------------------------------------------------------|------------|
| assemble_func | callable     | Function that assembles Jacobian and residual: (J, R) = func(u_rom, ...)                                                                | _required_ |
| u_rom         | array - like | Initial guess for reduced-order state vector                                                                                            | _required_ |
| *args         | tuple        | Additional positional arguments passed to assemble_func                                                                                 | `()`       |
| alpha         | float        | Step size damping factor (only used when use_lu=False)                                                                                  | `1.0`      |
| tol           | float        | Convergence tolerance on Newton step norm                                                                                               | `1e-3`     |
| maxit         | int          | Maximum number of Newton iterations                                                                                                     | `100`      |
| use_lu        | bool         | If True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction. | `False`    |
| jac_tol       | float        | Relative tolerance for Jacobian reuse (only used when use_lu=True)                                                                      | `1e-1`     |
| **kwargs      | dict         | Additional keyword arguments passed to assemble_func                                                                                    | `{}`       |

#### Returns {.doc-section .doc-section-returns}

| Name   | Type         | Description                                |
|--------|--------------|--------------------------------------------|
|        | array - like | Converged reduced-order state vector u_rom |

#### Raises {.doc-section .doc-section-raises}

| Name   | Type         | Description                                                                           |
|--------|--------------|---------------------------------------------------------------------------------------|
|        | RuntimeError | If Newton iteration fails to converge within maxit iterations (only when use_lu=True) |

#### Notes {.doc-section .doc-section-notes}

- LU mode: Reuses Jacobian factorization until relative change exceeds jac_tol
- Direct mode: Applies adaptive damping every 40 iterations, includes logging
- Part of ROM workflow for efficient nonlinear system solving

### reconstruct_solution { #skrom.rom.rom_utils.reconstruct_solution }

```python
rom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)
```

Reconstruct a full-order solution from a reduced solution vector.

#### Parameters {.doc-section .doc-section-parameters}

| Name      | Type                     | Description                                                | Default    |
|-----------|--------------------------|------------------------------------------------------------|------------|
| u_reduced | (ndarray, shape(r))      | Reduced solution vector.                                   | _required_ |
| V_sel     | (ndarray, shape(N_h, r)) | Basis matrix for free degrees of freedom.                  | _required_ |
| mean      | (ndarray, shape(N_h))    | Mean vector that was subtracted during snapshot centering. | _required_ |

#### Returns {.doc-section .doc-section-returns}

| Name   | Type                  | Description                                       |
|--------|-----------------------|---------------------------------------------------|
| u_full | (ndarray, shape(N_h)) | Full-order solution vector, including mean shift. |

### rom_data_gen { #skrom.rom.rom_utils.rom_data_gen }

```python
rom.rom_utils.rom_data_gen(save_kw, problem_path)
```

Save ROM simulation data to disk.

#### Parameters {.doc-section .doc-section-parameters}

| Name         | Type        | Description                                                             | Default    |
|--------------|-------------|-------------------------------------------------------------------------|------------|
| save_kw      | dict        | Dictionary containing simulation outputs; must include 'fos_solutions'. | _required_ |
| problem_path | str or Path | Filesystem path to the problem directory.                               | _required_ |

#### Raises {.doc-section .doc-section-raises}

| Name   | Type     | Description                                   |
|--------|----------|-----------------------------------------------|
|        | KeyError | If 'fos_solutions' key is missing in save_kw. |

### select_elements_and_gauss_weights { #skrom.rom.rom_utils.select_elements_and_gauss_weights }

```python
rom.rom_utils.select_elements_and_gauss_weights(
    n_gauss_points,
    element_indices,
    weights,
)
```

Select elements and corresponding weights from Gauss points, ensuring consistency
by including all Gauss points for each selected element with zero weights for unselected points.

Parameters:
n_gauss_points (int): Number of Gauss points per element.
element_indices (list or array): Selected Gauss point indices from ECM.
weights (list or array): Corresponding weights for selected indices.

Returns:
dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points.
      For each selected element, the list will have exactly `n_gauss_points` entries.

### sobol_train_test_split { #skrom.rom.rom_utils.sobol_train_test_split }

```python
rom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)
```

Split snapshots into training and testing masks via Sobol sequence ordering.

#### Parameters {.doc-section .doc-section-parameters}

| Name             | Type   | Description                                                              | Default    |
|------------------|--------|--------------------------------------------------------------------------|------------|
| N_snap           | int    | Total number of snapshots.                                               | _required_ |
| train_percentage | float  | Proportion of snapshots to include in the training set. Defaults to 0.8. | `0.8`      |

#### Returns {.doc-section .doc-section-returns}

| Name       | Type                             | Description                                 |
|------------|----------------------------------|---------------------------------------------|
| train_mask | ndarray of bool, shape (N_snap,) | Boolean mask indicating training snapshots. |
| test_mask  | ndarray of bool, shape (N_snap,) | Boolean mask indicating testing snapshots.  |

### train_test_split { #skrom.rom.rom_utils.train_test_split }

```python
rom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)
```

Split snapshot indices into training and testing masks.

#### Parameters {.doc-section .doc-section-parameters}

| Name             | Type        | Description                                                                                       | Default    |
|------------------|-------------|---------------------------------------------------------------------------------------------------|------------|
| N_snap           | int         | Total number of snapshots.                                                                        | _required_ |
| N_sel            | int or None | Number of snapshots to select before splitting. If None, all snapshots are used. Default is None. | `None`     |
| train_percentage | float       | Proportion of snapshots to include in the training set. Defaults to 0.8.                          | `0.8`      |

#### Returns {.doc-section .doc-section-returns}

| Name       | Type                             | Description                                 |
|------------|----------------------------------|---------------------------------------------|
| train_mask | ndarray of bool, shape (N_snap,) | Boolean mask indicating training snapshots. |
| test_mask  | ndarray of bool, shape (N_snap,) | Boolean mask indicating testing snapshots.  |

### update_basis { #skrom.rom.rom_utils.update_basis }

```python
rom.rom_utils.update_basis(V, W_mu, max_modes=5)
```

Update a reduced basis by appending new modes from deflated snapshots.

#### Parameters {.doc-section .doc-section-parameters}

| Name      | Type                         | Description                                                          | Default    |
|-----------|------------------------------|----------------------------------------------------------------------|------------|
| V         | (ndarray, shape(N_h, r_old)) | Current orthonormal reduced basis.                                   | _required_ |
| W_mu      | (ndarray, shape(N_h, N_t))   | New high-fidelity snapshots for parameter μ.                         | _required_ |
| max_modes | int                          | Maximum number of new modes to append from deflation. Defaults to 5. | `5`        |

#### Returns {.doc-section .doc-section-returns}

| Name   | Type                             | Description                                                   |
|--------|----------------------------------|---------------------------------------------------------------|
| V_new  | (ndarray, shape(N_h, r_old + k)) | Re-orthonormalized basis combining old and newly added modes. |