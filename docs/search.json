[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to skrom",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy."
  },
  {
    "objectID": "index.html#linear-heat-conduction-example-problem",
    "href": "index.html#linear-heat-conduction-example-problem",
    "title": "Welcome to skrom",
    "section": "Linear Heat Conduction example problem",
    "text": "Linear Heat Conduction example problem\n1D steady heat conduction equation with constant parameters:\n\\[\n- \\frac{d}{dx} \\left( k \\frac{dT}{dx} \\right) = q, \\quad x \\in [0, L],\n\\]\nwith the boundary conditions:\n\n\\(\\left. \\frac{dT}{dx} \\right|_{x=0} = 0\\) (Neumann),\n\\(T(L) = T_L\\) (Dirichlet).\n\nHere, \\(k = 16 + \\mu\\) and \\(q = 35000 + \\beta\\).\nTo derive the finite element formulation, we first multiply the strong form by a test function \\(v(x) \\in V\\), where \\(V\\) is the space of admissible test functions that vanish at the Dirichlet boundary. Integrating over the domain, we obtain the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q v(x) \\, dx.\n\\]\nLet us discretize the domain into \\(N\\) linear finite elements. We express the approximate solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are the piecewise linear basis functions and \\(T_j\\) are the nodal temperature values to be determined. Similarly, we choose test functions from the same basis: \\(v(x) = \\phi_i(x)\\).\nSubstituting into the weak form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q \\phi_i(x) \\, dx \\quad \\text{for } i = 1, \\dots, n.\n\\]\nThis leads to the standard finite element system:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwhere\n\n\\(\\mathbf{K}_{ij} = \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx\\) is the stiffness matrix,\n\\(\\mathbf{F}_i = \\int_0^L q \\phi_i(x) \\, dx\\) is the load vector,\n\\(\\mathbf{T} = [T_1, T_2, \\dots, T_n]^T\\) is the vector of unknown nodal temperatures.\n\nSince \\(k\\) and \\(q\\) are constant (parameter dependent), these integrals simplify over each element \\(e \\in [x_e, x_{e+1}]\\). On a uniform mesh, using linear shape functions:\n\nLocal stiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLocal load vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix},\n\\]\n\nwhere \\(h\\) is the element length.\nWe then assemble these local matrices into the global system. The Neumann boundary condition at \\(x = 0\\) contributes nothing (natural condition), and the Dirichlet boundary condition \\(T(L) = T_L\\) is imposed by modifying the last row of the global system accordingly.\nAfter applying the boundary conditions, the resulting linear system can be solved for the nodal values of the temperature field \\(\\mathbf{T}\\). This provides a numerical approximation to the analytical solution:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2).\n\\]\nBelow we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html",
    "href": "Resources/intro/rom_intro_ex.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#linear-heat-conduction-example-problem",
    "href": "Resources/intro/rom_intro_ex.html#linear-heat-conduction-example-problem",
    "title": "skrom",
    "section": "",
    "text": "1D steady heat conduction equation with constant parameters:\n\\[\n- \\frac{d}{dx} \\left( k \\frac{dT}{dx} \\right) = q, \\quad x \\in [0, L],\n\\]\nwith the boundary conditions:\n\n\\(\\left. \\frac{dT}{dx} \\right|_{x=0} = 0\\) (Neumann),\n\\(T(L) = T_L\\) (Dirichlet).\n\nHere, \\(k = 16 + \\mu\\) and \\(q = 35000 + \\beta\\).\nTo derive the finite element formulation, we first multiply the strong form by a test function \\(v(x) \\in V\\), where \\(V\\) is the space of admissible test functions that vanish at the Dirichlet boundary. Integrating over the domain, we obtain the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q v(x) \\, dx.\n\\]\nLet us discretize the domain into \\(N\\) linear finite elements. We express the approximate solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are the piecewise linear basis functions and \\(T_j\\) are the nodal temperature values to be determined. Similarly, we choose test functions from the same basis: \\(v(x) = \\phi_i(x)\\).\nSubstituting into the weak form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q \\phi_i(x) \\, dx \\quad \\text{for } i = 1, \\dots, n.\n\\]\nThis leads to the standard finite element system:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwhere\n\n\\(\\mathbf{K}_{ij} = \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx\\) is the stiffness matrix,\n\\(\\mathbf{F}_i = \\int_0^L q \\phi_i(x) \\, dx\\) is the load vector,\n\\(\\mathbf{T} = [T_1, T_2, \\dots, T_n]^T\\) is the vector of unknown nodal temperatures.\n\nSince \\(k\\) and \\(q\\) are constant (parameter dependent), these integrals simplify over each element \\(e \\in [x_e, x_{e+1}]\\). On a uniform mesh, using linear shape functions:\n\nLocal stiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLocal load vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix},\n\\]\n\nwhere \\(h\\) is the element length.\nWe then assemble these local matrices into the global system. The Neumann boundary condition at \\(x = 0\\) contributes nothing (natural condition), and the Dirichlet boundary condition \\(T(L) = T_L\\) is imposed by modifying the last row of the global system accordingly.\nAfter applying the boundary conditions, the resulting linear system can be solved for the nodal values of the temperature field \\(\\mathbf{T}\\). This provides a numerical approximation to the analytical solution:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2).\n\\]\nBelow we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html",
    "href": "reference/utils.visualization.generate_vtu.html",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "utils.visualization.generate_vtu\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html#functions",
    "href": "reference/utils.visualization.generate_vtu.html#functions",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html",
    "href": "reference/utils.visualization.color_palette.html",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "utils.visualization.color_palette\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html#functions",
    "href": "reference/utils.visualization.color_palette.html#functions",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.rom_error_est.html",
    "href": "reference/utils.rom_error_est.html",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "utils.rom_error_est\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.rom_error_est.html#functions",
    "href": "reference/utils.rom_error_est.html#functions",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.reduced_basis.html",
    "href": "reference/utils.reduced_basis.html",
    "title": "utils.reduced_basis",
    "section": "",
    "text": "utils.reduced_basis\nutils.reduced_basis",
    "crumbs": [
      "Utilities",
      "utils.reduced_basis"
    ]
  },
  {
    "objectID": "reference/utils.old.rom_utils_old.html",
    "href": "reference/utils.old.rom_utils_old.html",
    "title": "utils.old.rom_utils_old",
    "section": "",
    "text": "utils.old.rom_utils_old\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\ngenerate_sobol\nGenerate a scaled Sobol sequence.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\nload_rom_data\nLoad ROM data from disk into memory or object attributes.\n\n\nnewton_rom_solver\nSolve ROM equations via Newton’s method.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\ntrain_test_split\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\nutils.old.rom_utils_old.generate_gaussian_samples(\n    dimensions,\n    num_points,\n    bounds,\n)\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of samples to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension; used to compute means and std devs.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian random samples (not clipped to bounds).\n\n\n\n\n\n\n\nMean is (min+max)/2, std dev is (max-min)/5.\n\n\n\n\n&gt;&gt;&gt; gauss = generate_gaussian_samples(2, 50, [(-2,2), (0,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of sample dimensions.\nrequired\n\n\nnum_points\nint\nNumber of LHS points to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) pairs per dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nLHS points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; lhs_pts = generate_lhs(3, 10, [(0,1), (1,2), (-1,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_sobol(dimensions, num_points, bounds)\nGenerate a scaled Sobol sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions for the sequence.\nrequired\n\n\nnum_points\nint\nNumber of Sobol points to generate (power of two recommended).\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nSobol sequence points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; sobol_pts = generate_sobol(2, 8, [(0,1), (0,5)])\n\n\n\n\nutils.old.rom_utils_old.latin_hypercube_train_test_split(\n    N_snap,\n    train_percentage=0.8,\n)\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nMask of training snapshots selected via LHS ordering.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nMask of testing snapshots.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = latin_hypercube_train_test_split(50, 0.6)\n\n\n\n\nutils.old.rom_utils_old.load_rom_data(self=None, rom_data_dir=None)\nLoad ROM data from disk into memory or object attributes.\nSearches for fos_solutions.npy and ROM_simulation_data.npz under the given directory (or infers from self.problem_name), loads arrays, and returns or assigns them.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf None, function returns data; otherwise assigns to self attributes.\nNone\n\n\nrom_data_dir\nstr or Path\nDirectory containing ROM_data; if None, inferred from self.problem_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fos_solutions, sim_data) if self is None\nTuple of the full-order solutions array and dict of other data.\n\n\n\nNone if self is not None\nData assigned as attributes on self.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf expected data files are missing.\n\n\n\n\n\n\n&gt;&gt;&gt; sols, data = load_rom_data(None, '/path/ROM_data')\n&gt;&gt;&gt; load_rom_data(problem_instance, rom_data_dir)\n\n\n\n\nutils.old.rom_utils_old.newton_rom_solver(\n    instance,\n    u,\n    tol=0.01,\n    maxit=50,\n    params=None,\n)\nSolve ROM equations via Newton’s method.\nIteratively updates the reduced coefficients u to converge to the full-order solution based on provided reduced operators and interpolation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nROM object with attributes T_ref, U, basis, and method reduced_operators.\nrequired\n\n\nu\nndarray\nInitial reduced coefficients vector.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the change norm (default is 1e-2).\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations (default is 50).\n50\n\n\nparams\ndict or None\nOptional parameters to pass to reduced_operators.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_sol\nndarray\nReconstructed full-order solution upon convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; u0 = np.zeros(instance.U.shape[1])\n&gt;&gt;&gt; u_sol = newton_rom_solver(instance, u0, tol=1e-5)\n\n\n\n\nutils.old.rom_utils_old.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\nExtracts full-order solutions and other simulation outputs into a dedicated ROM_data folder under problem_path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nKeyword-data mapping containing at least the key ‘fos_solutions’ for full-order snapshots and other arrays to save.\nrequired\n\n\nproblem_path\nstr or Path\nBase directory for the ROM_data subfolder.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n&gt;&gt;&gt; rom_data_gen({'fos_solutions': sols, 'U': U, 'basis': basis}, '/path/to/problem')\n\n\n\n\nutils.old.rom_utils_old.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of snapshots to split.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots assigned to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered training mask.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered testing mask.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = sobol_train_test_split(32)\n\n\n\n\nutils.old.rom_utils_old.train_test_split(\n    N_snap,\n    N_sel=None,\n    train_percentage=0.8,\n)\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots available.\nrequired\n\n\nN_sel\nint\nNumber of snapshots to select for splitting. If provided, samples are randomly chosen without replacement from the full set before splitting. Default is None (use all snapshots).\nNone\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to the training set (between 0 and 1). Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training samples.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing samples.\n\n\n\n\n\n\n\nIf N_sel is given, train_percentage is still applied relative to N_snap.\nMasks are built by first permuting or selecting indices, then assigning the first int(N_snap * train_percentage) to training, the rest to testing.\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = train_test_split(100, train_percentage=0.75)\n&gt;&gt;&gt; np.sum(train_mask), np.sum(test_mask)\n(75, 25)",
    "crumbs": [
      "Utilities",
      "utils.old.rom_utils_old"
    ]
  },
  {
    "objectID": "reference/utils.old.rom_utils_old.html#functions",
    "href": "reference/utils.old.rom_utils_old.html#functions",
    "title": "utils.old.rom_utils_old",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\ngenerate_sobol\nGenerate a scaled Sobol sequence.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\nload_rom_data\nLoad ROM data from disk into memory or object attributes.\n\n\nnewton_rom_solver\nSolve ROM equations via Newton’s method.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\ntrain_test_split\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\nutils.old.rom_utils_old.generate_gaussian_samples(\n    dimensions,\n    num_points,\n    bounds,\n)\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of samples to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension; used to compute means and std devs.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian random samples (not clipped to bounds).\n\n\n\n\n\n\n\nMean is (min+max)/2, std dev is (max-min)/5.\n\n\n\n\n&gt;&gt;&gt; gauss = generate_gaussian_samples(2, 50, [(-2,2), (0,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of sample dimensions.\nrequired\n\n\nnum_points\nint\nNumber of LHS points to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) pairs per dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nLHS points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; lhs_pts = generate_lhs(3, 10, [(0,1), (1,2), (-1,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_sobol(dimensions, num_points, bounds)\nGenerate a scaled Sobol sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions for the sequence.\nrequired\n\n\nnum_points\nint\nNumber of Sobol points to generate (power of two recommended).\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nSobol sequence points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; sobol_pts = generate_sobol(2, 8, [(0,1), (0,5)])\n\n\n\n\nutils.old.rom_utils_old.latin_hypercube_train_test_split(\n    N_snap,\n    train_percentage=0.8,\n)\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nMask of training snapshots selected via LHS ordering.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nMask of testing snapshots.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = latin_hypercube_train_test_split(50, 0.6)\n\n\n\n\nutils.old.rom_utils_old.load_rom_data(self=None, rom_data_dir=None)\nLoad ROM data from disk into memory or object attributes.\nSearches for fos_solutions.npy and ROM_simulation_data.npz under the given directory (or infers from self.problem_name), loads arrays, and returns or assigns them.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf None, function returns data; otherwise assigns to self attributes.\nNone\n\n\nrom_data_dir\nstr or Path\nDirectory containing ROM_data; if None, inferred from self.problem_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fos_solutions, sim_data) if self is None\nTuple of the full-order solutions array and dict of other data.\n\n\n\nNone if self is not None\nData assigned as attributes on self.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf expected data files are missing.\n\n\n\n\n\n\n&gt;&gt;&gt; sols, data = load_rom_data(None, '/path/ROM_data')\n&gt;&gt;&gt; load_rom_data(problem_instance, rom_data_dir)\n\n\n\n\nutils.old.rom_utils_old.newton_rom_solver(\n    instance,\n    u,\n    tol=0.01,\n    maxit=50,\n    params=None,\n)\nSolve ROM equations via Newton’s method.\nIteratively updates the reduced coefficients u to converge to the full-order solution based on provided reduced operators and interpolation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nROM object with attributes T_ref, U, basis, and method reduced_operators.\nrequired\n\n\nu\nndarray\nInitial reduced coefficients vector.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the change norm (default is 1e-2).\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations (default is 50).\n50\n\n\nparams\ndict or None\nOptional parameters to pass to reduced_operators.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_sol\nndarray\nReconstructed full-order solution upon convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; u0 = np.zeros(instance.U.shape[1])\n&gt;&gt;&gt; u_sol = newton_rom_solver(instance, u0, tol=1e-5)\n\n\n\n\nutils.old.rom_utils_old.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\nExtracts full-order solutions and other simulation outputs into a dedicated ROM_data folder under problem_path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nKeyword-data mapping containing at least the key ‘fos_solutions’ for full-order snapshots and other arrays to save.\nrequired\n\n\nproblem_path\nstr or Path\nBase directory for the ROM_data subfolder.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n&gt;&gt;&gt; rom_data_gen({'fos_solutions': sols, 'U': U, 'basis': basis}, '/path/to/problem')\n\n\n\n\nutils.old.rom_utils_old.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of snapshots to split.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots assigned to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered training mask.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered testing mask.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = sobol_train_test_split(32)\n\n\n\n\nutils.old.rom_utils_old.train_test_split(\n    N_snap,\n    N_sel=None,\n    train_percentage=0.8,\n)\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots available.\nrequired\n\n\nN_sel\nint\nNumber of snapshots to select for splitting. If provided, samples are randomly chosen without replacement from the full set before splitting. Default is None (use all snapshots).\nNone\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to the training set (between 0 and 1). Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training samples.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing samples.\n\n\n\n\n\n\n\nIf N_sel is given, train_percentage is still applied relative to N_snap.\nMasks are built by first permuting or selecting indices, then assigning the first int(N_snap * train_percentage) to training, the rest to testing.\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = train_test_split(100, train_percentage=0.75)\n&gt;&gt;&gt; np.sum(train_mask), np.sum(test_mask)\n(75, 25)",
    "crumbs": [
      "Utilities",
      "utils.old.rom_utils_old"
    ]
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html",
    "href": "reference/utils.newton_solver_rom.html",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "utils.newton_solver_rom\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html#functions",
    "href": "reference/utils.newton_solver_rom.html#functions",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.fem_utils.html",
    "href": "reference/utils.fem_utils.html",
    "title": "utils.fem_utils",
    "section": "",
    "text": "utils.fem_utils\nutils.fem_utils"
  },
  {
    "objectID": "reference/utils.custom_nnls.html",
    "href": "reference/utils.custom_nnls.html",
    "title": "utils.custom_nnls",
    "section": "",
    "text": "utils.custom_nnls\nutils.custom_nnls"
  },
  {
    "objectID": "reference/utils.basic.html",
    "href": "reference/utils.basic.html",
    "title": "utils.basic",
    "section": "",
    "text": "utils.basic\nutils.basic\nThis module imports essential libraries commonly used in pyHyperRom. By using from pyHyperRom.basic import *, users can access frequently utilized libraries."
  },
  {
    "objectID": "reference/rom.rom_error_est.html",
    "href": "reference/rom.rom_error_est.html",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "rom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\nThis module provides: - compute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm). - plot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up. - generate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console.\nThe rom folder contains core tools for reduced-order modeling, including: - Assembly abstractions for reduced bilinear and linear forms - Error evaluation and reporting utilities (this module) - Hyper-reduction and cubature integration tools\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html#functions",
    "href": "reference/rom.rom_error_est.html#functions",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html",
    "href": "reference/rom.linear_form_hyperrom.html",
    "title": "rom.linear_form_hyperrom",
    "section": "",
    "text": "rom.linear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(**kwargs)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.linear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#classes",
    "href": "reference/rom.linear_form_hyperrom.html#classes",
    "title": "rom.linear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(**kwargs)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html",
    "href": "reference/rom.ecsw.hyperreduce.html",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "rom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "ECSW",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html#functions",
    "href": "reference/rom.ecsw.hyperreduce.html#functions",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "ECSW",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html",
    "href": "reference/rom.bilinear_form_rom.html",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\nThis module provides: - BilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html#classes",
    "href": "reference/rom.bilinear_form_rom.html#classes",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html",
    "href": "reference/problem_classes.master_class_static.html",
    "title": "problem_classes.master_class_static",
    "section": "",
    "text": "problem_classes.master_class_static\nModule for static reduced-order modeling (ROM):\n\nDynamic import of problem definitions\nFull-order FEM solver (FOM)\nOffline snapshot generator\nOnline ROM evaluator\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nProblem\nAbstract base for conductivity problems under affine decomposition.\n\n\nfom_simulation\nOffline snapshot generator using full-order FEM.\n\n\nrom_simulation\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\n\nproblem_classes.master_class_static.Problem()\nAbstract base for conductivity problems under affine decomposition.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn affine bilinear form components.\n\n\ndomain\nReturn geometry and FEM bases.\n\n\nfom_solver\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn affine linear form components.\n\n\nparameters\nGenerate sampling of parameter space.\n\n\nproperties\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nSolve reduced-order model for given parameters.\n\n\n\n\n\nproblem_classes.master_class_static.Problem.bilinear_forms()\nReturn affine bilinear form components.\n\n\n\nproblem_classes.master_class_static.Problem.domain()\nReturn geometry and FEM bases.\n\n\n\nproblem_classes.master_class_static.Problem.fom_solver()\nSolve full-order FEM system for given parameters.\n\n\n\nproblem_classes.master_class_static.Problem.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\n\nproblem_classes.master_class_static.Problem.linear_forms()\nReturn affine linear form components.\n\n\n\nproblem_classes.master_class_static.Problem.parameters()\nGenerate sampling of parameter space.\n\n\n\nproblem_classes.master_class_static.Problem.properties()\nReturn function to compute parameter-dependent coefficients.\n\n\n\nproblem_classes.master_class_static.Problem.rom_solver()\nSolve reduced-order model for given parameters.\n\n\n\n\n\nproblem_classes.master_class_static.fom_simulation(num_snapshots=32)\nOffline snapshot generator using full-order FEM.\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun_simulation\nGenerate snapshots and record timings.\n\n\n\n\n\nproblem_classes.master_class_static.fom_simulation.run_simulation()\nGenerate snapshots and record timings.\n\n\n\n\n\nproblem_classes.master_class_static.rom_simulation(\n    mean=None,\n    fos_solutions=None,\n    train_mask=None,\n    test_mask=None,\n    V_sel=None,\n    n_sel=None,\n    N_rom_snap=None,\n)\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun_hyper_rom_simulation\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\nrun_rom_simulation\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\n\nproblem_classes.master_class_static.rom_simulation.run_hyper_rom_simulation(z)\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\narray_like\nWeight vector for hyper-reduction (stored for reference).\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nhyper_rom_error\nlist of float\nPercent error per snapshot.\n\n\nhyper_speed_up\nlist of float\nFull/FOM time ratio per snapshot.\n\n\n\n\n\n\n\nproblem_classes.master_class_static.rom_simulation.run_rom_simulation()\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrom_error\nlist of float\nPercent error per snapshot.\n\n\nspeed_up\nlist of float\nFull/ROM time ratio per snapshot.\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_problem\nInstantiate a registered problem by name.\n\n\nregister_problem\nDecorator to register a problem class under a given name.\n\n\n\n\n\nproblem_classes.master_class_static.get_problem(name)\nInstantiate a registered problem by name.\n\n\n\nproblem_classes.master_class_static.register_problem(name)\nDecorator to register a problem class under a given name.",
    "crumbs": [
      "Problem Classes",
      "problem_classes.master_class_static"
    ]
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#classes",
    "href": "reference/problem_classes.master_class_static.html#classes",
    "title": "problem_classes.master_class_static",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nProblem\nAbstract base for conductivity problems under affine decomposition.\n\n\nfom_simulation\nOffline snapshot generator using full-order FEM.\n\n\nrom_simulation\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\n\nproblem_classes.master_class_static.Problem()\nAbstract base for conductivity problems under affine decomposition.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn affine bilinear form components.\n\n\ndomain\nReturn geometry and FEM bases.\n\n\nfom_solver\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn affine linear form components.\n\n\nparameters\nGenerate sampling of parameter space.\n\n\nproperties\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nSolve reduced-order model for given parameters.\n\n\n\n\n\nproblem_classes.master_class_static.Problem.bilinear_forms()\nReturn affine bilinear form components.\n\n\n\nproblem_classes.master_class_static.Problem.domain()\nReturn geometry and FEM bases.\n\n\n\nproblem_classes.master_class_static.Problem.fom_solver()\nSolve full-order FEM system for given parameters.\n\n\n\nproblem_classes.master_class_static.Problem.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\n\nproblem_classes.master_class_static.Problem.linear_forms()\nReturn affine linear form components.\n\n\n\nproblem_classes.master_class_static.Problem.parameters()\nGenerate sampling of parameter space.\n\n\n\nproblem_classes.master_class_static.Problem.properties()\nReturn function to compute parameter-dependent coefficients.\n\n\n\nproblem_classes.master_class_static.Problem.rom_solver()\nSolve reduced-order model for given parameters.\n\n\n\n\n\nproblem_classes.master_class_static.fom_simulation(num_snapshots=32)\nOffline snapshot generator using full-order FEM.\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun_simulation\nGenerate snapshots and record timings.\n\n\n\n\n\nproblem_classes.master_class_static.fom_simulation.run_simulation()\nGenerate snapshots and record timings.\n\n\n\n\n\nproblem_classes.master_class_static.rom_simulation(\n    mean=None,\n    fos_solutions=None,\n    train_mask=None,\n    test_mask=None,\n    V_sel=None,\n    n_sel=None,\n    N_rom_snap=None,\n)\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun_hyper_rom_simulation\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\nrun_rom_simulation\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\n\nproblem_classes.master_class_static.rom_simulation.run_hyper_rom_simulation(z)\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\narray_like\nWeight vector for hyper-reduction (stored for reference).\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nhyper_rom_error\nlist of float\nPercent error per snapshot.\n\n\nhyper_speed_up\nlist of float\nFull/FOM time ratio per snapshot.\n\n\n\n\n\n\n\nproblem_classes.master_class_static.rom_simulation.run_rom_simulation()\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrom_error\nlist of float\nPercent error per snapshot.\n\n\nspeed_up\nlist of float\nFull/ROM time ratio per snapshot.",
    "crumbs": [
      "Problem Classes",
      "problem_classes.master_class_static"
    ]
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#functions",
    "href": "reference/problem_classes.master_class_static.html#functions",
    "title": "problem_classes.master_class_static",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_problem\nInstantiate a registered problem by name.\n\n\nregister_problem\nDecorator to register a problem class under a given name.\n\n\n\n\n\nproblem_classes.master_class_static.get_problem(name)\nInstantiate a registered problem by name.\n\n\n\nproblem_classes.master_class_static.register_problem(name)\nDecorator to register a problem class under a given name.",
    "crumbs": [
      "Problem Classes",
      "problem_classes.master_class_static"
    ]
  },
  {
    "objectID": "reference/hyperreduction.html",
    "href": "reference/hyperreduction.html",
    "title": "hyperreduction",
    "section": "",
    "text": "hyperreduction\nhyperreduction\nThe hyperreduce package provides tools to perform hyper‐reduction on full‐order models.\nContents: - bilinear_form_hyperrom.py & linear_form_hyperrom.py: Classes that cluster elements by free‐DOF counts, project local stiffness/load contributions onto reduced bases, and assemble global reduced matrices/vectors. - hyperreduce.py: End‐to‐end pipeline combining randomized SVD preprocessing with bounded NNLS solves for weight selection, plus plotting diagnostics. - custom_nnls.py: Wrapped NNLS solver specialized for hyper‐reduction constraints.\nThese modules streamline the construction of sparse, hyper‐reduced operators and right‐hand sides for fast, accurate reduced‐order simulations."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.html",
    "href": "reference/hyperreduction.ecsw.html",
    "title": "hyperreduction.ecsw",
    "section": "",
    "text": "hyperreduction.ecsw\nhyperreduction.ecsw"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "hyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/fom.fem_utils.html",
    "href": "reference/fom.fem_utils.html",
    "title": "fom.fem_utils",
    "section": "",
    "text": "fom.fem_utils\nThis module includes:\n\nbuild_pc_amgsa: construct AMG smoothed aggregation preconditioner.\nelement2location: generate element-to-coordinate mappings from mesh data.\nnewton_solver and its helpers: perform Newton–Raphson solves with or without Dirichlet BC.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nGiven a dict mapping region names to boolean element‐masks,\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_mesh_and_basis\nCall domain() and assign just mesh and basis onto self.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\nunwrap_attr\nIf self. is a 0-d object ndarray, replace it with its .item().\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nGiven a dict mapping region names to boolean element‐masks, returns a dict of reduced bases for each region.\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nCall domain() and assign just mesh and basis onto self.\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.\n\n\n\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nIf self. is a 0-d object ndarray, replace it with its .item().",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html#functions",
    "href": "reference/fom.fem_utils.html#functions",
    "title": "fom.fem_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nGiven a dict mapping region names to boolean element‐masks,\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_mesh_and_basis\nCall domain() and assign just mesh and basis onto self.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\nunwrap_attr\nIf self. is a 0-d object ndarray, replace it with its .item().\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nGiven a dict mapping region names to boolean element‐masks, returns a dict of reduced bases for each region.\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nCall domain() and assign just mesh and basis onto self.\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.\n\n\n\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nIf self. is a 0-d object ndarray, replace it with its .item().",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.bilinear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly"
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "hyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html",
    "href": "reference/hyperreduction.linear_form_hyperrom.html",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.linear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Classes for different problems\n\n\n\nproblem_classes\n\n\n\nproblem_classes.master_class_static\nModule for static reduced-order modeling (ROM):\n\n\n\n\n\n\nFull-order model builders and utilities\n\n\n\nfom\n\n\n\nfom.fem_utils\nThis module includes:\n\n\n\n\n\n\nReduced-order model builders and utilities\n\n\n\nrom\nThe rom folder provides core reduced‐order modeling tools:\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,\n\n\nrom.linear_form_hyperrom\n\n\n\n\n\n\n\nReduced-order model builders and utilities\n\n\n\nrom.ecsw\nThe ecsw folder implements Empirical Cubature Subset Weighting (ECSW) methods.\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\n\n\n\n\n\n\nCore helpers and reduced-basis tools\n\n\n\nutils\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.old\n\n\n\nutils.old.rom_utils_old\n\n\n\nutils.reduced_basis\n\n\n\nutils.reduced_basis.svd\n\n\n\n\n\n\n\nVTU/VTP writers, color palettes, and style packages\n\n\n\nutils.visualization\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#problem-classes",
    "href": "reference/index.html#problem-classes",
    "title": "Function reference",
    "section": "",
    "text": "Classes for different problems\n\n\n\nproblem_classes\n\n\n\nproblem_classes.master_class_static\nModule for static reduced-order modeling (ROM):",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#full-order-model-fom",
    "href": "reference/index.html#full-order-model-fom",
    "title": "Function reference",
    "section": "",
    "text": "Full-order model builders and utilities\n\n\n\nfom\n\n\n\nfom.fem_utils\nThis module includes:",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reduced-order-model-rom",
    "href": "reference/index.html#reduced-order-model-rom",
    "title": "Function reference",
    "section": "",
    "text": "Reduced-order model builders and utilities\n\n\n\nrom\nThe rom folder provides core reduced‐order modeling tools:\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,\n\n\nrom.linear_form_hyperrom",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ecsw",
    "href": "reference/index.html#ecsw",
    "title": "Function reference",
    "section": "",
    "text": "Reduced-order model builders and utilities\n\n\n\nrom.ecsw\nThe ecsw folder implements Empirical Cubature Subset Weighting (ECSW) methods.\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Function reference",
    "section": "",
    "text": "Core helpers and reduced-basis tools\n\n\n\nutils\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.old\n\n\n\nutils.old.rom_utils_old\n\n\n\nutils.reduced_basis\n\n\n\nutils.reduced_basis.svd",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#visualization",
    "href": "reference/index.html#visualization",
    "title": "Function reference",
    "section": "",
    "text": "VTU/VTP writers, color palettes, and style packages\n\n\n\nutils.visualization\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/problem_classes.html",
    "href": "reference/problem_classes.html",
    "title": "problem_classes",
    "section": "",
    "text": "problem_classes\nproblem_classes",
    "crumbs": [
      "Problem Classes",
      "problem_classes"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html",
    "href": "reference/rom.ecsw.custom_nnls.html",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "rom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "ECSW",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html#classes",
    "href": "reference/rom.ecsw.custom_nnls.html#classes",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "ECSW",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.html",
    "href": "reference/rom.ecsw.html",
    "title": "rom.ecsw",
    "section": "",
    "text": "rom.ecsw\nrom.ecsw\nThe ecsw folder implements Empirical Cubature Subset Weighting (ECSW) methods.\nContents: - nnls_solver.py: Active‐set bounded NNLS solver (NNLSSolver) with L₂/L∞ criteria for computing nonnegative cubature weights under per-entry bounds. - Utilities for convergence testing (NNLS_termination), argument verification, and solver configuration.\nTogether, these tools select and weight integration points to approximate high‐dimensional integrals with a sparse subset, enabling efficient reduced‐order model assembly.",
    "crumbs": [
      "ECSW",
      "rom.ecsw"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html",
    "href": "reference/rom.linear_form_rom.html",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "rom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\nThis module provides: - LinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html#classes",
    "href": "reference/rom.linear_form_rom.html#classes",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html",
    "href": "reference/rom.rom_utils.html",
    "title": "rom.rom_utils",
    "section": "",
    "text": "rom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O, and Newton solvers in reduced‐order modeling (ROM) workflows.\nThis module provides:\n\nSnapshot train/test splitting routines:\n\ntrain_test_split, latin_hypercube_train_test_split, sobol_train_test_split\n\nSample generators:\n\ngenerate_sobol, generate_lhs, generate_gaussian_samples\n\nBasis management:\n\nupdate_basis – deflation and augmentation of reduced bases\n\nSolution reconstruction:\n\nreconstruct_solution – expand reduced vectors back to full order\n\nROM data persistence:\n\nrom_data_gen, load_rom_data\n\nNewton solvers for ROM systems:\n\nnewton_hyper_rom_solver, newton_solver_rom\n\n\nTogether, these functions support data preparation, sampling design, basis enrichment, I/O, and nonlinear solves in full‐to‐reduced‐order pipelines.\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve a nonlinear reduced-order system via Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.01,\n    maxit=50,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n50\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    V_sel=None,\n    mean=None,\n    tol=0.001,\n    maxit=50,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear reduced-order system via Newton’s method.\nIf use_lu=True, uses LU refactorization on the reduced Jacobian. If use_lu=False, reconstructs full state and solves directly each iteration.\nReturns: - (u_rom,) when use_lu=True - (u_full, mean) when use_lu=False\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html#functions",
    "href": "reference/rom.rom_utils.html#functions",
    "title": "rom.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve a nonlinear reduced-order system via Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.01,\n    maxit=50,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n50\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    V_sel=None,\n    mean=None,\n    tol=0.001,\n    maxit=50,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear reduced-order system via Newton’s method.\nIf use_lu=True, uses LU refactorization on the reduced Jacobian. If use_lu=False, reconstructs full state and solves directly each iteration.\nReturns: - (u_rom,) when use_lu=True - (u_full, mean) when use_lu=False\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/utils.basis.pod.html",
    "href": "reference/utils.basis.pod.html",
    "title": "utils.basis.pod",
    "section": "",
    "text": "utils.basis.pod\nutils.basis.pod"
  },
  {
    "objectID": "reference/utils.errors.html",
    "href": "reference/utils.errors.html",
    "title": "utils.errors",
    "section": "",
    "text": "utils.errors\nutils.errors"
  },
  {
    "objectID": "reference/utils.newton_solver.html",
    "href": "reference/utils.newton_solver.html",
    "title": "utils.newton_solver",
    "section": "",
    "text": "utils.newton_solver\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.newton_solver.html#functions",
    "href": "reference/utils.newton_solver.html#functions",
    "title": "utils.newton_solver",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.old.html",
    "href": "reference/utils.old.html",
    "title": "utils.old",
    "section": "",
    "text": "utils.old\n\n\nLegacy utility functions and experimental prototypes retained for reference and backward compatibility.\nThis subpackage contains all “old” or deprecated utility routines that have since been superseded by newer, more robust implementations in the main utils package. It allows you to review earlier approaches and compare behavior against current methods.\nAvailable modules (non-exhaustive):\n\nsvd_mode_selectors_old.py : Original SVD mode selection routines using basic cumulative-energy thresholds.\napproximating_ln.py : Naive series-expansion algorithm for natural logarithm approximation.\nmagnetic_field_utils_old.py: Early SFML-based routines for drawing electric and magnetic field visualizations.\nkotter_change_plan.py : Preliminary Kotter’s Eight-Step Change Management plan generator.\ndehydration_monitor_old.py : Prototype hydration-tracking functions for Alzheimer’s monitoring device.\nwavelet_basics.py : Initial implementations of wavelet transform utilities.\n\n\n\n\n&gt;&gt;&gt; from utils.old import svd_mode_selectors_old\n&gt;&gt;&gt; modes, U = svd_mode_selectors_old.svd_mode_selector(data_matrix, tolerance=1e-2)",
    "crumbs": [
      "Utilities",
      "utils.old"
    ]
  },
  {
    "objectID": "reference/utils.old.html#utils.old",
    "href": "reference/utils.old.html#utils.old",
    "title": "utils.old",
    "section": "",
    "text": "Legacy utility functions and experimental prototypes retained for reference and backward compatibility.\nThis subpackage contains all “old” or deprecated utility routines that have since been superseded by newer, more robust implementations in the main utils package. It allows you to review earlier approaches and compare behavior against current methods.\nAvailable modules (non-exhaustive):\n\nsvd_mode_selectors_old.py : Original SVD mode selection routines using basic cumulative-energy thresholds.\napproximating_ln.py : Naive series-expansion algorithm for natural logarithm approximation.\nmagnetic_field_utils_old.py: Early SFML-based routines for drawing electric and magnetic field visualizations.\nkotter_change_plan.py : Preliminary Kotter’s Eight-Step Change Management plan generator.\ndehydration_monitor_old.py : Prototype hydration-tracking functions for Alzheimer’s monitoring device.\nwavelet_basics.py : Initial implementations of wavelet transform utilities.",
    "crumbs": [
      "Utilities",
      "utils.old"
    ]
  },
  {
    "objectID": "reference/utils.old.html#examples",
    "href": "reference/utils.old.html#examples",
    "title": "utils.old",
    "section": "",
    "text": "&gt;&gt;&gt; from utils.old import svd_mode_selectors_old\n&gt;&gt;&gt; modes, U = svd_mode_selectors_old.svd_mode_selector(data_matrix, tolerance=1e-2)",
    "crumbs": [
      "Utilities",
      "utils.old"
    ]
  },
  {
    "objectID": "reference/utils.html",
    "href": "reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nutils",
    "crumbs": [
      "Utilities",
      "utils"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html",
    "href": "reference/utils.reduced_basis.svd.html",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "utils.reduced_basis.svd\n\n\n\n\n\nName\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5",
    "crumbs": [
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html#functions",
    "href": "reference/utils.reduced_basis.svd.html#functions",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5",
    "crumbs": [
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.rom_utils.html",
    "href": "reference/utils.rom_utils.html",
    "title": "utils.rom_utils",
    "section": "",
    "text": "utils.rom_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.rom_utils.html#functions",
    "href": "reference/utils.rom_utils.html#functions",
    "title": "utils.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html",
    "href": "reference/utils.visualization.generate_vtk.html",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html#functions",
    "href": "reference/utils.visualization.generate_vtk.html#functions",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html",
    "href": "reference/utils.visualization.vtuwriter.html",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "utils.visualization.vtuwriter\n\n\n\n\n\nName\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)",
    "crumbs": [
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html#classes",
    "href": "reference/utils.visualization.vtuwriter.html#classes",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)",
    "crumbs": [
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Welcome to skrom",
    "section": "Getting Started",
    "text": "Getting Started\n\nWhat is Reduced-Order Modeling?\nReduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\n\n\nOffline-Online Paradigm\nscikit-rom implements the classical offline-online decomposition:\n\nOffline Phase (computationally expensive, done once):\n\nGenerate parameter samples\nSolve full-order problems (snapshots)\nCompute POD basis via SVD\nAssemble reduced operators\n\nOnline Phase (fast, many evaluations):\n\nRapid parameter evaluation using pre-computed operators\nTypically 10-500x faster than full-order models\n\n\n\nLinear Heat Conduction example problem\n\n1D steady heat conduction equation with constant parameters:\n\\[\n- \\frac{d}{dx} \\left( k \\frac{dT}{dx} \\right) = q, \\quad x \\in [0, L],\n\\]\nwith the boundary conditions:\n\n\\(\\left. \\frac{dT}{dx} \\right|_{x=0} = 0\\) (Neumann),\n\\(T(L) = T_L\\) (Dirichlet).\n\nHere, \\(k = 16 + \\mu\\) and \\(q = 35000 + \\beta\\).\nTo derive the finite element formulation, we first multiply the strong form by a test function \\(v(x) \\in V\\), where \\(V\\) is the space of admissible test functions that vanish at the Dirichlet boundary. Integrating over the domain, we obtain the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q v(x) \\, dx.\n\\]\nLet us discretize the domain into \\(N\\) linear finite elements. We express the approximate solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are the piecewise linear basis functions and \\(T_j\\) are the nodal temperature values to be determined. Similarly, we choose test functions from the same basis: \\(v(x) = \\phi_i(x)\\).\nSubstituting into the weak form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q \\phi_i(x) \\, dx \\quad \\text{for } i = 1, \\dots, n.\n\\]\nThis leads to the standard finite element system:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwhere\n\n\\(\\mathbf{K}_{ij} = \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx\\) is the stiffness matrix,\n\\(\\mathbf{F}_i = \\int_0^L q \\phi_i(x) \\, dx\\) is the load vector,\n\\(\\mathbf{T} = [T_1, T_2, \\dots, T_n]^T\\) is the vector of unknown nodal temperatures.\n\nSince \\(k\\) and \\(q\\) are constant (parameter dependent), these integrals simplify over each element \\(e \\in [x_e, x_{e+1}]\\). On a uniform mesh, using linear shape functions:\n\nLocal stiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLocal load vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix},\n\\]\n\nwhere \\(h\\) is the element length.\nWe then assemble these local matrices into the global system. The Neumann boundary condition at \\(x = 0\\) contributes nothing (natural condition), and the Dirichlet boundary condition \\(T(L) = T_L\\) is imposed by modifying the last row of the global system accordingly.\nAfter applying the boundary conditions, the resulting linear system can be solved for the nodal values of the temperature field \\(\\mathbf{T}\\). This provides a numerical approximation to the analytical solution:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2).\n\\]\nBelow we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  },
  {
    "objectID": "index.html#recommended-reading",
    "href": "index.html#recommended-reading",
    "title": "Welcome to skrom",
    "section": "Recommended Reading",
    "text": "Recommended Reading\nTo dive deeper, check out:\n\nHyper-reduction Techniques for Efficient Simulation"
  },
  {
    "objectID": "utils.visualization.html",
    "href": "utils.visualization.html",
    "title": "utils.visualization",
    "section": "",
    "text": "utils.visualization\nutils.visualization",
    "crumbs": [
      "Visualization",
      "utils.visualization"
    ]
  },
  {
    "objectID": "utils.imports.html",
    "href": "utils.imports.html",
    "title": "utils.imports",
    "section": "",
    "text": "utils.imports\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework: – Core imports for OS, filesystem, timing, and randomness – Numerical & symbolic computing: NumPy, SciPy (dense & sparse), Sympy – Finite‐element tools: scikit‐fem (from skfem import *), mesh I/O via meshio – Linear algebra solvers: dense (LU), sparse (splu, spilu, CG), and multigrid (pyamg) – Sampling & design‐of‐experiments: Sobol, Latin Hypercube (SciPy QMC & pyDOE) – Plotting & visualization: Matplotlib (2D/3D, custom styles), ptitprince, and optional animation modules\n– Utilities for dynamic imports, path handling, and Cartesian products These imports and utilities ensure consistent, ready‐to‐use functionality across the entire reduced‐order modeling pipeline.",
    "crumbs": [
      "**Documentation**",
      "utils.imports"
    ]
  },
  {
    "objectID": "problem_structure.html",
    "href": "problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Video\nLinear Elasticity\nThis comprehensive tutorial demonstrates the complete process of developing a reduced-order model (ROM) for a three-dimensional linear elastic structure using scikit-rom. You’ll learn how each component operates, understand the interconnections between files, and discover how to build an affine ROM that enables real-time or near-real-time simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#what-is-reduced-order-modeling",
    "href": "problem_structure.html#what-is-reduced-order-modeling",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "What is Reduced-Order Modeling?",
    "text": "What is Reduced-Order Modeling?\nReduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#prerequisites",
    "href": "problem_structure.html#prerequisites",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Prerequisites",
    "text": "Prerequisites\nFirst, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#geometry-finite-element-setup-domain.py",
    "href": "problem_structure.html#geometry-finite-element-setup-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "1. Geometry & Finite-Element Setup — domain.py",
    "text": "1. Geometry & Finite-Element Setup — domain.py\nThe domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#constitutive-law-material-properties-properties.py",
    "href": "problem_structure.html#constitutive-law-material-properties-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "2. Constitutive Law & Material Properties — properties.py",
    "text": "2. Constitutive Law & Material Properties — properties.py\nThis module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "href": "problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "3. Affine Stiffness Tensor — bilinear_forms.py",
    "text": "3. Affine Stiffness Tensor — bilinear_forms.py\nThis is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#right-hand-side-linear_forms.py",
    "href": "problem_structure.html#right-hand-side-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "4. Right-Hand Side — linear_forms.py",
    "text": "4. Right-Hand Side — linear_forms.py\nThis module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#parameter-sampling-params.py",
    "href": "problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "5. Parameter Sampling — params.py",
    "text": "5. Parameter Sampling — params.py\nParameter Ranges:\n\n\\(E\\): [0.5, 2.0]\n\\(\\nu\\): [0.2, 0.4]\n\nSampling Strategy: Uses Sobol sequences to create quasi-random sets of \\((E,\\nu)\\) pairs for:\n\nTraining snapshots (for ROM basis construction)\nTesting snapshots (for validation)\n\nMasks Provided: Returns boolean arrays to cleanly separate training vs testing data.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#orchestrating-everything-problem_def.py",
    "href": "problem_structure.html#orchestrating-everything-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "6. Orchestrating Everything — problem_def.py",
    "text": "6. Orchestrating Everything — problem_def.py\nThis is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\nAnatomy of ProblemAffine\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#offline-workflow-building-the-rom",
    "href": "problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "7. Offline Workflow: Building the ROM",
    "text": "7. Offline Workflow: Building the ROM\nStep-by-step process:\n\nParameter Sampling: Generate \\(n\\) training samples \\((E_i, \\nu_i)\\) using the routine from params.py.\nFull-Order Simulations: For each parameter, solve the full high-fidelity FEM system and store the solution as a snapshot.\nData Processing:\n\nMean Subtraction: Subtract the mean from all snapshots to center the dataset\nSVD/POD: Perform singular value decomposition on the mean-subtracted snapshots to find the dominant modes (energy-ranked spatial patterns)\nMode Truncation: Retain only the leading \\(r\\) modes (user- or error-determined) for reduced basis\n\nReduced Operator Assembly: Project per-region blocks \\((K_{\\lambda,\\text{region}}, K_{\\mu,\\text{region}})\\) into the reduced space, yielding ultra-compact operators.\n\nThe reduced model is now ready for very rapid online predictions.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#online-solve-real-time-evaluation",
    "href": "problem_structure.html#online-solve-real-time-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "8. Online Solve — Real-Time Evaluation",
    "text": "8. Online Solve — Real-Time Evaluation\nOnce the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#validation-ensuring-rom-quality",
    "href": "problem_structure.html#validation-ensuring-rom-quality",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "9. Validation — Ensuring ROM Quality",
    "text": "9. Validation — Ensuring ROM Quality\nIt’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#advanced-topics",
    "href": "problem_structure.html#advanced-topics",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "10. Advanced Topics",
    "text": "10. Advanced Topics\n\n10.1 Choosing the Reduced Dimension\nThe choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n10.2 Affine vs. Non-Affine Problems\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "reference/fom.html",
    "href": "reference/fom.html",
    "title": "fom",
    "section": "",
    "text": "fom\n\n\nFinite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom"
    ]
  },
  {
    "objectID": "reference/fom.html#fem_utils.py",
    "href": "reference/fom.html#fem_utils.py",
    "title": "fom",
    "section": "",
    "text": "Finite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-description",
    "href": "problem_structure.html#problem-description",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Problem Description",
    "text": "Problem Description\nWe analyze a 3D block governed by linear elasticity principles. The structure features two distinct material regions with different stiffness properties, enabling demonstration of spatially varying material handling through affine decomposition. Core characteristics include:\nLinear Affine Elasticity: The stiffness matrix is constructed as a linear combination of blocks that are affine in the Lamé parameters \\((\\lambda, \\mu)\\).\nDomain Partitioning: The block is divided into two regions with distinct elastic properties.\nParameter Space: Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) are sampled for both offline and online ROM phases.\nBoundary Conditions: Dirichlet constraints (fixed displacement) on one face; Neumann conditions (applied traction) on the opposing face.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#project-architecture",
    "href": "problem_structure.html#project-architecture",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Project Architecture",
    "text": "Project Architecture\nThe simulation workflow is organized through the following directory structure and files:\nproblem_1/\n├─ domain.py           # Mesh generation, basis setup, boundary and region partitioning\n├─ bilinear_forms.py   # Affine weak form (stiffness) assembly\n├─ linear_forms.py     # Load (traction) right-hand side term\n├─ properties.py       # Lamé parameter computation per region\n├─ params.py           # Sampling (E, ν) for training and testing\n└─ problem_def.py      # Main orchestration: assembles all components for scikit-rom",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "href": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "1. Geometry & Finite Element Framework — domain.py",
    "text": "1. Geometry & Finite Element Framework — domain.py\nMesh Construction: The domain represents a 3D block discretized with hexahedral elements, parameterized by dimensions \\((l_x, l_y, l_z)\\) and mesh refinement factor for resolution control.\nBasis Functions: Employs vector-valued trilinear hexahedral elements to represent 3D displacement fields.\nBoundary Identification:\n\n'left': Dirichlet (fixed displacement)\n'right': Neumann (applied load)\n\nRegion Partitioning: The mesh is divided along the \\(x\\)-axis at the midpoint into:\n\nregion_1: \\(x \\leq 0.5 \\cdot l_x\\) (stiffer region)\nregion_2: \\(x &gt; 0.5 \\cdot l_x\\) (softer region)\n\nThe module returns a comprehensive dictionary containing the mesh, bases, boundary DOFs, and a per-region basis dictionary for subsequent operator assembly.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "href": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "2. Material Properties & Affine Coefficient Functions — properties.py",
    "text": "2. Material Properties & Affine Coefficient Functions — properties.py\nLamé Parameters: Transforms Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) into Lamé parameters \\((\\lambda, \\mu)\\) using skfem utilities.\nRegion Handling:\n\nFor region_1, both \\(\\lambda\\) and \\(\\mu\\) are scaled by 50× (stiffer inclusion)\nFor region_2, properties remain unchanged (baseline material)\n\nThis design facilitates straightforward definition of piecewise-constant or heterogeneous material properties, essential for multi-region simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "href": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py",
    "text": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py\nAffine Bilinear Forms:\n\nstiffness_lam: Weak form for the \\(\\lambda\\) (volumetric) component\nstiffness_mu: Weak form for the \\(\\mu\\) (shear) component\n\nMathematics: Each block is computed per-region (using basis restriction). The global stiffness matrix is expressed as:\n\\(K(E,\\nu) = \\sum_{\\text{regions}} \\lambda \\cdot K_{\\lambda,\\text{region}} + \\mu \\cdot K_{\\mu,\\text{region}}\\)\nParameter-Dependent Evaluation: Lamé parameters are computed as needed for each region via the region-aware property function.\nThis approach ensures the assembly aligns with the affine decomposition essential for efficient ROM evaluation.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "href": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "4. Right-Hand Side (Loads) — linear_forms.py",
    "text": "4. Right-Hand Side (Loads) — linear_forms.py\nNeumann Traction: Implements a constant traction (-1e-2) in the global \\(y\\)-direction applied to the ‘right’ face.\nAffine in Parameters: The load vector is parameter-independent and only needs to be assembled once for the entire ROM process.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-orchestration-problem_def.py",
    "href": "problem_structure.html#problem-orchestration-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "6. Problem Orchestration — problem_def.py",
    "text": "6. Problem Orchestration — problem_def.py\nMaster Problem Class: Inherits from the scikit-rom base and registers essential routines:\n\ndomain(): Loads mesh and DOFs from domain.py\nbilinear_forms(): Returns affine weak forms for \\(\\lambda\\) and \\(\\mu\\)\nlinear_forms(): Returns the Neumann loading routine\nproperties(): Returns the regionwise Lamé parameter mapper\nparameters(n_samples): Returns parameter sets and train/test split\n\nAffine Operator Assembly: On the first solve, stiffness and load “blocks” are assembled separately for each region/material.\nFull-Order Solve: Assembles and solves the condensed system with Dirichlet BCs for each parameter instance.\nROM Projection: Projects global blocks onto the reduced basis, incorporating an offline mean-shift to keep the ROM centered.\nThis design ensures a clear separation between model definition (problem file) and algorithmic ROM machinery (provided by scikit-rom).",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#online-workflow-fast-evaluation",
    "href": "problem_structure.html#online-workflow-fast-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "8. Online Workflow: Fast Evaluation",
    "text": "8. Online Workflow: Fast Evaluation\nFor a new parameter set \\((E, \\nu)\\):\n\nCompute Per-Region Lamé Parameters: Map input parameters to \\((\\lambda, \\mu)\\) values for each region.\nAssemble Reduced Stiffness: Combine precomputed regionwise blocks using affine expressions.\nSolve Reduced System: The resulting linear system has size equal to the number of modes \\((r \\ll N)\\), making it extremely fast.\nMean Recovery: Add back the mean field to produce the full-field displacement solution, ready for visualization or further analysis.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#validation-error-assessment",
    "href": "problem_structure.html#validation-error-assessment",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "9. Validation & Error Assessment",
    "text": "9. Validation & Error Assessment\nTest Set: Evaluate the ROM on held-out (never-seen) parameter pairs.\nError Metrics:\n\nRelative error (L2 or energy norm) between ROM and high-fidelity FOM solutions\nStatistical fit metrics (e.g., R² score)\n\nSpeed-up Factor: The ROM typically achieves significant speed-up (often orders of magnitude) versus direct FEM.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#summary-table-of-key-methods",
    "href": "problem_structure.html#summary-table-of-key-methods",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "10. Summary Table of Key Methods",
    "text": "10. Summary Table of Key Methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nTypical Location in Pipeline\n\n\n\n\ndomain()\nSetup mesh, BCs, DOFs, and per-region bases\nFirst, before assembly\n\n\nbilinear_forms()\nReturn affine form handles for λ, μ\nOperator initialization\n\n\nlinear_forms()\nSpecify right-hand-side (load)\nOperator assembly\n\n\nproperties()\nMap (E, ν, region) → (λ, μ)\nParameter unpacking\n\n\nparameters()\nProduce sampled (E, ν) + train/test masks\nOffline/online split\n\n\nfom_solver()\nRun and store full-order solutions\nSnapshot generation (offline)\n\n\nrom_solver()\nAssemble and solve projected ROM system\nRapid online prediction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#code-snippets-for-each-stage",
    "href": "problem_structure.html#code-snippets-for-each-stage",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "11. Code Snippets for Each Stage",
    "text": "11. Code Snippets for Each Stage\nParameter Sampling Example:\nparams, param_ranges, train_mask, test_mask = parameters(32)\nDomain Setup Example:\ndom = domain_()\nmesh = dom['mesh']\nbasis = dom['basis']\nregions = dom['basis_regions']\nAffine Block Assembly:\nstiffness_lam, stiffness_mu = bilinear_forms()\nK_lambda = asm(stiffness_lam, region_basis, ...)\nK_mu = asm(stiffness_mu, region_basis, ...)\nFull-Order Solve:\nu = solve(*condense(K, rhs, x=fixed_values, D=dirichlet_dofs))\nROM Solve Online:\nms_full_sol, mean_shift = rom_solver(param)\nfull_field = ms_full_sol + mean_shift",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#best-practices",
    "href": "problem_structure.html#best-practices",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "12. Best Practices",
    "text": "12. Best Practices\n\nAlways center your snapshot data before SVD to ensure best POD convergence\nUse enough training samples (and parameter space coverage) to avoid overfitting or “holes” in ROM accuracy\nCheck ROM error on multiple, unseen test samples\nVisualize spatial error fields—not just scalar error metrics—for insight into local ROM limitations\nLeverage the modular file structure for extending to other domains, BCs, and PDEs\n\nThis workflow and modular codebase provide a flexible, scalable foundation for reduced-order modeling of parametrized PDEs in computational mechanics, accelerating simulation, optimization, and interactive design.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "sidebar: - contents: - reference/index.qmd - contents: - reference/problem_classes.qmd - reference/problem_classes.master_class_static.qmd section: Problem Classes - contents: - reference/fom.qmd - reference/fom.fem_utils.qmd section: Full-Order Model (FOM) - contents: - reference/rom.qmd - reference/rom.bilinear_form_rom.qmd - reference/rom.linear_form_rom.qmd - reference/rom.rom_error_est.qmd - reference/rom.rom_utils.qmd - reference/rom.linear_form_hyperrom.qmd section: Reduced-Order Model (ROM) - contents: - reference/rom.ecsw.qmd - reference/rom.ecsw.custom_nnls.qmd - reference/rom.ecsw.hyperreduce.qmd section: ECSW - contents: - reference/utils.qmd - reference/utils.imports.qmd - reference/utils.old.qmd - reference/utils.old.rom_utils_old.qmd - reference/utils.reduced_basis.qmd - reference/utils.reduced_basis.svd.qmd section: Utilities - contents: - reference/utils.visualization.qmd - reference/utils.visualization.generate_vtk.qmd - reference/utils.visualization.generate_vtu.qmd - reference/utils.visualization.vtuwriter.qmd - reference/utils.visualization.color_palette.qmd section: Visualization id: reference - id: dummy-sidebar",
    "crumbs": [
      "**Documentation**"
    ]
  },
  {
    "objectID": "index.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "href": "index.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "title": "Welcome to skrom",
    "section": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling",
    "text": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling\nWe consider the boundary value problem\n\\[\n- \\frac{d}{dx}\\left(k\\,\\frac{dT}{dx}\\right) = q, \\quad x \\in [0, L],\n\\]\nsubject to the boundary conditions:\n\nNeumann: \\(\\left. \\dfrac{dT}{dx} \\right|_{x=0} = 0\\),\nDirichlet: \\(T(L) = T_L\\),\n\nwhere the material parameters are defined as:\n\\[\nk = 16 + \\mu, \\qquad q = 35000 + \\beta,\n\\]\nwith \\(\\mu\\) and \\(\\beta\\) denoting input parameters.\n\n\nWeak Formulation\nMultiplying the governing equation by a test function \\(v \\in V\\) that vanishes at \\(x = L\\), and integrating over the domain yields the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q\\,v(x)\\, dx.\n\\]\n\n\n\nFinite Element Discretization\nDiscretize the interval \\([0, L]\\) into \\(N\\) uniform linear elements of length \\(h = L / N\\). Approximate the solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are piecewise linear basis functions, and \\(T_j\\) are the nodal temperatures. Choosing \\(v = \\phi_i(x)\\) leads to the discrete form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q\\, \\phi_i(x) \\, dx.\n\\]\nThe global system can be written as:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwith\n\n\\(K_{ij} = \\int_0^L k, \\dfrac{d\\phi_j}{dx} \\dfrac{d\\phi_i}{dx} , dx\\) (stiffness matrix),\n\\(F_i = \\int_0^L q, \\phi_i(x) , dx\\) (load vector),\n\\(\\mathbf{T} = [T_1, \\dots, T_n]^\\top\\) (nodal temperatures).\n\nOn each element, the local contributions are:\n\nStiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLoad vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}.\n\\]\n\nThe Neumann condition at \\(x = 0\\) is naturally satisfied. The Dirichlet condition \\(T(L) = T_L\\) is imposed directly on the final equation.\n\n\n\nAnalytical Reference Solution\nFor constant \\(k\\) and \\(q\\), the exact solution is:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2),\n\\]\nwhich provides a useful reference for numerical verification."
  },
  {
    "objectID": "index.html#motivation-for-reduced-order-modeling",
    "href": "index.html#motivation-for-reduced-order-modeling",
    "title": "Welcome to skrom",
    "section": "Motivation for Reduced-Order Modeling",
    "text": "Motivation for Reduced-Order Modeling\nWhen evaluating \\(\\mathbf{T}\\) for multiple parameter pairs \\((\\mu, \\beta)\\), solving the full system \\(\\mathbf{K} \\mathbf{T} = \\mathbf{F}\\) repeatedly becomes computationally expensive. This challenge arises in applications such as parameter studies, optimization loops, or real-time simulation.\nReduced-order modeling (ROM) mitigates this cost by projecting the full system onto a lower-dimensional subspace, enabling rapid evaluation with minimal accuracy loss. The approach involves:\n\nAn offline phase where representative solutions (“snapshots”) are collected and used to construct a low-dimensional basis,\nAn online phase where the system is solved in the reduced space, avoiding expensive computations at full resolution.\n\nIn problems with affine parameter dependence, the ROM can be formulated such that no linear solves are required in the online stage, making it suitable for many-query scenarios."
  },
  {
    "objectID": "index.html#affine-reduced-order-modeling-rom",
    "href": "index.html#affine-reduced-order-modeling-rom",
    "title": "Welcome to skrom",
    "section": "Affine Reduced-Order Modeling (ROM)",
    "text": "Affine Reduced-Order Modeling (ROM)\nWe approximate the full-order solution using a reduced affine expansion:\n\\[\n\\mathbf{T} \\approx \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a},\n\\]\nwhere:\n\n\\(\\mathbf{T}_{\\text{mean}} \\in \\mathbb{R}^N\\) is the mean of collected snapshots,\n\\(\\mathbf{U} \\in \\mathbb{R}^{N \\times r}\\) is the reduced basis (e.g., from POD),\n\\(\\mathbf{a} \\in \\mathbb{R}^r\\) are reduced coordinates.\n\nSubstituting into the system and applying Galerkin projection:\n\\[\n\\mathbf{K} (\\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}) = \\mathbf{f}\n\\;\\Rightarrow\\;\n\\mathbf{U}^\\top \\mathbf{K} \\mathbf{U} \\mathbf{a} = \\mathbf{U}^\\top(\\mathbf{f} - \\mathbf{K} \\mathbf{T}_{\\text{mean}}).\n\\]\nDefine:\n\nReduced stiffness: \\(\\mathbf{K}_r = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{U}\\),\nReduced source: \\(\\mathbf{b} = \\mathbf{U}^\\top \\mathbf{f}\\),\nProjected offset: \\(\\mathbf{g} = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{T}_{\\text{mean}}\\).\n\nThen:\n\\[\n\\mathbf{a} = \\mathbf{K}_r^{-1}(\\mathbf{b} - \\mathbf{g}),\n\\qquad\n\\hat{\\mathbf{T}} = \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}.\n\\]"
  },
  {
    "objectID": "index.html#efficient-online-evaluation-for-affine-parametric-systems",
    "href": "index.html#efficient-online-evaluation-for-affine-parametric-systems",
    "title": "Welcome to skrom",
    "section": "Efficient Online Evaluation for Affine Parametric Systems",
    "text": "Efficient Online Evaluation for Affine Parametric Systems\nAssume the system admits the following affine form:\n\\[\n\\mathbf{K}(\\mu) = \\mu\\, \\mathbf{K}_1,\n\\quad\n\\mathbf{f}(\\beta) = \\beta\\, \\mathbf{f}_1.\n\\]\nThen, in the offline phase, precompute:\nIn the online phase, for any \\((\\mu, \\beta)\\):\n\\[\n\\boxed{\n\\hat{\\mathbf{T}}(\\mu, \\beta)\n= \\mathbf{T}_{\\text{mean}}\n+ \\mathbf{U} \\left( \\frac{\\beta}{\\mu} \\mathbf{a}_1 - \\mathbf{c}_1 \\right)\n}\n\\]\nThis avoids matrix assembly and linear solves during inference, resulting in fast and scalable evaluation. Below we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling",
    "text": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling\nWe consider the boundary value problem\n\\[\n- \\frac{d}{dx}\\left(k\\,\\frac{dT}{dx}\\right) = q, \\quad x \\in [0, L],\n\\]\nsubject to the boundary conditions:\n\nNeumann: \\(\\left. \\dfrac{dT}{dx} \\right|_{x=0} = 0\\),\nDirichlet: \\(T(L) = T_L\\),\n\nwhere the material parameters are defined as:\n\\[\nk = 16 + \\mu, \\qquad q = 35000 + \\beta,\n\\]\nwith \\(\\mu\\) and \\(\\beta\\) denoting input parameters.\n\n\nWeak Formulation\nMultiplying the governing equation by a test function \\(v \\in V\\) that vanishes at \\(x = L\\), and integrating over the domain yields the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q\\,v(x)\\, dx.\n\\]\n\n\n\nFinite Element Discretization\nDiscretize the interval \\([0, L]\\) into \\(N\\) uniform linear elements of length \\(h = L / N\\). Approximate the solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are piecewise linear basis functions, and \\(T_j\\) are the nodal temperatures. Choosing \\(v = \\phi_i(x)\\) leads to the discrete form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q\\, \\phi_i(x) \\, dx.\n\\]\nThe global system can be written as:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwith\n\n\\(K_{ij} = \\int_0^L k, \\dfrac{d\\phi_j}{dx} \\dfrac{d\\phi_i}{dx} , dx\\) (stiffness matrix),\n\\(F_i = \\int_0^L q, \\phi_i(x) , dx\\) (load vector),\n\\(\\mathbf{T} = [T_1, \\dots, T_n]^\\top\\) (nodal temperatures).\n\nOn each element, the local contributions are:\n\nStiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLoad vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}.\n\\]\n\nThe Neumann condition at \\(x = 0\\) is naturally satisfied. The Dirichlet condition \\(T(L) = T_L\\) is imposed directly on the final equation.\n\n\n\nAnalytical Reference Solution\nFor constant \\(k\\) and \\(q\\), the exact solution is:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2),\n\\]\nwhich provides a useful reference for numerical verification."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "Motivation for Reduced-Order Modeling",
    "text": "Motivation for Reduced-Order Modeling\nWhen evaluating \\(\\mathbf{T}\\) for multiple parameter pairs \\((\\mu, \\beta)\\), solving the full system \\(\\mathbf{K} \\mathbf{T} = \\mathbf{F}\\) repeatedly becomes computationally expensive. This challenge arises in applications such as parameter studies, optimization loops, or real-time simulation.\nReduced-order modeling (ROM) mitigates this cost by projecting the full system onto a lower-dimensional subspace, enabling rapid evaluation with minimal accuracy loss. The approach involves:\n\nAn offline phase where representative solutions (“snapshots”) are collected and used to construct a low-dimensional basis,\nAn online phase where the system is solved in the reduced space, avoiding expensive computations at full resolution.\n\nIn problems with affine parameter dependence, the ROM can be formulated such that no linear solves are required in the online stage, making it suitable for many-query scenarios."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "href": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "title": "SCIKIT-ROM",
    "section": "Affine Reduced-Order Modeling (ROM)",
    "text": "Affine Reduced-Order Modeling (ROM)\nWe approximate the full-order solution using a reduced affine expansion:\n\\[\n\\mathbf{T} \\approx \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a},\n\\]\nwhere:\n\n\\(\\mathbf{T}_{\\text{mean}} \\in \\mathbb{R}^N\\) is the mean of collected snapshots,\n\\(\\mathbf{U} \\in \\mathbb{R}^{N \\times r}\\) is the reduced basis (e.g., from POD),\n\\(\\mathbf{a} \\in \\mathbb{R}^r\\) are reduced coordinates.\n\nSubstituting into the system and applying Galerkin projection:\n\\[\n\\mathbf{K} (\\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}) = \\mathbf{f}\n\\;\\Rightarrow\\;\n\\mathbf{U}^\\top \\mathbf{K} \\mathbf{U} \\mathbf{a} = \\mathbf{U}^\\top(\\mathbf{f} - \\mathbf{K} \\mathbf{T}_{\\text{mean}}).\n\\]\nDefine:\n\nReduced stiffness: \\(\\mathbf{K}_r = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{U}\\),\nReduced source: \\(\\mathbf{b} = \\mathbf{U}^\\top \\mathbf{f}\\),\nProjected offset: \\(\\mathbf{g} = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{T}_{\\text{mean}}\\).\n\nThen:\n\\[\n\\mathbf{a} = \\mathbf{K}_r^{-1}(\\mathbf{b} - \\mathbf{g}),\n\\qquad\n\\hat{\\mathbf{T}} = \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}.\n\\]"
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "href": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "title": "SCIKIT-ROM",
    "section": "Efficient Online Evaluation for Affine Parametric Systems",
    "text": "Efficient Online Evaluation for Affine Parametric Systems\nAssume the system admits the following affine form:\n\\[\n\\mathbf{K}(\\mu) = \\mu\\, \\mathbf{K}_1,\n\\quad\n\\mathbf{f}(\\beta) = \\beta\\, \\mathbf{f}_1.\n\\]\nThen, in the offline phase, precompute:\nIn the online phase, for any \\((\\mu, \\beta)\\):\n\\[\n\\boxed{\n\\hat{\\mathbf{T}}(\\mu, \\beta)\n= \\mathbf{T}_{\\text{mean}}\n+ \\mathbf{U} \\left( \\frac{\\beta}{\\mu} \\mathbf{a}_1 - \\mathbf{c}_1 \\right)\n}\n\\]\nThis avoids matrix assembly and linear solves during inference, resulting in fast and scalable evaluation. Below we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  }
]