[
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.bilinear_form_hyperrom_ecsw\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including:\n\nClasses for reduced‐order bilinear and linear forms with element clustering\nRoutines to extract local element matrices/vectors in the ROM basis\nUtilities for efficient handling of Dirichlet conditions in reduced spaces\nSupport for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#hyperreducebilinear_form_hyperrom.py",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including:\n\nClasses for reduced‐order bilinear and linear forms with element clustering\nRoutines to extract local element matrices/vectors in the ROM basis\nUtilities for efficient handling of Dirichlet conditions in reduced spaces\nSupport for element‐wise parallelization and weighted assembly",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.linear_form_hyperrom_deim\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nHyperreduction of a linear form via DEIM and mesh sampling.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nHyperreduction of a linear form via DEIM and mesh sampling.\nImplements a Discrete Empirical Interpolation Method (DEIM)–based hyperreduction for finite‐element linear forms. Builds a reduced‐order load vector by assembling only a weighted subset of elements and reconstructing the full operator via DEIM interpolation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyper-reduced load vector via DEIM.\n\n\ndeim_elem_assembly\nAssemble the sampled full-order load vector.\n\n\nextract_element_vector_rom\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyper-reduced load vector via DEIM.\nThis method first builds the sampled full-order load vector on the selected elements, then applies the DEIM interpolation matrix to project it onto the reduced basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to deim_elem_assembly / element extraction.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nReduced-order load vector of shape (r,).\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble the sampled full-order load vector.\nExtracts element-level load contributions only on the sampled elements, then scatters them into the global load vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to extract_element_vector_rom.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nFull-order load vector of length n_dofs.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nBasis for test functions.\nrequired\n\n\nelem_indices\narray_like of int\nIndices of elements to include in extraction.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments for evaluating the bilinear form over each element.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nArray of shape (n_elems, n_loc) containing the element vectors.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nHyperreduction of a linear form via DEIM and mesh sampling.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nHyperreduction of a linear form via DEIM and mesh sampling.\nImplements a Discrete Empirical Interpolation Method (DEIM)–based hyperreduction for finite‐element linear forms. Builds a reduced‐order load vector by assembling only a weighted subset of elements and reconstructing the full operator via DEIM interpolation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyper-reduced load vector via DEIM.\n\n\ndeim_elem_assembly\nAssemble the sampled full-order load vector.\n\n\nextract_element_vector_rom\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyper-reduced load vector via DEIM.\nThis method first builds the sampled full-order load vector on the selected elements, then applies the DEIM interpolation matrix to project it onto the reduced basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to deim_elem_assembly / element extraction.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nReduced-order load vector of shape (r,).\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble the sampled full-order load vector.\nExtracts element-level load contributions only on the sampled elements, then scatters them into the global load vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to extract_element_vector_rom.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nFull-order load vector of length n_dofs.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nBasis for test functions.\nrequired\n\n\nelem_indices\narray_like of int\nIndices of elements to include in extraction.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments for evaluating the bilinear form over each element.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nArray of shape (n_elems, n_loc) containing the element vectors.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/utils.imports.html",
    "href": "reference/utils.imports.html",
    "title": "utils.imports",
    "section": "",
    "text": "utils.imports\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n– Core imports for OS, filesystem, timing, and randomness – Numerical & symbolic computing: NumPy, SciPy (dense & sparse), Sympy – Finite‐element tools: scikit‐fem (from skfem import *), mesh I/O via meshio – Linear algebra solvers: dense (LU), sparse (splu, spilu, CG), and multigrid (pyamg) – Sampling & design‐of‐experiments: Sobol, Latin Hypercube (SciPy QMC & pyDOE) – Plotting & visualization: Matplotlib (2D/3D, custom styles), ptitprince, and optional animation modules\n– Utilities for dynamic imports, path handling, and Cartesian products These imports and utilities ensure consistent, ready‐to‐use functionality across the entire reduced‐order modeling pipeline.",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.imports"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html",
    "href": "reference/rom.linear_form_rom.html",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "rom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\nThis module provides:\n\nLinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\n\nThe rom folder contains core tools for reduced-order modeling (ROM), including:\n\nClasses for projecting and assembling reduced-order bilinear and linear forms\nUtilities for handling Dirichlet boundary conditions in reduced spaces\nChunked and clustered assembly routines to manage large-scale stiffness/load data\nMapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html#classes",
    "href": "reference/rom.linear_form_rom.html#classes",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html",
    "href": "reference/utils.visualization.generate_vtk.html",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html#functions",
    "href": "reference/utils.visualization.generate_vtk.html#functions",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html",
    "href": "reference/rom.bilinear_form_rom.html",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\nThis module provides:\n\nBilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\n\nThe rom folder contains core tools for reduced-order modeling (ROM), including:\n\nClasses for projecting and assembling reduced-order bilinear and linear forms\nUtilities for handling Dirichlet boundary conditions in reduced spaces\nChunked and clustered assembly routines to manage large-scale stiffness/load data\nMapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html#classes",
    "href": "reference/rom.bilinear_form_rom.html#classes",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html",
    "href": "reference/fom.fem_utils.html",
    "title": "fom.fem_utils",
    "section": "",
    "text": "fom.fem_utils\nThis module includes:\n\nbuild_pc_amgsa: construct AMG smoothed aggregation preconditioner.\nelement2location: generate element-to-coordinate mappings from mesh data.\nnewton_solver and its helpers: perform Newton–Raphson solves with or without Dirichlet BC.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nGiven a dict mapping region names to boolean element‐masks,\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_mesh_and_basis\nCall domain() and assign just mesh and basis onto self.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\nunwrap_attr\nIf self. is a 0-d object ndarray, replace it with its .item().\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nGiven a dict mapping region names to boolean element‐masks, returns a dict of reduced bases for each region.\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nCall domain() and assign just mesh and basis onto self.\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.\n\n\n\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nIf self. is a 0-d object ndarray, replace it with its .item().",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html#functions",
    "href": "reference/fom.fem_utils.html#functions",
    "title": "fom.fem_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nGiven a dict mapping region names to boolean element‐masks,\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_mesh_and_basis\nCall domain() and assign just mesh and basis onto self.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\nunwrap_attr\nIf self. is a 0-d object ndarray, replace it with its .item().\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nGiven a dict mapping region names to boolean element‐masks, returns a dict of reduced bases for each region.\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nCall domain() and assign just mesh and basis onto self.\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.\n\n\n\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nIf self. is a 0-d object ndarray, replace it with its .item().",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html",
    "href": "reference/utils.dynamics.integrators.html",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "utils.dynamics.integrators\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html#functions",
    "href": "reference/utils.dynamics.integrators.html#functions",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "problem_structure.html",
    "href": "problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Video\nLinear Elasticity\nThis comprehensive tutorial demonstrates the complete process of developing a reduced-order model (ROM) for a three-dimensional linear elastic structure using scikit-rom. You’ll learn how each component operates, understand the interconnections between files, and discover how to build an affine ROM that enables real-time or near-real-time simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-description",
    "href": "problem_structure.html#problem-description",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Problem Description",
    "text": "Problem Description\nWe analyze a 3D block governed by linear elasticity principles. The structure features two distinct material regions with different stiffness properties, enabling demonstration of spatially varying material handling through affine decomposition. Core characteristics include:\nLinear Affine Elasticity: The stiffness matrix is constructed as a linear combination of blocks that are affine in the Lamé parameters \\((\\lambda, \\mu)\\).\nDomain Partitioning: The block is divided into two regions with distinct elastic properties.\nParameter Space: Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) are sampled for both offline and online ROM phases.\nBoundary Conditions: Dirichlet constraints (fixed displacement) on one face; Neumann conditions (applied traction) on the opposing face.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#project-architecture",
    "href": "problem_structure.html#project-architecture",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Project Architecture",
    "text": "Project Architecture\nThe simulation workflow is organized through the following directory structure and files:\nproblem_1/\n├─ domain.py           # Mesh generation, basis setup, boundary and region partitioning\n├─ bilinear_forms.py   # Affine weak form (stiffness) assembly\n├─ linear_forms.py     # Load (traction) right-hand side term\n├─ properties.py       # Lamé parameter computation per region\n├─ params.py           # Sampling (E, ν) for training and testing\n└─ problem_def.py      # Main orchestration: assembles all components for scikit-rom",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "href": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "1. Geometry & Finite Element Framework — domain.py",
    "text": "1. Geometry & Finite Element Framework — domain.py\nMesh Construction: The domain represents a 3D block discretized with hexahedral elements, parameterized by dimensions \\((l_x, l_y, l_z)\\) and mesh refinement factor for resolution control.\nBasis Functions: Employs vector-valued trilinear hexahedral elements to represent 3D displacement fields.\nBoundary Identification:\n\n'left': Dirichlet (fixed displacement)\n'right': Neumann (applied load)\n\nRegion Partitioning: The mesh is divided along the \\(x\\)-axis at the midpoint into:\n\nregion_1: \\(x \\leq 0.5 \\cdot l_x\\) (stiffer region)\nregion_2: \\(x &gt; 0.5 \\cdot l_x\\) (softer region)\n\nThe module returns a comprehensive dictionary containing the mesh, bases, boundary DOFs, and a per-region basis dictionary for subsequent operator assembly.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "href": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "2. Material Properties & Affine Coefficient Functions — properties.py",
    "text": "2. Material Properties & Affine Coefficient Functions — properties.py\nLamé Parameters: Transforms Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) into Lamé parameters \\((\\lambda, \\mu)\\) using skfem utilities.\nRegion Handling:\n\nFor region_1, both \\(\\lambda\\) and \\(\\mu\\) are scaled by 50× (stiffer inclusion)\nFor region_2, properties remain unchanged (baseline material)\n\nThis design facilitates straightforward definition of piecewise-constant or heterogeneous material properties, essential for multi-region simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "href": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py",
    "text": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py\nAffine Bilinear Forms:\n\nstiffness_lam: Weak form for the \\(\\lambda\\) (volumetric) component\nstiffness_mu: Weak form for the \\(\\mu\\) (shear) component\n\nMathematics: Each block is computed per-region (using basis restriction). The global stiffness matrix is expressed as:\n\\(K(E,\\nu) = \\sum_{\\text{regions}} \\lambda \\cdot K_{\\lambda,\\text{region}} + \\mu \\cdot K_{\\mu,\\text{region}}\\)\nParameter-Dependent Evaluation: Lamé parameters are computed as needed for each region via the region-aware property function.\nThis approach ensures the assembly aligns with the affine decomposition essential for efficient ROM evaluation.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "href": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "4. Right-Hand Side (Loads) — linear_forms.py",
    "text": "4. Right-Hand Side (Loads) — linear_forms.py\nNeumann Traction: Implements a constant traction (-1e-2) in the global \\(y\\)-direction applied to the ‘right’ face.\nAffine in Parameters: The load vector is parameter-independent and only needs to be assembled once for the entire ROM process.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#parameter-sampling-params.py",
    "href": "problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "5. Parameter Sampling — params.py",
    "text": "5. Parameter Sampling — params.py\nParameter Ranges:\n\n\\(E\\): [0.5, 2.0]\n\\(\\nu\\): [0.2, 0.4]\n\nSampling Strategy: Uses Sobol sequences to create quasi-random sets of \\((E,\\nu)\\) pairs for:\n\nTraining snapshots (for ROM basis construction)\nTesting snapshots (for validation)\n\nMasks Provided: Returns boolean arrays to cleanly separate training vs testing data.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-orchestration-problem_def.py",
    "href": "problem_structure.html#problem-orchestration-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "6. Problem Orchestration — problem_def.py",
    "text": "6. Problem Orchestration — problem_def.py\nMaster Problem Class: Inherits from the scikit-rom base and registers essential routines:\n\ndomain(): Loads mesh and DOFs from domain.py\nbilinear_forms(): Returns affine weak forms for \\(\\lambda\\) and \\(\\mu\\)\nlinear_forms(): Returns the Neumann loading routine\nproperties(): Returns the regionwise Lamé parameter mapper\nparameters(n_samples): Returns parameter sets and train/test split\n\nAffine Operator Assembly: On the first solve, stiffness and load “blocks” are assembled separately for each region/material.\nFull-Order Solve: Assembles and solves the condensed system with Dirichlet BCs for each parameter instance.\nROM Projection: Projects global blocks onto the reduced basis, incorporating an offline mean-shift to keep the ROM centered.\nThis design ensures a clear separation between model definition (problem file) and algorithmic ROM machinery (provided by scikit-rom).",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#offline-workflow-building-the-rom",
    "href": "problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "7. Offline Workflow: Building the ROM",
    "text": "7. Offline Workflow: Building the ROM\nStep-by-step process:\n\nParameter Sampling: Generate \\(n\\) training samples \\((E_i, \\nu_i)\\) using the routine from params.py.\nFull-Order Simulations: For each parameter, solve the full high-fidelity FEM system and store the solution as a snapshot.\nData Processing:\n\nMean Subtraction: Subtract the mean from all snapshots to center the dataset\nSVD/POD: Perform singular value decomposition on the mean-subtracted snapshots to find the dominant modes (energy-ranked spatial patterns)\nMode Truncation: Retain only the leading \\(r\\) modes (user- or error-determined) for reduced basis\n\nReduced Operator Assembly: Project per-region blocks \\((K_{\\lambda,\\text{region}}, K_{\\mu,\\text{region}})\\) into the reduced space, yielding ultra-compact operators.\n\nThe reduced model is now ready for very rapid online predictions.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#online-workflow-fast-evaluation",
    "href": "problem_structure.html#online-workflow-fast-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "8. Online Workflow: Fast Evaluation",
    "text": "8. Online Workflow: Fast Evaluation\nFor a new parameter set \\((E, \\nu)\\):\n\nCompute Per-Region Lamé Parameters: Map input parameters to \\((\\lambda, \\mu)\\) values for each region.\nAssemble Reduced Stiffness: Combine precomputed regionwise blocks using affine expressions.\nSolve Reduced System: The resulting linear system has size equal to the number of modes \\((r \\ll N)\\), making it extremely fast.\nMean Recovery: Add back the mean field to produce the full-field displacement solution, ready for visualization or further analysis.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#validation-error-assessment",
    "href": "problem_structure.html#validation-error-assessment",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "9. Validation & Error Assessment",
    "text": "9. Validation & Error Assessment\nTest Set: Evaluate the ROM on held-out (never-seen) parameter pairs.\nError Metrics:\n\nRelative error (L2 or energy norm) between ROM and high-fidelity FOM solutions\nStatistical fit metrics (e.g., R² score)\n\nSpeed-up Factor: The ROM typically achieves significant speed-up (often orders of magnitude) versus direct FEM.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#summary-table-of-key-methods",
    "href": "problem_structure.html#summary-table-of-key-methods",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "10. Summary Table of Key Methods",
    "text": "10. Summary Table of Key Methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nTypical Location in Pipeline\n\n\n\n\ndomain()\nSetup mesh, BCs, DOFs, and per-region bases\nFirst, before assembly\n\n\nbilinear_forms()\nReturn affine form handles for λ, μ\nOperator initialization\n\n\nlinear_forms()\nSpecify right-hand-side (load)\nOperator assembly\n\n\nproperties()\nMap (E, ν, region) → (λ, μ)\nParameter unpacking\n\n\nparameters()\nProduce sampled (E, ν) + train/test masks\nOffline/online split\n\n\nfom_solver()\nRun and store full-order solutions\nSnapshot generation (offline)\n\n\nrom_solver()\nAssemble and solve projected ROM system\nRapid online prediction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#code-snippets-for-each-stage",
    "href": "problem_structure.html#code-snippets-for-each-stage",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "11. Code Snippets for Each Stage",
    "text": "11. Code Snippets for Each Stage\nParameter Sampling Example:\nparams, param_ranges, train_mask, test_mask = parameters(32)\nDomain Setup Example:\ndom = domain_()\nmesh = dom['mesh']\nbasis = dom['basis']\nregions = dom['basis_regions']\nAffine Block Assembly:\nstiffness_lam, stiffness_mu = bilinear_forms()\nK_lambda = asm(stiffness_lam, region_basis, ...)\nK_mu = asm(stiffness_mu, region_basis, ...)\nFull-Order Solve:\nu = solve(*condense(K, rhs, x=fixed_values, D=dirichlet_dofs))\nROM Solve Online:\nms_full_sol, mean_shift = rom_solver(param)\nfull_field = ms_full_sol + mean_shift",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#best-practices",
    "href": "problem_structure.html#best-practices",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "12. Best Practices",
    "text": "12. Best Practices\n\nAlways center your snapshot data before SVD to ensure best POD convergence\nUse enough training samples (and parameter space coverage) to avoid overfitting or “holes” in ROM accuracy\nCheck ROM error on multiple, unseen test samples\nVisualize spatial error fields—not just scalar error metrics—for insight into local ROM limitations\nLeverage the modular file structure for extending to other domains, BCs, and PDEs\n\nThis workflow and modular codebase provide a flexible, scalable foundation for reduced-order modeling of parametrized PDEs in computational mechanics, accelerating simulation, optimization, and interactive design.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  }
]