[
  {
    "objectID": "twisting.html#problem-setup",
    "href": "twisting.html#problem-setup",
    "title": "P.2 Twisting of a Neo-Hookean Block",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.2 Twisting of a Neo-Hookean Block"
    ]
  },
  {
    "objectID": "Resources/intro/rom_intro.html",
    "href": "Resources/intro/rom_intro.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "scikit-rom\nscikit-rom is a lightweight, Python-based platform designed for projection-based model reduction of finite element models with moderate to large problem sizes (up to approximately 600,000 degrees of freedom). Built on top of scikit-fem, an easy-to-use finite element assembly library, this repository demonstrates reduced-order modeling (ROM) techniques for a range of linear and nonlinear problems, including time-dependent ones. Current examples primarily focus on thermal and mechanical systems, with extensions to fluid dynamics planned for future releases.\nBeyond its application to real-world finite element problems, the library also serves as a valuable testing ground for new model reduction algorithms and as a tutorial resource for those new to the field.\n\n\n\nWhat is Reduced-Order Modeling?\nReduced-order modeling (ROM) is a computational strategy for approximating high-fidelity numerical models with significantly reduced computational cost. Instead of solving large-scale systems—often with millions of unknowns—ROM techniques construct low-dimensional surrogates that retain the dominant physics of the system, enabling efficient and repeated evaluations.\nThe underlying principle is that many physical systems exhibit behavior that can be captured by a small number of dominant modes, despite their discretization on fine spatial meshes. Techniques such as Proper Orthogonal Decomposition (POD) extract these modes from full-order simulations, enabling the construction of reduced models that are both accurate and computationally efficient.\n\n\n\nOffline–Online Decomposition\nscikit-rom implements the classical offline–online decomposition paradigm:\n\nOffline Phase (computationally intensive, performed once):\n\nSampling of the parameter space\nGeneration of full-order solution snapshots\nComputation of the reduced basis via singular value decomposition (SVD)\nAssembly of parameter-independent reduced operators\n\nOnline Phase (efficient, performed repeatedly):\n\nEvaluation of the system response for new parameter values using preassembled reduced operators\nSpeedups on the order of 10–500× relative to full-order models are typical"
  },
  {
    "objectID": "reference/utils.visualization.html",
    "href": "reference/utils.visualization.html",
    "title": "utils.visualization",
    "section": "",
    "text": "utils.visualization"
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html",
    "href": "reference/utils.visualization.generate_vtu.html",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "utils.visualization.generate_vtu\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html#functions",
    "href": "reference/utils.visualization.generate_vtu.html#functions",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html",
    "href": "reference/utils.visualization.color_palette.html",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "utils.visualization.color_palette\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html#functions",
    "href": "reference/utils.visualization.color_palette.html#functions",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.rom_error_est.html",
    "href": "reference/utils.rom_error_est.html",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "utils.rom_error_est\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.rom_error_est.html#functions",
    "href": "reference/utils.rom_error_est.html#functions",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.reduced_basis.html",
    "href": "reference/utils.reduced_basis.html",
    "title": "utils.reduced_basis",
    "section": "",
    "text": "utils.reduced_basis"
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html",
    "href": "reference/utils.newton_solver_rom.html",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "utils.newton_solver_rom\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html#functions",
    "href": "reference/utils.newton_solver_rom.html#functions",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.imports.html",
    "href": "reference/utils.imports.html",
    "title": "utils.imports",
    "section": "",
    "text": "utils.imports\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework: – Core imports for OS, filesystem, timing, and randomness – Numerical & symbolic computing: NumPy, SciPy (dense & sparse), Sympy – Finite‐element tools: scikit‐fem (from skfem import *), mesh I/O via meshio – Linear algebra solvers: dense (LU), sparse (splu, spilu, CG), and multigrid (pyamg) – Sampling & design‐of‐experiments: Sobol, Latin Hypercube (SciPy QMC & pyDOE) – Plotting & visualization: Matplotlib (2D/3D, custom styles), ptitprince, and optional animation modules\n– Utilities for dynamic imports, path handling, and Cartesian products These imports and utilities ensure consistent, ready‐to‐use functionality across the entire reduced‐order modeling pipeline.",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.imports"
    ]
  },
  {
    "objectID": "reference/utils.errors.html",
    "href": "reference/utils.errors.html",
    "title": "utils.errors",
    "section": "",
    "text": "utils.errors\nutils.errors"
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html",
    "href": "reference/utils.dynamics.integrators.html",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "utils.dynamics.integrators\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n[Code: Suparno Bhattacharyya]\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html#functions",
    "href": "reference/utils.dynamics.integrators.html#functions",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n[Code: Suparno Bhattacharyya]\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.basis.pod.html",
    "href": "reference/utils.basis.pod.html",
    "title": "utils.basis.pod",
    "section": "",
    "text": "utils.basis.pod\nutils.basis.pod"
  },
  {
    "objectID": "reference/templates.problem_template.properties.html",
    "href": "reference/templates.problem_template.properties.html",
    "title": "templates.problem_template.properties",
    "section": "",
    "text": "templates.problem_template.properties\n\n\n\n\n\nName\nDescription\n\n\n\n\nproperty_fn\nTemplate for a material or source property function.\n\n\n\n\n\ntemplates.problem_template.properties.property_fn(param)\nTemplate for a material or source property function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparam\nfloat\nUser-defined parameter controlling the property.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nComputed property value.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.properties"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.properties.html#functions",
    "href": "reference/templates.problem_template.properties.html#functions",
    "title": "templates.problem_template.properties",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nproperty_fn\nTemplate for a material or source property function.\n\n\n\n\n\ntemplates.problem_template.properties.property_fn(param)\nTemplate for a material or source property function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparam\nfloat\nUser-defined parameter controlling the property.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nComputed property value.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.properties"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.params.html",
    "href": "reference/templates.problem_template.params.html",
    "title": "templates.problem_template.params",
    "section": "",
    "text": "templates.problem_template.params\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameters\nTemplate for generating training/testing parameter samples.\n\n\n\n\n\ntemplates.problem_template.params.parameters(N_snap)\nTemplate for generating training/testing parameter samples.\nUses generate_sobol from skrom.rom.rom_utils to sample uniformly over each interval in param_ranges.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of samples per set.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nparams\n(ndarray, shape(2 * N_snap, D))\nStacked [training; testing] samples.\n\n\nparam_ranges\nlist of tuple\n[(p1_min, p1_max), …, (pD_min, pD_max)] for each parameter.\n\n\ntrain_mask\nndarray of bool\nTrue for the first N_snap entries of params.\n\n\ntest_mask\nndarray of bool\nTrue for the remaining entries.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.params"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.params.html#functions",
    "href": "reference/templates.problem_template.params.html#functions",
    "title": "templates.problem_template.params",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nparameters\nTemplate for generating training/testing parameter samples.\n\n\n\n\n\ntemplates.problem_template.params.parameters(N_snap)\nTemplate for generating training/testing parameter samples.\nUses generate_sobol from skrom.rom.rom_utils to sample uniformly over each interval in param_ranges.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of samples per set.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nparams\n(ndarray, shape(2 * N_snap, D))\nStacked [training; testing] samples.\n\n\nparam_ranges\nlist of tuple\n[(p1_min, p1_max), …, (pD_min, pD_max)] for each parameter.\n\n\ntrain_mask\nndarray of bool\nTrue for the first N_snap entries of params.\n\n\ntest_mask\nndarray of bool\nTrue for the remaining entries.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.params"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.domain.html",
    "href": "reference/templates.problem_template.domain.html",
    "title": "templates.problem_template.domain",
    "section": "",
    "text": "templates.problem_template.domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain_\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\ntemplates.problem_template.domain.domain_(**kwargs)\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\nAny problem-specific parameters needed for mesh generation, basis construction, and boundary identification.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{ ‘mesh’: , ‘basis’: , ‘free_dofs’: , ‘dirichlet_dofs’: , ‘dirichlet_value’: , # add other entries as needed }",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.domain"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.domain.html#functions",
    "href": "reference/templates.problem_template.domain.html#functions",
    "title": "templates.problem_template.domain",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndomain_\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\ntemplates.problem_template.domain.domain_(**kwargs)\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\nAny problem-specific parameters needed for mesh generation, basis construction, and boundary identification.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{ ‘mesh’: , ‘basis’: , ‘free_dofs’: , ‘dirichlet_dofs’: , ‘dirichlet_value’: , # add other entries as needed }",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.domain"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html",
    "href": "reference/rom.rom_utils.html",
    "title": "rom.rom_utils",
    "section": "",
    "text": "rom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O, and Newton solvers in reduced‐order modeling (ROM) workflows.\nThis module provides:\n\nSnapshot train/test splitting routines:\n\ntrain_test_split, latin_hypercube_train_test_split, sobol_train_test_split\n\nSample generators:\n\ngenerate_sobol, generate_lhs, generate_gaussian_samples\n\nBasis management:\n\nupdate_basis – deflation and augmentation of reduced bases\n\nSolution reconstruction:\n\nreconstruct_solution – expand reduced vectors back to full order\n\nROM data persistence:\n\nrom_data_gen, load_rom_data\n\nNewton solvers for ROM systems:\n\nnewton_hyper_rom_solver, newton_solver_rom\n\n\nTogether, these functions support data preparation, sampling design, basis enrichment, I/O, and nonlinear solves in full‐to‐reduced‐order pipelines.\n[Authors: Suparno Bhattacharyya, Ali Hamza Abidi Syed]\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_residuals\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\n\n\ncompute_nonlinear_snapshots\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve nonlinear reduced-order system using Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nselect_elements_and_gauss_weights\nSelect elements and corresponding weights from Gauss points, ensuring consistency\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n)\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\nThis function processes training snapshots to collect residual evaluations that will be used for hyperreduction (reducing computational cost of nonlinear ROM terms).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfos_solutions\nndarray\nFull order solutions (not directly used but maintained for interface consistency)\nrequired\n\n\nNLS_train_ms\n(ndarray, shape(n_snapshots, n_dofs))\nMean-subtracted training snapshots (temperature fluctuations from mean)\nrequired\n\n\nNLS_train_mean\n(ndarray, shape(n_dofs))\nMean temperature field across all training snapshots\nrequired\n\n\nV_sel\n(ndarray, shape(n_dofs, n_modes))\nSelected POD basis matrix (reduced basis vectors)\nrequired\n\n\nreconstruct_solution\ncallable\nFunction to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean)\nrequired\n\n\nResidual\nLinearFormROM object\nROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nq_mus\n(ndarray, shape(n_snapshots, n_residual_components))\nCollected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter\n\n\n\n\n\n\n\nrom.rom_utils.compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n)\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnon_linear_func\n\nA function with signature non_linear_func(u=, param=) → array.\nrequired\n\n\nfos_solutions\n\nSequence of full-order solutions (each an ndarray).\nrequired\n\n\nparam_list\n\nSequence of parameter values, same length as fos_solutions.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_nl\nndarray\nArray of shape (n_snapshots, …) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]).\n\n\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.03,\n    maxit=200,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.03\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n200\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    alpha=1.0,\n    tol=0.001,\n    maxit=100,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve nonlinear reduced-order system using Newton’s method.\nProvides two solution strategies: efficient LU refactorization for ROM systems or direct solving with adaptive step damping.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction that assembles Jacobian and residual: (J, R) = func(u_rom, …)\nrequired\n\n\nu_rom\narray - like\nInitial guess for reduced-order state vector\nrequired\n\n\n*args\ntuple\nAdditional positional arguments passed to assemble_func\n()\n\n\nalpha\nfloat\nStep size damping factor (only used when use_lu=False)\n1.0\n\n\ntol\nfloat\nConvergence tolerance on Newton step norm\n1e-3\n\n\nmaxit\nint\nMaximum number of Newton iterations\n100\n\n\nuse_lu\nbool\nIf True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction.\nFalse\n\n\njac_tol\nfloat\nRelative tolerance for Jacobian reuse (only used when use_lu=True)\n1e-1\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to assemble_func\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\narray - like\nConverged reduced-order state vector u_rom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf Newton iteration fails to converge within maxit iterations (only when use_lu=True)\n\n\n\n\n\n\n\nLU mode: Reuses Jacobian factorization until relative change exceeds jac_tol\nDirect mode: Applies adaptive damping every 40 iterations, includes logging\nPart of ROM workflow for efficient nonlinear system solving\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.select_elements_and_gauss_weights(\n    n_gauss_points,\n    element_indices,\n    weights,\n)\nSelect elements and corresponding weights from Gauss points, ensuring consistency by including all Gauss points for each selected element with zero weights for unselected points.\nParameters: n_gauss_points (int): Number of Gauss points per element. element_indices (list or array): Selected Gauss point indices from ECM. weights (list or array): Corresponding weights for selected indices.\nReturns: dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points. For each selected element, the list will have exactly n_gauss_points entries.\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html#functions",
    "href": "reference/rom.rom_utils.html#functions",
    "title": "rom.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncollect_residuals\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\n\n\ncompute_nonlinear_snapshots\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve nonlinear reduced-order system using Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nselect_elements_and_gauss_weights\nSelect elements and corresponding weights from Gauss points, ensuring consistency\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n)\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\nThis function processes training snapshots to collect residual evaluations that will be used for hyperreduction (reducing computational cost of nonlinear ROM terms).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfos_solutions\nndarray\nFull order solutions (not directly used but maintained for interface consistency)\nrequired\n\n\nNLS_train_ms\n(ndarray, shape(n_snapshots, n_dofs))\nMean-subtracted training snapshots (temperature fluctuations from mean)\nrequired\n\n\nNLS_train_mean\n(ndarray, shape(n_dofs))\nMean temperature field across all training snapshots\nrequired\n\n\nV_sel\n(ndarray, shape(n_dofs, n_modes))\nSelected POD basis matrix (reduced basis vectors)\nrequired\n\n\nreconstruct_solution\ncallable\nFunction to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean)\nrequired\n\n\nResidual\nLinearFormROM object\nROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nq_mus\n(ndarray, shape(n_snapshots, n_residual_components))\nCollected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter\n\n\n\n\n\n\n\nrom.rom_utils.compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n)\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnon_linear_func\n\nA function with signature non_linear_func(u=, param=) → array.\nrequired\n\n\nfos_solutions\n\nSequence of full-order solutions (each an ndarray).\nrequired\n\n\nparam_list\n\nSequence of parameter values, same length as fos_solutions.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_nl\nndarray\nArray of shape (n_snapshots, …) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]).\n\n\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.03,\n    maxit=200,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.03\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n200\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    alpha=1.0,\n    tol=0.001,\n    maxit=100,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve nonlinear reduced-order system using Newton’s method.\nProvides two solution strategies: efficient LU refactorization for ROM systems or direct solving with adaptive step damping.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction that assembles Jacobian and residual: (J, R) = func(u_rom, …)\nrequired\n\n\nu_rom\narray - like\nInitial guess for reduced-order state vector\nrequired\n\n\n*args\ntuple\nAdditional positional arguments passed to assemble_func\n()\n\n\nalpha\nfloat\nStep size damping factor (only used when use_lu=False)\n1.0\n\n\ntol\nfloat\nConvergence tolerance on Newton step norm\n1e-3\n\n\nmaxit\nint\nMaximum number of Newton iterations\n100\n\n\nuse_lu\nbool\nIf True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction.\nFalse\n\n\njac_tol\nfloat\nRelative tolerance for Jacobian reuse (only used when use_lu=True)\n1e-1\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to assemble_func\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\narray - like\nConverged reduced-order state vector u_rom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf Newton iteration fails to converge within maxit iterations (only when use_lu=True)\n\n\n\n\n\n\n\nLU mode: Reuses Jacobian factorization until relative change exceeds jac_tol\nDirect mode: Applies adaptive damping every 40 iterations, includes logging\nPart of ROM workflow for efficient nonlinear system solving\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.select_elements_and_gauss_weights(\n    n_gauss_points,\n    element_indices,\n    weights,\n)\nSelect elements and corresponding weights from Gauss points, ensuring consistency by including all Gauss points for each selected element with zero weights for unselected points.\nParameters: n_gauss_points (int): Number of Gauss points per element. element_indices (list or array): Selected Gauss point indices from ECM. weights (list or array): Corresponding weights for selected indices.\nReturns: dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points. For each selected element, the list will have exactly n_gauss_points entries.\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.html",
    "href": "reference/rom.html",
    "title": "rom",
    "section": "",
    "text": "rom\nThe rom folder provides core reduced‐order modeling tools:\n– Projection & assembly classes (BilinearFormROM, LinearFormROM): • Project full‐order stiffness and load contributions onto reduced bases • Handle Dirichlet boundary conditions via free‐DOF mappings • Support chunked/clustered assembly for memory‐efficient reduced operators\n– Error evaluation & visualization (error_utils.py): • Compute time‐dependent and global error metrics (L2, RMSE, R², energy‐norm, etc.) • Generate scatter plots, spatial snapshots, raincloud plots, and tabular reports\n– ROM utilities (utils.py): • Snapshot splitting and sampling (random, Latin‐Hypercube, Sobol, Gaussian) • Basis enrichment via deflation and QR re‐orthonormalization • Solution reconstruction from reduced coefficients • Data I/O for ROM simulations (rom_data_gen, load_rom_data) • Newton solvers for (hyper‐)reduced systems"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html",
    "href": "reference/rom.linear_form_hyperrom.html",
    "title": "rom.linear_form_hyperrom",
    "section": "",
    "text": "rom.linear_form_hyperrom"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.linear_form_hyperrom",
    "section": "hyperreduce/linear_form_hyperrom.py",
    "text": "hyperreduce/linear_form_hyperrom.py\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#classes",
    "href": "reference/rom.linear_form_hyperrom.html#classes",
    "title": "rom.linear_form_hyperrom",
    "section": "Classes",
    "text": "Classes\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\nLinearFormHYPERROM\nrom.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\nassemble_weighted\nrom.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(**kwargs)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\nextract_element_vector\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\nextract_element_vector_rom\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.linear_form_hyperrom_ecsw\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides:\n\nLinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\n\nThe hyperreduce folder contains all tools to perform hyper-reduction, including:\n\nReduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM)\nRoutines for extracting element stiffness matrices and load vectors in a reduced basis\nUtilities for efficient handling of Dirichlet conditions and element clustering\nSupport for weights, parallelization, and reconstruction of full-order data\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_ecsw\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides:\n\nLinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\n\nThe hyperreduce folder contains all tools to perform hyper-reduction, including:\n\nReduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM)\nRoutines for extracting element stiffness matrices and load vectors in a reduced basis\nUtilities for efficient handling of Dirichlet conditions and element clustering\nSupport for weights, parallelization, and reconstruction of full-order data\n\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_ecsw\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html",
    "href": "reference/rom.ecsw.custom_nnls.html",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "rom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides:\n\nNNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS.\n_verify: internal helper to assert solver invariants.\nNNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\n\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including:\n\nAlgorithms to compute cubature weights using bounded NNLS.\nSelection and pruning of integration points via active-set methods.\nSupport functions for convergence criteria and solver configuration.\n\n[Original C++ code: libROM team at LLNL, Python adaptation: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html#classes",
    "href": "reference/rom.ecsw.custom_nnls.html#classes",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.linear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element linear forms.\nThis module implements hyperreduction of linear forms using the Discrete Empirical Interpolation Method (DEIM) combined with element sampling for efficient load vector assembly. It provides dramatic computational speedups by:\n\nAssembling only a subset of finite elements based on DEIM selection\nUsing efficient vector assembly techniques for sparse operations\nReconstructing full load vectors via DEIM interpolation matrices\nSupporting parallel element vector extraction when available\n\nTL;DR: Enables speedup in linear form assembly for ROMs by evaluating only essential elements and reconstructing the full load vector through intelligent interpolation.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\nTL;DR: Dramatically accelerates linear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time ROM applications with parameter-dependent forcing terms.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in linear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled for load vector construction, dramatically reducing the active element count.\nSparse Assembly: Assembles only the selected elements using efficient vector assembly techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order load vector using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order load vector onto the reduced test basis to produce the final reduced-order linear form.\n\nThis hyperreduction is particularly effective for problems where: - Load distributions are spatially localized or have low-rank structure - Real-time simulation speed is critical for control applications - Parameter-dependent forcing terms exhibit smooth variation - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time ROM evaluation with parameter-dependent loads.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function to be hyperreduced. Should accept test basis functions and return element-wise load contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection analysis.\nrequired\n\n\nubasis\nBasis\nTest basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix that projects full-order load vectors to the r-dimensional reduced test space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order load vectors from sampled values: F_reduced = deim_mat @ F_sampled[sampled_rows]\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean load vector for centering. Required if load data was mean-subtracted during DEIM basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element vector extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\nndarray of shape (n_free, r)\nCopy of the left (test) reduced basis matrix for load vector projection.\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements for assembly.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis\nBasis\nOriginal full-order finite element basis reference.\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for load vector reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows\nndarray of shape (n_active_elements * n_local_dofs,)\nFlattened element-DOF indices for efficient vector assembly operations.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced load vector using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse load vector over hyperreduced element set.\n\n\nextract_element_vector_rom\nExtract element load vectors for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced load vector using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order load vector.\nThis method orchestrates the complete hyperreduction assembly process:\n\nParameter Setup: Combines default finite element parameters with user-provided kwargs for element-level load evaluation.\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order load vector using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse vector, providing the minimal information needed for reconstruction.\nVector Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order load vector from the sampled values.\n\nThe mathematical operation performed is: F_reduced = deim_mat @ F_sampled[sampled_rows]\nwhere F_sampled is the sparse load vector assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control, such as material parameters or time-dependent loading conditions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_reduced\nndarray of shape (r,)\nReduced-order load vector ready for use in ROM systems. This is the hyperreduced approximation of the full-order load projected onto the reduced test basis.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse load vector over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element load vectors only from selected elements and building the global sparse load vector using optimized scatter-add operations.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction for load vectors:\n\nElement Vector Extraction: Calls extract_element_vector_rom() to compute local load contributions for selected elements only, avoiding expensive integration over the entire domain.\nData Preparation: Flattens the element load vectors into a 1D array matching the connectivity pattern for efficient assembly.\nScatter-Add Assembly: Uses NumPy’s add.at function to efficiently accumulate element contributions at their global DOF locations, handling overlapping contributions correctly.\n\nThe assembly process preserves the mathematical structure of the full-order load vector while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_vector_rom for controlling element-level assembly behavior, such as load magnitude parameters or spatial distribution functions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf\nndarray of shape (n_dofs,)\nSparse global load vector assembled over the hyperreduced element set. Only selected elements contribute to this vector, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element load vectors for hyperreduced mesh assembly.\nTL;DR: Computes local element load vectors for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global load vector assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global linear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the linear form: F_e[i] = ∫_Ω_e φ_i(x) * form(x) dx\nwhere φ_i are test basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nFinite element basis for test functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the linear form evaluation, such as load magnitude parameters, time-dependent coefficients, or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\nndarray of shape (n_elements, n_local_dofs)\nArray of local element load vectors. Each element_vectors[e] contains the n_local_dofs-length load vector for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no valid basis is provided for the load vector extraction.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\nTL;DR: Dramatically accelerates linear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time ROM applications with parameter-dependent forcing terms.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in linear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled for load vector construction, dramatically reducing the active element count.\nSparse Assembly: Assembles only the selected elements using efficient vector assembly techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order load vector using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order load vector onto the reduced test basis to produce the final reduced-order linear form.\n\nThis hyperreduction is particularly effective for problems where: - Load distributions are spatially localized or have low-rank structure - Real-time simulation speed is critical for control applications - Parameter-dependent forcing terms exhibit smooth variation - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time ROM evaluation with parameter-dependent loads.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function to be hyperreduced. Should accept test basis functions and return element-wise load contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection analysis.\nrequired\n\n\nubasis\nBasis\nTest basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix that projects full-order load vectors to the r-dimensional reduced test space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order load vectors from sampled values: F_reduced = deim_mat @ F_sampled[sampled_rows]\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean load vector for centering. Required if load data was mean-subtracted during DEIM basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element vector extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\nndarray of shape (n_free, r)\nCopy of the left (test) reduced basis matrix for load vector projection.\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements for assembly.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis\nBasis\nOriginal full-order finite element basis reference.\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for load vector reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows\nndarray of shape (n_active_elements * n_local_dofs,)\nFlattened element-DOF indices for efficient vector assembly operations.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced load vector using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse load vector over hyperreduced element set.\n\n\nextract_element_vector_rom\nExtract element load vectors for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced load vector using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order load vector.\nThis method orchestrates the complete hyperreduction assembly process:\n\nParameter Setup: Combines default finite element parameters with user-provided kwargs for element-level load evaluation.\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order load vector using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse vector, providing the minimal information needed for reconstruction.\nVector Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order load vector from the sampled values.\n\nThe mathematical operation performed is: F_reduced = deim_mat @ F_sampled[sampled_rows]\nwhere F_sampled is the sparse load vector assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control, such as material parameters or time-dependent loading conditions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_reduced\nndarray of shape (r,)\nReduced-order load vector ready for use in ROM systems. This is the hyperreduced approximation of the full-order load projected onto the reduced test basis.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse load vector over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element load vectors only from selected elements and building the global sparse load vector using optimized scatter-add operations.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction for load vectors:\n\nElement Vector Extraction: Calls extract_element_vector_rom() to compute local load contributions for selected elements only, avoiding expensive integration over the entire domain.\nData Preparation: Flattens the element load vectors into a 1D array matching the connectivity pattern for efficient assembly.\nScatter-Add Assembly: Uses NumPy’s add.at function to efficiently accumulate element contributions at their global DOF locations, handling overlapping contributions correctly.\n\nThe assembly process preserves the mathematical structure of the full-order load vector while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_vector_rom for controlling element-level assembly behavior, such as load magnitude parameters or spatial distribution functions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf\nndarray of shape (n_dofs,)\nSparse global load vector assembled over the hyperreduced element set. Only selected elements contribute to this vector, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element load vectors for hyperreduced mesh assembly.\nTL;DR: Computes local element load vectors for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global load vector assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global linear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the linear form: F_e[i] = ∫_Ω_e φ_i(x) * form(x) dx\nwhere φ_i are test basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nFinite element basis for test functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the linear form evaluation, such as load magnitude parameters, time-dependent coefficients, or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\nndarray of shape (n_elements, n_local_dofs)\nArray of local element load vectors. Each element_vectors[e] contains the n_local_dofs-length load vector for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no valid basis is provided for the load vector extraction.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.bilinear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.bilinear_form_hyperrom_deim.html",
    "title": "rom.deim.bilinear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.bilinear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element bilinear forms.\nThis module implements hyperreduction of bilinear forms using the Discrete Empirical Interpolation Method (DEIM) combined with element sampling. It provides dramatic computational speedups by:\n\nAssembling only a subset of finite elements based on DEIM selection\nUsing sparse matrix techniques for efficient memory usage\nReconstructing full operators via DEIM interpolation matrices\nSupporting parallel element matrix extraction when available\n\nTL;DR: Enables ~100-1000x speedup in bilinear form assembly for ROMs by evaluating only essential elements and reconstructing the full operator through intelligent interpolation.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_deim\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    sampled_rows,\n    deim_mat,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time nonlinear ROM applications.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in bilinear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled, dramatically reducing the active element count from thousands to tens.\nSparse Assembly: Assembles only the selected elements using efficient sparse matrix techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order operator using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order matrix onto the reduced basis to produce the final reduced-order bilinear form.\n\nThis hyperreduction is particularly effective for problems where: - Nonlinear effects are spatially localized - Real-time simulation speed is critical - The parameter-dependent operators have low-rank structure - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time nonlinear ROM evaluation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept basis functions and return element-wise contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection.\nrequired\n\n\nubasis\nBasis\nTrial/test basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix. Currently unused in this implementation but maintained for interface compatibility.\nrequired\n\n\nrob\nndarray of shape (n_free, r)\nRight (trial) reduced basis matrix that projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order operators from sampled values: A_reduced = deim_mat @ A_sampled[sampled_rows] @ rob\nrequired\n\n\nvbasis\nBasis\nTest function basis. If None, defaults to ubasis for Galerkin methods.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean solution snapshot for centering. Required if snapshot data was mean-subtracted during basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for operator reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_elems\nint\nNumber of active elements in the hyperreduced mesh.\n\n\nn_loc\nint\nNumber of local degrees of freedom per element.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows, cols\nndarray\nBroadcasted row and column indices for sparse matrix assembly.\n\n\nrow_flat, col_flat\nndarray\nFlattened index arrays for efficient COO matrix construction.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse matrix over hyperreduced element set.\n\n\nextract_element_matrices_rom\nExtract element matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order operator matrix.\nThis method orchestrates the complete hyperreduction assembly process:\n\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order matrix using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse matrix, providing the minimal information needed for reconstruction.\nOperator Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order operator from the sampled values.\nBasis Projection: Projects the reconstructed operator onto the reduced trial basis to produce the final r×r reduced-order matrix.\n\nThe mathematical operation performed is: A_reduced = deim_mat @ A_sampled[sampled_rows, :] @ rob\nwhere A_sampled is the sparse matrix assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nA_reduced\nndarray of shape (r, r)\nReduced-order bilinear form matrix ready for use in ROM systems. This is the hyperreduced approximation of the full-order operator projected onto the reduced basis.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse matrix over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element matrices only from selected elements and building the global sparse matrix using optimized COO format construction.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction:\n\nElement Matrix Extraction: Calls extract_element_matrices_rom() to compute local stiffness matrices for selected elements only, avoiding expensive integration over the entire domain.\nSparse Data Preparation: Flattens the element matrices and corresponding row/column indices into triplet format (I, J, V) suitable for sparse matrix construction.\nZero Filtering: Optionally removes zero entries to minimize memory usage and improve sparse matrix performance.\nCOO Construction: Builds the sparse matrix using coordinate (COO) format and converts to compressed sparse row (CSR) for efficient subsequent operations.\n\nThe assembly process preserves the mathematical structure of the full-order operator while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_matrices_rom for controlling element-level assembly behavior.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK\nscipy.sparse.csr_matrix of shape (n_dofs, n_dofs)\nSparse global stiffness matrix assembled over the hyperreduced element set. Only selected elements contribute to this matrix, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nFinite element basis for trial functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nFinite element basis for test functions. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.bilinear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.bilinear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.bilinear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.bilinear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_deim\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    sampled_rows,\n    deim_mat,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time nonlinear ROM applications.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in bilinear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled, dramatically reducing the active element count from thousands to tens.\nSparse Assembly: Assembles only the selected elements using efficient sparse matrix techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order operator using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order matrix onto the reduced basis to produce the final reduced-order bilinear form.\n\nThis hyperreduction is particularly effective for problems where: - Nonlinear effects are spatially localized - Real-time simulation speed is critical - The parameter-dependent operators have low-rank structure - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time nonlinear ROM evaluation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept basis functions and return element-wise contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection.\nrequired\n\n\nubasis\nBasis\nTrial/test basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix. Currently unused in this implementation but maintained for interface compatibility.\nrequired\n\n\nrob\nndarray of shape (n_free, r)\nRight (trial) reduced basis matrix that projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order operators from sampled values: A_reduced = deim_mat @ A_sampled[sampled_rows] @ rob\nrequired\n\n\nvbasis\nBasis\nTest function basis. If None, defaults to ubasis for Galerkin methods.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean solution snapshot for centering. Required if snapshot data was mean-subtracted during basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for operator reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_elems\nint\nNumber of active elements in the hyperreduced mesh.\n\n\nn_loc\nint\nNumber of local degrees of freedom per element.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows, cols\nndarray\nBroadcasted row and column indices for sparse matrix assembly.\n\n\nrow_flat, col_flat\nndarray\nFlattened index arrays for efficient COO matrix construction.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse matrix over hyperreduced element set.\n\n\nextract_element_matrices_rom\nExtract element matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order operator matrix.\nThis method orchestrates the complete hyperreduction assembly process:\n\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order matrix using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse matrix, providing the minimal information needed for reconstruction.\nOperator Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order operator from the sampled values.\nBasis Projection: Projects the reconstructed operator onto the reduced trial basis to produce the final r×r reduced-order matrix.\n\nThe mathematical operation performed is: A_reduced = deim_mat @ A_sampled[sampled_rows, :] @ rob\nwhere A_sampled is the sparse matrix assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nA_reduced\nndarray of shape (r, r)\nReduced-order bilinear form matrix ready for use in ROM systems. This is the hyperreduced approximation of the full-order operator projected onto the reduced basis.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse matrix over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element matrices only from selected elements and building the global sparse matrix using optimized COO format construction.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction:\n\nElement Matrix Extraction: Calls extract_element_matrices_rom() to compute local stiffness matrices for selected elements only, avoiding expensive integration over the entire domain.\nSparse Data Preparation: Flattens the element matrices and corresponding row/column indices into triplet format (I, J, V) suitable for sparse matrix construction.\nZero Filtering: Optionally removes zero entries to minimize memory usage and improve sparse matrix performance.\nCOO Construction: Builds the sparse matrix using coordinate (COO) format and converts to compressed sparse row (CSR) for efficient subsequent operations.\n\nThe assembly process preserves the mathematical structure of the full-order operator while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_matrices_rom for controlling element-level assembly behavior.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK\nscipy.sparse.csr_matrix of shape (n_dofs, n_dofs)\nSparse global stiffness matrix assembled over the hyperreduced element set. Only selected elements contribute to this matrix, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nFinite element basis for trial functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nFinite element basis for test functions. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.bilinear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/problem_structure.html",
    "href": "reference/problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Linear Elasticity\n\n\n\nGoal. This comprehensive hands-on tutorial walks you through every file in problem_1 and shows how to assemble an affine reduced-order model (ROM) for a 3-D linear-elastic block using scikit-rom. We’ll explain the theory behind each step and demonstrate how reduced-order modeling can dramatically accelerate computational mechanics simulations.\n\n\n\n\nReduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples\n\n\n\n\n\nFirst, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible.\n\n\n\n\nThe domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable.\n\n\n\n\nThis module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement\n\n\n\n\nThis is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase.\n\n\n\n\nThis module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads\n\n\n\n\nFor ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.\nfrom src.skrom.rom.rom_utils import generate_sobol\n\ndef parameters(N_snap=32):\n    # Sobol over (E, nu) in [100, 200] × [0.25, 0.35]\n    return generate_sobol([[100.,200.],[0.25,0.35]], 2*N_snap)\nDetailed Explanation:\n\nSobol Sequences: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.\nParameter Ranges:\n\nYoung’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)\nPoisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)\n\nSample Size: 2*N_snap samples are generated so they can be split into training and testing sets.\n\nUsage Pattern:\nE_nu_train, E_nu_test = np.split(parameters(32), 2)\nThis gives you 32 training samples and 32 testing samples for validation.\nWhy Good Sampling Matters: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others.\n\n\n\n\nThis is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\n\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations.\n\n\n\n\n\nThe offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.\nfrom src.skrom.problem_classes import new_problem\n\nprob = new_problem(\"problem_1\")\n\n# 1) draw parameter samples\ntheta_train = prob.parameters(n_samples=64)\n\n# 2) build snapshots\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\n\n# 3) compute POD basis\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\n\n# 4) assemble reduced operators\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nDetailed Step-by-Step Explanation:\n\n\ntheta_train = prob.parameters(n_samples=64)\nThis generates 64 parameter combinations \\((E_i, \\nu_i)\\) using the Sobol sequence. These parameters should span the expected range of operating conditions.\n\n\n\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\nFor each parameter combination, the full finite element problem is solved: \\[K(\\theta_i) u_i = f\\]\nThe resulting displacement vectors \\(u_i\\) are called “snapshots” and are stored as columns in matrix \\(U\\). If you have \\(N\\) degrees of freedom and \\(n_{snap}\\) parameter samples, then \\(U \\in \\mathbb{R}^{N \\times n_{snap}}\\).\n\n\n\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\nPOD performs Singular Value Decomposition on the snapshot matrix: \\[U = V \\Sigma W^T\\]\nThe columns of \\(V\\) are the POD modes, ordered by importance (largest singular values first). We keep only the first \\(r=50\\) modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.\nKey Insight: The POD basis \\(V\\) captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.\n\n\n\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nThe full-order operators are projected onto the reduced space: \\[A_r^q = V^T A^q V, \\quad f_r = V^T f\\]\nFor our affine case: - \\(A_r^1 = V^T K_\\lambda V\\) (reduced volumetric stiffness) - \\(A_r^2 = V^T K_\\mu V\\) (reduced deviatoric stiffness) - \\(f_r = V^T f\\) (reduced load vector)\nThese are small \\(r \\times r\\) matrices instead of \\(N \\times N\\) matrices, enabling rapid online assembly.\n\n\n\n\n\nOnce the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods\n\n\n\n\nIt’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction\n\n\n\n\n\n\nThe choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used."
  },
  {
    "objectID": "reference/problem_structure.html#what-is-reduced-order-modeling",
    "href": "reference/problem_structure.html#what-is-reduced-order-modeling",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples"
  },
  {
    "objectID": "reference/problem_structure.html#prerequisites",
    "href": "reference/problem_structure.html#prerequisites",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "First, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible."
  },
  {
    "objectID": "reference/problem_structure.html#geometry-finite-element-setup-domain.py",
    "href": "reference/problem_structure.html#geometry-finite-element-setup-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable."
  },
  {
    "objectID": "reference/problem_structure.html#constitutive-law-material-properties-properties.py",
    "href": "reference/problem_structure.html#constitutive-law-material-properties-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement"
  },
  {
    "objectID": "reference/problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "href": "reference/problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase."
  },
  {
    "objectID": "reference/problem_structure.html#right-hand-side-linear_forms.py",
    "href": "reference/problem_structure.html#right-hand-side-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads"
  },
  {
    "objectID": "reference/problem_structure.html#parameter-sampling-params.py",
    "href": "reference/problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "For ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.\nfrom src.skrom.rom.rom_utils import generate_sobol\n\ndef parameters(N_snap=32):\n    # Sobol over (E, nu) in [100, 200] × [0.25, 0.35]\n    return generate_sobol([[100.,200.],[0.25,0.35]], 2*N_snap)\nDetailed Explanation:\n\nSobol Sequences: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.\nParameter Ranges:\n\nYoung’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)\nPoisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)\n\nSample Size: 2*N_snap samples are generated so they can be split into training and testing sets.\n\nUsage Pattern:\nE_nu_train, E_nu_test = np.split(parameters(32), 2)\nThis gives you 32 training samples and 32 testing samples for validation.\nWhy Good Sampling Matters: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others."
  },
  {
    "objectID": "reference/problem_structure.html#orchestrating-everything-problem_def.py",
    "href": "reference/problem_structure.html#orchestrating-everything-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\n\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations."
  },
  {
    "objectID": "reference/problem_structure.html#offline-workflow-building-the-rom",
    "href": "reference/problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.\nfrom src.skrom.problem_classes import new_problem\n\nprob = new_problem(\"problem_1\")\n\n# 1) draw parameter samples\ntheta_train = prob.parameters(n_samples=64)\n\n# 2) build snapshots\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\n\n# 3) compute POD basis\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\n\n# 4) assemble reduced operators\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nDetailed Step-by-Step Explanation:\n\n\ntheta_train = prob.parameters(n_samples=64)\nThis generates 64 parameter combinations \\((E_i, \\nu_i)\\) using the Sobol sequence. These parameters should span the expected range of operating conditions.\n\n\n\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\nFor each parameter combination, the full finite element problem is solved: \\[K(\\theta_i) u_i = f\\]\nThe resulting displacement vectors \\(u_i\\) are called “snapshots” and are stored as columns in matrix \\(U\\). If you have \\(N\\) degrees of freedom and \\(n_{snap}\\) parameter samples, then \\(U \\in \\mathbb{R}^{N \\times n_{snap}}\\).\n\n\n\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\nPOD performs Singular Value Decomposition on the snapshot matrix: \\[U = V \\Sigma W^T\\]\nThe columns of \\(V\\) are the POD modes, ordered by importance (largest singular values first). We keep only the first \\(r=50\\) modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.\nKey Insight: The POD basis \\(V\\) captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.\n\n\n\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nThe full-order operators are projected onto the reduced space: \\[A_r^q = V^T A^q V, \\quad f_r = V^T f\\]\nFor our affine case: - \\(A_r^1 = V^T K_\\lambda V\\) (reduced volumetric stiffness) - \\(A_r^2 = V^T K_\\mu V\\) (reduced deviatoric stiffness) - \\(f_r = V^T f\\) (reduced load vector)\nThese are small \\(r \\times r\\) matrices instead of \\(N \\times N\\) matrices, enabling rapid online assembly."
  },
  {
    "objectID": "reference/problem_structure.html#online-solve-real-time-evaluation",
    "href": "reference/problem_structure.html#online-solve-real-time-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Once the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods"
  },
  {
    "objectID": "reference/problem_structure.html#validation-ensuring-rom-quality",
    "href": "reference/problem_structure.html#validation-ensuring-rom-quality",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "It’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction"
  },
  {
    "objectID": "reference/problem_structure.html#advanced-topics",
    "href": "reference/problem_structure.html#advanced-topics",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used."
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html",
    "href": "reference/problem_classes.master_class_static.html",
    "title": "problem_classes.master_class_static",
    "section": "",
    "text": "problem_classes.master_class_static\nModule for static reduced-order modeling (ROM):"
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#classes",
    "href": "reference/problem_classes.master_class_static.html#classes",
    "title": "problem_classes.master_class_static",
    "section": "Classes",
    "text": "Classes\n\n\n\nName\nDescription\n\n\n\n\nProblem\nAbstract base for conductivity problems under affine decomposition.\n\n\nfom_simulation\nOffline snapshot generator using full-order FEM.\n\n\nrom_simulation\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\nProblem\nproblem_classes.master_class_static.Problem()\nAbstract base for conductivity problems under affine decomposition.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn affine bilinear form components.\n\n\ndomain\nReturn geometry and FEM bases.\n\n\nfom_solver\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn affine linear form components.\n\n\nparameters\nGenerate sampling of parameter space.\n\n\nproperties\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nSolve reduced-order model for given parameters.\n\n\n\n\nbilinear_forms\nproblem_classes.master_class_static.Problem.bilinear_forms()\nReturn affine bilinear form components.\n\n\ndomain\nproblem_classes.master_class_static.Problem.domain()\nReturn geometry and FEM bases.\n\n\nfom_solver\nproblem_classes.master_class_static.Problem.fom_solver()\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nproblem_classes.master_class_static.Problem.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nproblem_classes.master_class_static.Problem.linear_forms()\nReturn affine linear form components.\n\n\nparameters\nproblem_classes.master_class_static.Problem.parameters()\nGenerate sampling of parameter space.\n\n\nproperties\nproblem_classes.master_class_static.Problem.properties()\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nproblem_classes.master_class_static.Problem.rom_solver()\nSolve reduced-order model for given parameters.\n\n\n\n\nfom_simulation\nproblem_classes.master_class_static.fom_simulation(num_snapshots=32)\nOffline snapshot generator using full-order FEM.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nrun_simulation\nGenerate snapshots and record timings.\n\n\n\n\nrun_simulation\nproblem_classes.master_class_static.fom_simulation.run_simulation()\nGenerate snapshots and record timings.\n\n\n\n\nrom_simulation\nproblem_classes.master_class_static.rom_simulation(\n    mean=None,\n    fos_solutions=None,\n    train_mask=None,\n    test_mask=None,\n    V_sel=None,\n    n_sel=None,\n    N_rom_snap=None,\n)\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nrun_hyper_rom_simulation\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\nrun_rom_simulation\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\nrun_hyper_rom_simulation\nproblem_classes.master_class_static.rom_simulation.run_hyper_rom_simulation(z)\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\narray_like\nWeight vector for hyper-reduction (stored for reference).\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nhyper_rom_error\nlist of float\nPercent error per snapshot.\n\n\nhyper_speed_up\nlist of float\nFull/FOM time ratio per snapshot.\n\n\n\n\n\n\nrun_rom_simulation\nproblem_classes.master_class_static.rom_simulation.run_rom_simulation()\nExecute ROM solves, compute error percentages and speed-ups.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nrom_error\nlist of float\nPercent error per snapshot.\n\n\nspeed_up\nlist of float\nFull/ROM time ratio per snapshot."
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#functions",
    "href": "reference/problem_classes.master_class_static.html#functions",
    "title": "problem_classes.master_class_static",
    "section": "Functions",
    "text": "Functions\n\n\n\nName\nDescription\n\n\n\n\nget_problem\nInstantiate a registered problem by name.\n\n\nregister_problem\nDecorator to register a problem class under a given name.\n\n\n\n\nget_problem\nproblem_classes.master_class_static.get_problem(name)\nInstantiate a registered problem by name.\n\n\nregister_problem\nproblem_classes.master_class_static.register_problem(name)\nDecorator to register a problem class under a given name."
  },
  {
    "objectID": "reference/hyperreduction.html",
    "href": "reference/hyperreduction.html",
    "title": "hyperreduction",
    "section": "",
    "text": "hyperreduction\nhyperreduction\nThe hyperreduce package provides tools to perform hyper‐reduction on full‐order models.\nContents: - bilinear_form_hyperrom.py & linear_form_hyperrom.py: Classes that cluster elements by free‐DOF counts, project local stiffness/load contributions onto reduced bases, and assemble global reduced matrices/vectors. - hyperreduce.py: End‐to‐end pipeline combining randomized SVD preprocessing with bounded NNLS solves for weight selection, plus plotting diagnostics. - custom_nnls.py: Wrapped NNLS solver specialized for hyper‐reduction constraints.\nThese modules streamline the construction of sparse, hyper‐reduced operators and right‐hand sides for fast, accurate reduced‐order simulations."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.html",
    "href": "reference/hyperreduction.ecsw.html",
    "title": "hyperreduction.ecsw",
    "section": "",
    "text": "hyperreduction.ecsw\nhyperreduction.ecsw"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "hyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/fom.html",
    "href": "reference/fom.html",
    "title": "fom",
    "section": "",
    "text": "fom"
  },
  {
    "objectID": "reference/fom.html#fem_utils.py",
    "href": "reference/fom.html#fem_utils.py",
    "title": "fom",
    "section": "fem_utils.py",
    "text": "fem_utils.py\nFinite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "problem_structure.html",
    "href": "problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Video\nLinear Elasticity\nThis comprehensive tutorial demonstrates the complete process of developing a reduced-order model (ROM) for a three-dimensional linear elastic structure using scikit-rom. You’ll learn how each component operates, understand the interconnections between files, and discover how to build an affine ROM that enables real-time or near-real-time simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-description",
    "href": "problem_structure.html#problem-description",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Problem Description",
    "text": "Problem Description\nWe analyze a 3D block governed by linear elasticity principles. The structure features two distinct material regions with different stiffness properties, enabling demonstration of spatially varying material handling through affine decomposition. Core characteristics include:\nLinear Affine Elasticity: The stiffness matrix is constructed as a linear combination of blocks that are affine in the Lamé parameters \\((\\lambda, \\mu)\\).\nDomain Partitioning: The block is divided into two regions with distinct elastic properties.\nParameter Space: Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) are sampled for both offline and online ROM phases.\nBoundary Conditions: Dirichlet constraints (fixed displacement) on one face; Neumann conditions (applied traction) on the opposing face.\nLink\n Video tutorial",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#project-architecture",
    "href": "problem_structure.html#project-architecture",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Project Architecture",
    "text": "Project Architecture\nThe simulation workflow is organized through the following directory structure and files:\nproblem_1/\n├─ domain.py           # Mesh generation, basis setup, boundary and region partitioning\n├─ bilinear_forms.py   # Affine weak form (stiffness) assembly\n├─ linear_forms.py     # Load (traction) right-hand side term\n├─ properties.py       # Lamé parameter computation per region\n├─ params.py           # Sampling (E, ν) for training and testing\n└─ problem_def.py      # Main orchestration: assembles all components for scikit-rom\n└─ problem_1.ipynb     # Executes the complete workflow starting from data generation to model reduction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "href": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "1. Geometry & Finite Element Framework — domain.py",
    "text": "1. Geometry & Finite Element Framework — domain.py\nMesh Construction: The domain represents a 3D block discretized with hexahedral elements, parameterized by dimensions \\((l_x, l_y, l_z)\\) and mesh refinement factor for resolution control.\nBasis Functions: Employs vector-valued trilinear hexahedral elements to represent 3D displacement fields.\nBoundary Identification:\n\n'left': Dirichlet (fixed displacement)\n'right': Neumann (applied load)\n\nRegion Partitioning: The mesh is divided along the \\(x\\)-axis at the midpoint into:\n\nregion_1: \\(x \\leq 0.5 \\cdot l_x\\) (stiffer region)\nregion_2: \\(x &gt; 0.5 \\cdot l_x\\) (softer region)\n\nThe module returns a comprehensive dictionary containing the mesh, bases, boundary DOFs, and a per-region basis dictionary for subsequent operator assembly.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "href": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "2. Material Properties & Affine Coefficient Functions — properties.py",
    "text": "2. Material Properties & Affine Coefficient Functions — properties.py\nLamé Parameters: Transforms Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) into Lamé parameters \\((\\lambda, \\mu)\\) using skfem utilities.\nRegion Handling:\n\nFor region_1, both \\(\\lambda\\) and \\(\\mu\\) are scaled by \\(50\\times\\) (stiffer inclusion)\nFor region_2, properties remain unchanged (baseline material)",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "href": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py",
    "text": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py\nAffine Bilinear Forms:\n\nstiffness_lam: Weak form for the \\(\\lambda\\) (volumetric) component\nstiffness_mu: Weak form for the \\(\\mu\\) (shear) component\n\nMathematics: Each block is computed per-region (using basis restriction). The global stiffness matrix is expressed as:\n\\(K(E,\\nu) = \\sum_{\\text{regions}} \\lambda \\cdot K_{\\lambda,\\text{region}} + \\mu \\cdot K_{\\mu,\\text{region}}\\)\nParameter-Dependent Evaluation: Lamé parameters are computed as needed for each region via the region-aware property function.\nThis approach ensures the assembly aligns with the affine decomposition essential for efficient ROM evaluation.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "href": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "4. Right-Hand Side (Loads) — linear_forms.py",
    "text": "4. Right-Hand Side (Loads) — linear_forms.py\nNeumann Traction: Implements a constant traction (-1e-2) in the global \\(y\\)-direction applied to the ‘right’ face.\nAffine in Parameters: The load vector is parameter-independent and only needs to be assembled once for the entire ROM process.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#parameter-sampling-params.py",
    "href": "problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "5. Parameter Sampling — params.py",
    "text": "5. Parameter Sampling — params.py\nParameter Ranges:\n\n\\(E\\): [2.0, 10.0]\n\\(\\nu\\): [0.2, 0.4]\n\nSampling Strategy: Uses Sobol sequences to create quasi-random sets of \\((E,\\nu)\\) pairs for:\n\nTraining snapshots (for ROM basis construction)\nTesting snapshots (for validation)\n\nMasks Provided: Returns boolean arrays to cleanly separate training vs testing data.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-orchestration-problem_def.py",
    "href": "problem_structure.html#problem-orchestration-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "6. Problem Orchestration — problem_def.py",
    "text": "6. Problem Orchestration — problem_def.py\nMaster Problem Class: Inherits from the scikit-rom base and registers essential routines:\n\ndomain(): Loads mesh and DOFs from domain.py\nbilinear_forms(): Returns affine weak forms for \\(\\lambda\\) and \\(\\mu\\)\nlinear_forms(): Returns the Neumann loading routine\nproperties(): Returns the regionwise Lamé parameter mapper\nparameters(n_samples): Returns parameter sets and train/test split\n\nAffine Operator Assembly: On the first solve, stiffness and load “blocks” are assembled separately for each region/material.\nFull-Order Solve: Assembles and solves the condensed system with Dirichlet BCs for each parameter instance.\nROM Projection: Projects global blocks onto the reduced basis, incorporating an offline mean-shift to keep the ROM centered.\nThis design ensures a clear separation between model definition (problem file) and algorithmic ROM machinery (provided by scikit-rom).",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#offline-workflow-building-the-rom",
    "href": "problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "7. Offline Workflow: Building the ROM",
    "text": "7. Offline Workflow: Building the ROM\nStep-by-step process:\n\nParameter Sampling: Generate \\(n\\) training samples \\((E_i, \\nu_i)\\) using the routine from params.py.\nFull-Order Simulations: For each parameter, solve the full high-fidelity FEM system and store the solution as a snapshot.\nData Processing:\n\nMean Subtraction: Subtract the mean from all snapshots to center the dataset\nSVD/POD: Perform singular value decomposition on the mean-subtracted snapshots to find the dominant modes (energy-ranked spatial patterns)\nMode Truncation: Retain only the leading \\(r\\) modes (user- or error-determined) for reduced basis\n\nReduced Operator Assembly: Project per-region blocks \\((K_{\\lambda,\\text{region}}, K_{\\mu,\\text{region}})\\) into the reduced space, yielding ultra-compact operators.\n\nThe reduced model is now ready for very rapid online predictions.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#online-workflow-fast-evaluation",
    "href": "problem_structure.html#online-workflow-fast-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "8. Online Workflow: Fast Evaluation",
    "text": "8. Online Workflow: Fast Evaluation\nFor a new parameter set \\((E, \\nu)\\):\n\nCompute Per-Region Lamé Parameters: Map input parameters to \\((\\lambda, \\mu)\\) values for each region.\nAssemble Reduced Stiffness: Combine precomputed regionwise blocks using affine expressions.\nSolve Reduced System: The resulting linear system has size equal to the number of modes \\((r \\ll N)\\), making it extremely fast.\nMean Recovery: Add back the mean field to produce the full-field displacement solution, ready for visualization or further analysis.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#validation-error-assessment",
    "href": "problem_structure.html#validation-error-assessment",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "9. Validation & Error Assessment",
    "text": "9. Validation & Error Assessment\nTest Set: Evaluate the ROM on held-out (never-seen) parameter pairs.\nError Metrics:\n\nRelative error (L2 or energy norm) between ROM and high-fidelity FOM solutions\nStatistical fit metrics (e.g., R² score)\n\nSpeed-up Factor: The ROM typically achieves significant speed-up (often orders of magnitude) versus direct FEM.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#summary-table-of-key-methods",
    "href": "problem_structure.html#summary-table-of-key-methods",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "10. Summary Table of Key Methods",
    "text": "10. Summary Table of Key Methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nTypical Location in Pipeline\n\n\n\n\ndomain()\nSetup mesh, BCs, DOFs, and per-region bases\nFirst, before assembly\n\n\nbilinear_forms()\nReturn affine form handles for λ, μ\nOperator initialization\n\n\nlinear_forms()\nSpecify right-hand-side (load)\nOperator assembly\n\n\nproperties()\nMap (E, ν, region) → (λ, μ)\nParameter unpacking\n\n\nparameters()\nProduce sampled (E, ν) + train/test masks\nOffline/online split\n\n\nfom_solver()\nRun and store full-order solutions\nSnapshot generation (offline)\n\n\nrom_solver()\nAssemble and solve projected ROM system\nRapid online prediction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#best-practices",
    "href": "problem_structure.html#best-practices",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "11. Best Practices",
    "text": "11. Best Practices\n\nAlways center your snapshot data before SVD to ensure best POD convergence\nUse enough training samples (and parameter space coverage) to avoid overfitting or “holes” in ROM accuracy\nCheck ROM error on multiple, unseen test samples\nVisualize spatial error fields—not just scalar error metrics—for insight into local ROM limitations\nLeverage the modular file structure for extending to other domains, BCs, and PDEs\n\nThis workflow and modular codebase provide a flexible, scalable foundation for reduced-order modeling of parametrized PDEs in computational mechanics, accelerating simulation, optimization, and interactive design.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "nonlinear_power_law.html#problem-setup",
    "href": "nonlinear_power_law.html#problem-setup",
    "title": "P.1 Nonlinear power-law (strain-hardening) bar under gravity and line load",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.1 Nonlinear power-law (strain-hardening) bar under gravity and line load"
    ]
  },
  {
    "objectID": "linear bending.html#problem-setup",
    "href": "linear bending.html#problem-setup",
    "title": "P.3 Heterogeneous linear elasticity in a two-material 3D block",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink\nSee detailed tutorial for this problem",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.3 Heterogeneous linear elasticity in a two-material 3D block"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to skrom",
    "section": "",
    "text": "scikit-rom is a lightweight, Python-based platform designed for projection-based model reduction of finite element models with moderate to large problem sizes (up to approximately 600,000 degrees of freedom). Built on top of scikit-fem, an easy-to-use finite element assembly library, this repository demonstrates reduced-order modeling (ROM) techniques for a range of linear and nonlinear problems, including time-dependent ones. Current examples primarily focus on thermal and mechanical systems, with extensions to fluid dynamics planned for future releases.\nBeyond its application to real-world finite element problems, the library also serves as a valuable testing ground for new model reduction algorithms and as a tutorial resource for those new to the field."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Welcome to skrom",
    "section": "Installation",
    "text": "Installation\n\n\nThis tutorial explains how to install SKROM (scikit-ROM):\nInstallation Steps:\n\nClone the repository:\n\ngit clone https://github.com/suparnob100/scikit-rom\ncd scikit-rom\n\nInstall with pip:\n\n\nFor developers (editable install):\n\npip install -e .\n\nFor regular users:\n\npip install .\n(Use pip3 instead of pip on Mac)\nNotes:\n\nUse -e for development; it lets you edit the code without reinstalling.\nRegular users should use standard installation.\nReinstallation automatically removes the old version.\nThe installation completes in seconds and shows “successfully built SKROM.”\nAll instructions are available on the GitHub page."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Welcome to skrom",
    "section": "Getting Started",
    "text": "Getting Started"
  },
  {
    "objectID": "index.html#recommended-reading",
    "href": "index.html#recommended-reading",
    "title": "Welcome to skrom",
    "section": "Recommended Reading",
    "text": "Recommended Reading\nTo dive deeper, check out:\n\nHyper-reduction Techniques for Efficient Simulation"
  },
  {
    "objectID": "linear star.html#problem-setup",
    "href": "linear star.html#problem-setup",
    "title": "P.4 Linear heat conduction with non-affine parametric source on a star-shaped plate",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Heat Transfer",
      "P.4 Linear heat conduction with non-affine parametric source on a star-shaped plate"
    ]
  },
  {
    "objectID": "non_linear.html#problem-setup",
    "href": "non_linear.html#problem-setup",
    "title": "P.5 Nonlinear heat conduction in a two-material 1-D rod",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Heat Transfer",
      "P.5 Nonlinear heat conduction in a two-material 1-D rod"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html",
    "href": "reference/fom.fem_utils.html",
    "title": "fom.fem_utils",
    "section": "",
    "text": "fom.fem_utils\nFinite element utilities for preconditioning, mesh operations, and nonlinear solving.\nThis module includes:\n\nbuild_pc_amgsa: construct AMG smoothed aggregation preconditioner.\nelement2location: generate element-to-coordinate mappings from mesh data.\nnewton_solver and its helpers: perform Newton–Raphson solves with or without Dirichlet BC.\ncompute_basis_regions: create reduced bases for mesh regions.\nload_domain, load_mesh_and_basis: domain/mesh loading utilities.\nunwrap_attr: attribute unwrapping helper.\n\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nCreate reduced basis functions for specified mesh regions.\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_domain\nLoad domain information and assign attributes to instance.\n\n\nload_mesh_and_basis\nLoad only mesh and basis from domain and assign to instance.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method.\n\n\nunwrap_attr\nUnwrap 0-dimensional object arrays to their scalar values.\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\nTL;DR: Creates an AMG preconditioner from a system matrix for efficient iterative solving of large sparse linear systems.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers like conjugate gradient.\n\n\n\n\n\n\n&gt;&gt;&gt; import scipy.sparse as sp\n&gt;&gt;&gt; A = sp.diags([1, -2, 1], [-1, 0, 1], shape=(100, 100))\n&gt;&gt;&gt; M = build_pc_amgsa(A)\n&gt;&gt;&gt; # Use M as preconditioner in iterative solver\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nCreate reduced basis functions for specified mesh regions.\nTL;DR: Given boolean masks defining mesh regions, returns basis functions restricted to each region for efficient regional computations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nobject\nFinite element basis object with nelems attribute and with_elements method.\nrequired\n\n\nmasks\ndict of str to ndarray of bool\nDictionary mapping region names to boolean element masks of shape (basis.nelems,). True values indicate elements belonging to the region.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nregion_bases\ndict of str to object\nDictionary mapping region names to reduced basis objects containing only elements specified by the corresponding mask.\n\n\n\n\n\n\n&gt;&gt;&gt; masks = {'left': np.array([True, False, True]), \n...          'right': np.array([False, True, False])}\n&gt;&gt;&gt; region_bases = compute_basis_regions(basis, masks)\n&gt;&gt;&gt; # region_bases['left'] contains basis for left region elements\n\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\nTL;DR: Extracts element-wise coordinate information from mesh connectivity, useful for element-based computations in finite element methods.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity). Expected to have p as shape (spatial_dim, n_nodes) and t as shape (n_local_nodes_per_element, n_elements).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element. For 1D meshes, this gives coordinates of element endpoints.\n\n\n\n\n\n\n&gt;&gt;&gt; # For a 1D mesh with 3 elements and 4 nodes\n&gt;&gt;&gt; element_coords = element2location(mesh)\n&gt;&gt;&gt; # element_coords[0] gives coordinates of first element's nodes\n\n\n\n\nfom.fem_utils.load_domain(instance)\nLoad domain information and assign attributes to instance.\nTL;DR: Calls instance.domain() and assigns all returned attributes to the instance object for convenient access.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method that returns a dictionary of domain attributes.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting attributes based on the domain dictionary keys and values.\n\n\n\n&gt;&gt;&gt; load_domain(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh, problem_instance.basis, etc. are available\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nLoad only mesh and basis from domain and assign to instance.\nTL;DR: Extracts just mesh and basis from instance.domain() for cases where only these two components are needed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method returning a dictionary containing at least ‘mesh’ and ‘basis’ keys.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting only mesh and basis attributes, ignoring other domain components.\n\n\n\n&gt;&gt;&gt; load_mesh_and_basis(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh and problem_instance.basis are available\n\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method.\nTL;DR: Newton solver with optional Dirichlet boundary conditions that iteratively solves F(u) = 0 by computing Jacobian and RHS at each iteration.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the Jacobian matrix. Should accept (u, *assemble_args) and return the Jacobian matrix J where J[i,j] = ∂F_i/∂u_j.\nrequired\n\n\nrhs_fn\ncallable\nFunction that assembles the RHS vector. Should accept (u, *assemble_args) and return the residual vector F(u).\nrequired\n\n\nu0\nndarray of shape (n_dofs,)\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nPrescribed values at the Dirichlet DOFs. Must have same length as dirichlet_dofs.\nNone\n\n\n*assemble_args\ntuple\nAdditional positional arguments passed to assemble_fn and rhs_fn.\n()\n\n\ntol\nfloat\nConvergence tolerance based on the L2 norm of the solution update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations before giving up.\n50\n\n\nalpha\nfloat\nStep length parameter for solution updates.\n1.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray of shape (n_dofs,)\nApproximate solution vector after convergence or maximum iterations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations and no Dirichlet boundary conditions are specified.\n\n\n\n\n\n\nThe Newton method solves F(u) = 0 by iterating u_{k+1} = u_k - α * J_k^{-1} * F(u_k), where J_k is the Jacobian at u_k. For problems with Dirichlet BC, the system is condensed to solve only for free DOFs.\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nUnwrap 0-dimensional object arrays to their scalar values.\nTL;DR: Converts 0-d numpy object arrays to their contained scalar value using .item(), useful for cleaning up attributes after certain operations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject containing the attribute to unwrap.\nrequired\n\n\nattr_name\nstr\nName of the attribute to unwrap.\nrequired\n\n\n\n\n\n\nOnly applies unwrapping if the attribute is a 0-dimensional numpy array with object dtype. The instance is modified in-place.\n\n\n\n&gt;&gt;&gt; # If instance.result is np.array(42, dtype=object)\n&gt;&gt;&gt; unwrap_attr(instance, 'result')\n&gt;&gt;&gt; # Now instance.result is 42 (scalar int)",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html#functions",
    "href": "reference/fom.fem_utils.html#functions",
    "title": "fom.fem_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nCreate reduced basis functions for specified mesh regions.\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_domain\nLoad domain information and assign attributes to instance.\n\n\nload_mesh_and_basis\nLoad only mesh and basis from domain and assign to instance.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method.\n\n\nunwrap_attr\nUnwrap 0-dimensional object arrays to their scalar values.\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\nTL;DR: Creates an AMG preconditioner from a system matrix for efficient iterative solving of large sparse linear systems.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers like conjugate gradient.\n\n\n\n\n\n\n&gt;&gt;&gt; import scipy.sparse as sp\n&gt;&gt;&gt; A = sp.diags([1, -2, 1], [-1, 0, 1], shape=(100, 100))\n&gt;&gt;&gt; M = build_pc_amgsa(A)\n&gt;&gt;&gt; # Use M as preconditioner in iterative solver\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nCreate reduced basis functions for specified mesh regions.\nTL;DR: Given boolean masks defining mesh regions, returns basis functions restricted to each region for efficient regional computations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nobject\nFinite element basis object with nelems attribute and with_elements method.\nrequired\n\n\nmasks\ndict of str to ndarray of bool\nDictionary mapping region names to boolean element masks of shape (basis.nelems,). True values indicate elements belonging to the region.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nregion_bases\ndict of str to object\nDictionary mapping region names to reduced basis objects containing only elements specified by the corresponding mask.\n\n\n\n\n\n\n&gt;&gt;&gt; masks = {'left': np.array([True, False, True]), \n...          'right': np.array([False, True, False])}\n&gt;&gt;&gt; region_bases = compute_basis_regions(basis, masks)\n&gt;&gt;&gt; # region_bases['left'] contains basis for left region elements\n\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\nTL;DR: Extracts element-wise coordinate information from mesh connectivity, useful for element-based computations in finite element methods.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity). Expected to have p as shape (spatial_dim, n_nodes) and t as shape (n_local_nodes_per_element, n_elements).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element. For 1D meshes, this gives coordinates of element endpoints.\n\n\n\n\n\n\n&gt;&gt;&gt; # For a 1D mesh with 3 elements and 4 nodes\n&gt;&gt;&gt; element_coords = element2location(mesh)\n&gt;&gt;&gt; # element_coords[0] gives coordinates of first element's nodes\n\n\n\n\nfom.fem_utils.load_domain(instance)\nLoad domain information and assign attributes to instance.\nTL;DR: Calls instance.domain() and assigns all returned attributes to the instance object for convenient access.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method that returns a dictionary of domain attributes.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting attributes based on the domain dictionary keys and values.\n\n\n\n&gt;&gt;&gt; load_domain(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh, problem_instance.basis, etc. are available\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nLoad only mesh and basis from domain and assign to instance.\nTL;DR: Extracts just mesh and basis from instance.domain() for cases where only these two components are needed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method returning a dictionary containing at least ‘mesh’ and ‘basis’ keys.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting only mesh and basis attributes, ignoring other domain components.\n\n\n\n&gt;&gt;&gt; load_mesh_and_basis(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh and problem_instance.basis are available\n\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method.\nTL;DR: Newton solver with optional Dirichlet boundary conditions that iteratively solves F(u) = 0 by computing Jacobian and RHS at each iteration.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the Jacobian matrix. Should accept (u, *assemble_args) and return the Jacobian matrix J where J[i,j] = ∂F_i/∂u_j.\nrequired\n\n\nrhs_fn\ncallable\nFunction that assembles the RHS vector. Should accept (u, *assemble_args) and return the residual vector F(u).\nrequired\n\n\nu0\nndarray of shape (n_dofs,)\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nPrescribed values at the Dirichlet DOFs. Must have same length as dirichlet_dofs.\nNone\n\n\n*assemble_args\ntuple\nAdditional positional arguments passed to assemble_fn and rhs_fn.\n()\n\n\ntol\nfloat\nConvergence tolerance based on the L2 norm of the solution update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations before giving up.\n50\n\n\nalpha\nfloat\nStep length parameter for solution updates.\n1.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray of shape (n_dofs,)\nApproximate solution vector after convergence or maximum iterations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations and no Dirichlet boundary conditions are specified.\n\n\n\n\n\n\nThe Newton method solves F(u) = 0 by iterating u_{k+1} = u_k - α * J_k^{-1} * F(u_k), where J_k is the Jacobian at u_k. For problems with Dirichlet BC, the system is condensed to solve only for free DOFs.\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nUnwrap 0-dimensional object arrays to their scalar values.\nTL;DR: Converts 0-d numpy object arrays to their contained scalar value using .item(), useful for cleaning up attributes after certain operations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject containing the attribute to unwrap.\nrequired\n\n\nattr_name\nstr\nName of the attribute to unwrap.\nrequired\n\n\n\n\n\n\nOnly applies unwrapping if the attribute is a 0-dimensional numpy array with object dtype. The instance is modified in-place.\n\n\n\n&gt;&gt;&gt; # If instance.result is np.array(42, dtype=object)\n&gt;&gt;&gt; unwrap_attr(instance, 'result')\n&gt;&gt;&gt; # Now instance.result is 42 (scalar int)",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.bilinear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly"
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "hyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html",
    "href": "reference/hyperreduction.linear_form_hyperrom.html",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.linear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "fom.fem_utils\nFinite element utilities for preconditioning, mesh operations, and nonlinear solving.\n\n\n\n\n\n\n\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,\n\n\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element bilinear forms.\n\n\nrom.deim.linear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element linear forms.\n\n\nrom.deim.deim\nDiscrete Empirical Interpolation Method (DEIM) for nonlinear ROM acceleration.\n\n\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw\nECSW-based hyperreduction for finite element bilinear forms with element clustering.\n\n\nrom.ecsw.linear_form_hyperrom_ecsw\n\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\n\n\n\n\n\n\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.reduced_basis.svd\n\n\n\n\n\n\n\n\n\n\nutils.dynamics.integrators\n\n\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette\n\n\n\nutils.visualization.plot_utils\n\n\n\n\n\n\n\n\n\n\ntemplates.problem_template.bilinear_forms\n\n\n\ntemplates.problem_template.linear_forms\n\n\n\ntemplates.problem_template.params\n\n\n\ntemplates.problem_template.domain\n\n\n\ntemplates.problem_template.problem_def\n\n\n\ntemplates.problem_template.properties",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#full-order-model-fom",
    "href": "reference/index.html#full-order-model-fom",
    "title": "Function reference",
    "section": "",
    "text": "fom.fem_utils\nFinite element utilities for preconditioning, mesh operations, and nonlinear solving.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reduced-order-model-rom",
    "href": "reference/index.html#reduced-order-model-rom",
    "title": "Function reference",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#deim-hyper-reduction",
    "href": "reference/index.html#deim-hyper-reduction",
    "title": "Function reference",
    "section": "",
    "text": "rom.deim.bilinear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element bilinear forms.\n\n\nrom.deim.linear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element linear forms.\n\n\nrom.deim.deim\nDiscrete Empirical Interpolation Method (DEIM) for nonlinear ROM acceleration.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ecsw-hyper-reduction",
    "href": "reference/index.html#ecsw-hyper-reduction",
    "title": "Function reference",
    "section": "",
    "text": "rom.ecsw.bilinear_form_hyperrom_ecsw\nECSW-based hyperreduction for finite element bilinear forms with element clustering.\n\n\nrom.ecsw.linear_form_hyperrom_ecsw\n\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Function reference",
    "section": "",
    "text": "utils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.reduced_basis.svd",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#dynamics",
    "href": "reference/index.html#dynamics",
    "title": "Function reference",
    "section": "",
    "text": "utils.dynamics.integrators",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#visualization",
    "href": "reference/index.html#visualization",
    "title": "Function reference",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette\n\n\n\nutils.visualization.plot_utils",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#templates",
    "href": "reference/index.html#templates",
    "title": "Function reference",
    "section": "",
    "text": "templates.problem_template.bilinear_forms\n\n\n\ntemplates.problem_template.linear_forms\n\n\n\ntemplates.problem_template.params\n\n\n\ntemplates.problem_template.domain\n\n\n\ntemplates.problem_template.problem_def\n\n\n\ntemplates.problem_template.properties",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/problem_classes.html",
    "href": "reference/problem_classes.html",
    "title": "problem_classes",
    "section": "",
    "text": "problem_classes"
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html",
    "href": "reference/rom.bilinear_form_rom.html",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\nThis module provides: - BilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including:\n\nClasses for projecting and assembling reduced-order bilinear and linear forms\nUtilities for handling Dirichlet boundary conditions in reduced spaces\nChunked and clustered assembly routines to manage large-scale stiffness/load data\nMapping utilities between full-order and reduced-order degrees of freedom\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html#classes",
    "href": "reference/rom.bilinear_form_rom.html#classes",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.deim.deim.html",
    "href": "reference/rom.deim.deim.html",
    "title": "rom.deim.deim",
    "section": "",
    "text": "rom.deim.deim\nDiscrete Empirical Interpolation Method (DEIM) for nonlinear ROM acceleration.\nThis module implements DEIM for reducing the dimension of nonlinear force terms in reduced-order models within finite element frameworks. DEIM enables efficient evaluation of nonlinear terms by:\n\nComputing empirical modes from nonlinear force snapshots via SVD\nSelecting optimal interpolation points using greedy algorithms\nConstructing projection matrices for fast nonlinear term approximation\nMapping selected DOFs to element indicators for efficient assembly\n\nTL;DR: Dramatically reduces computational cost of nonlinear ROM evaluation by approximating nonlinear terms using interpolation at carefully selected points, achieving significant speedups while maintaining accuracy.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\n\n\n\n\n\nrom.deim.deim.deim(mesh, F_nl, V_sel, tol_f=0.01, extra_modes=0)\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\nTL;DR: Reduces computational cost of nonlinear terms in ROMs by ~1000x through strategic sampling and interpolation, enabling real-time nonlinear PDE solutions.\nThe Discrete Empirical Interpolation Method (DEIM) addresses the computational bottleneck in nonlinear reduced-order models where nonlinear terms must still be evaluated at all degrees of freedom. DEIM constructs an efficient approximation by:\n\nEmpirical Mode Analysis: Computes dominant modes of nonlinear force snapshots using SVD to capture the essential nonlinear behavior patterns.\nOptimal Point Selection: Uses a greedy algorithm to select interpolation points that maximize information content while minimizing approximation error.\nProjection Matrix Construction: Builds a projection matrix that enables fast reconstruction of full nonlinear terms from interpolated values.\nElement Mapping: Maps selected degrees of freedom to finite element indicators for efficient sparse assembly operations.\n\nThe method transforms the nonlinear term evaluation from O(n) to O(m) where m &lt;&lt; n, achieving dramatic computational savings essential for real-time applications.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nFinite element mesh containing connectivity information and node data.\nrequired\n\n\nF_nl\nndarray of shape (n_dofs, n_snapshots)\nSnapshot matrix of nonlinear force evaluations at various parameter values. Each column represents the nonlinear force vector for one parameter instance.\nrequired\n\n\nV_sel\nndarray of shape (n_dofs, n_modes)\nReduced basis matrix from POD, used for solution space projection.\nrequired\n\n\ntol_f\nfloat\nTolerance for SVD mode selection based on singular value decay. Smaller values retain more modes for higher accuracy.\n1e-2\n\n\nextra_modes\nint\nAdditional empirical modes to retain beyond those selected by tolerance criterion, useful for capturing marginal nonlinear effects.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nU_fs\nndarray\nTruncated empirical basis matrix containing selected nonlinear modes.\n\n\ndeim_mat\nndarray\nDEIM projection matrix enabling fast nonlinear term reconstruction: F_nl_approx = V.T @ U_fs @ deim_mat @ F_nl_sampled\n\n\nxi\nndarray of int\nBinary element indicator vector marking which elements contain selected DOFs.\n\n\nn_f_sel\nint\nNumber of empirical modes selected for DEIM approximation.\n\n\n\n\n\n\nDEIM is particularly effective for: - Nonlinear PDEs with localized nonlinear effects - Real-time control applications requiring fast ROM evaluation\n- Problems where nonlinear term evaluation dominates computational cost - Systems with smooth nonlinear behavior amenable to low-rank approximation\nThe method assumes the nonlinear terms can be well-approximated by a low-rank representation, which is typically valid for many physical systems.\n\n\n\n.. [1] Chaturantabut, S. and Sorensen, D.C., 2010. Nonlinear model reduction via discrete empirical interpolation method. SIAM journal on scientific computing, 32(5), pp.2737-2764.\n\n\n\n&gt;&gt;&gt; # Generate nonlinear force snapshots\n&gt;&gt;&gt; F_snapshots = compute_nonlinear_snapshots(problem, param_list)\n&gt;&gt;&gt; # Create DEIM approximation\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, reduced_basis, tol_f=1e-3)\n&gt;&gt;&gt; deim_matrix, sample_points = deim_obj.select_elems()\n&gt;&gt;&gt; # Use in ROM: F_approx = V.T @ U @ deim_matrix @ F_sampled\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim_red\nExecute greedy DEIM algorithm for optimal interpolation point selection.\n\n\nselect_elems\nSelect interpolation points and construct DEIM projection matrix.\n\n\n\n\n\nrom.deim.deim.deim.deim_red(f_basis, num_f_basis_vectors_used)\nExecute greedy DEIM algorithm for optimal interpolation point selection.\nTL;DR: Implements the core greedy algorithm that iteratively selects interpolation points to minimize approximation error in the empirical subspace.\nThe DEIM greedy algorithm works by:\n\nInitial Selection: Chooses the DOF with maximum absolute value in the first empirical mode as the starting interpolation point.\nIterative Refinement: For each subsequent mode, solves for optimal interpolation coefficients using previously selected points, then selects the DOF with maximum residual as the next point.\nResidual Minimization: Each new point is chosen to minimize the approximation error when reconstructing the current empirical mode from previously selected points.\n\nThis greedy strategy ensures that interpolation points capture maximum information content while maintaining numerical stability through well-conditioned interpolation matrices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf_basis\nndarray of shape (n_dofs, n_modes)\nEmpirical basis matrix from SVD of nonlinear force snapshots. Each column represents one empirical mode.\nrequired\n\n\nnum_f_basis_vectors_used\nint\nNumber of empirical modes to use for interpolation point selection. Cannot exceed the total number of available modes.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_basis_sampled\nndarray of shape (num_modes, num_modes)\nSquare matrix containing rows of the empirical basis corresponding to selected interpolation points. Used to construct the projection matrix.\n\n\nsampled_rows\nlist of int\nOrdered list of DOF indices selected as interpolation points. The order reflects the greedy selection sequence.\n\n\n\n\n\n\nThe algorithm ensures that the interpolation matrix f_basis_sampled remains well-conditioned by construction, as each new point is chosen to maximize the residual norm.\nFor problems with strong locality in nonlinear effects, DEIM typically selects points near regions of highest nonlinear activity, leading to physically intuitive sampling patterns.\nThe computational complexity is O(m³) where m is the number of modes, making it efficient even for moderately large empirical subspaces.\n\n\n\n&gt;&gt;&gt; # Empirical basis from SVD  \n&gt;&gt;&gt; U, s, Vt = np.linalg.svd(F_snapshots, full_matrices=False)\n&gt;&gt;&gt; sampled_basis, indices = deim_obj.deim_red(U, n_modes=10)\n&gt;&gt;&gt; print(f\"Condition number: {np.linalg.cond(sampled_basis):.2e}\")\n\n\n\n\nrom.deim.deim.deim.select_elems()\nSelect interpolation points and construct DEIM projection matrix.\nTL;DR: Core DEIM algorithm that identifies optimal sampling points and builds the projection matrix for fast nonlinear term approximation.\nThis method performs the complete DEIM setup:\n\nSVD Analysis: Decomposes nonlinear snapshots to identify dominant empirical modes that capture essential nonlinear behavior patterns.\nMode Selection: Applies tolerance-based truncation with optional extra modes to balance accuracy and computational efficiency.\nPoint Selection: Uses greedy DEIM algorithm to select interpolation points that minimize approximation error in the empirical subspace.\nElement Mapping: Maps selected DOFs to finite element indicators for efficient sparse matrix assembly during online evaluation.\nProjection Construction: Builds the DEIM projection matrix that enables reconstruction: F_full ≈ U_fs @ pinv(U_fs[selected_rows, :]) @ F_sampled\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndeim_mat\nndarray of shape (n_modes, n_selected_points)\nDEIM projection matrix for reconstructing full nonlinear terms from sampled values. Used as: F_approx = V.T @ U_fs @ deim_mat @ F_sampled\n\n\nsampled_rows\nlist of int\nIndices of degrees of freedom selected as DEIM interpolation points. These are the only DOFs where nonlinear terms need evaluation.\n\n\n\n\n\n\nThe projection matrix construction uses the Moore-Penrose pseudoinverse to ensure numerical stability even when the empirical basis is not perfectly conditioned.\nThe element mapping (self.xi) enables efficient assembly by identifying which finite elements contribute to the selected DOFs, allowing sparse matrix operations during online evaluation.\n\n\n\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, basis_matrix)\n&gt;&gt;&gt; proj_matrix, points = deim_obj.select_elems()\n&gt;&gt;&gt; print(f\"Selected {len(points)} points from {F_snapshots.shape[0]} DOFs\")\n&gt;&gt;&gt; print(f\"Reduction ratio: {F_snapshots.shape[0]/len(points):.1f}x\")",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.deim.html#classes",
    "href": "reference/rom.deim.deim.html#classes",
    "title": "rom.deim.deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndeim\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\n\n\n\n\n\nrom.deim.deim.deim(mesh, F_nl, V_sel, tol_f=0.01, extra_modes=0)\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\nTL;DR: Reduces computational cost of nonlinear terms in ROMs by ~1000x through strategic sampling and interpolation, enabling real-time nonlinear PDE solutions.\nThe Discrete Empirical Interpolation Method (DEIM) addresses the computational bottleneck in nonlinear reduced-order models where nonlinear terms must still be evaluated at all degrees of freedom. DEIM constructs an efficient approximation by:\n\nEmpirical Mode Analysis: Computes dominant modes of nonlinear force snapshots using SVD to capture the essential nonlinear behavior patterns.\nOptimal Point Selection: Uses a greedy algorithm to select interpolation points that maximize information content while minimizing approximation error.\nProjection Matrix Construction: Builds a projection matrix that enables fast reconstruction of full nonlinear terms from interpolated values.\nElement Mapping: Maps selected degrees of freedom to finite element indicators for efficient sparse assembly operations.\n\nThe method transforms the nonlinear term evaluation from O(n) to O(m) where m &lt;&lt; n, achieving dramatic computational savings essential for real-time applications.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nFinite element mesh containing connectivity information and node data.\nrequired\n\n\nF_nl\nndarray of shape (n_dofs, n_snapshots)\nSnapshot matrix of nonlinear force evaluations at various parameter values. Each column represents the nonlinear force vector for one parameter instance.\nrequired\n\n\nV_sel\nndarray of shape (n_dofs, n_modes)\nReduced basis matrix from POD, used for solution space projection.\nrequired\n\n\ntol_f\nfloat\nTolerance for SVD mode selection based on singular value decay. Smaller values retain more modes for higher accuracy.\n1e-2\n\n\nextra_modes\nint\nAdditional empirical modes to retain beyond those selected by tolerance criterion, useful for capturing marginal nonlinear effects.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nU_fs\nndarray\nTruncated empirical basis matrix containing selected nonlinear modes.\n\n\ndeim_mat\nndarray\nDEIM projection matrix enabling fast nonlinear term reconstruction: F_nl_approx = V.T @ U_fs @ deim_mat @ F_nl_sampled\n\n\nxi\nndarray of int\nBinary element indicator vector marking which elements contain selected DOFs.\n\n\nn_f_sel\nint\nNumber of empirical modes selected for DEIM approximation.\n\n\n\n\n\n\nDEIM is particularly effective for: - Nonlinear PDEs with localized nonlinear effects - Real-time control applications requiring fast ROM evaluation\n- Problems where nonlinear term evaluation dominates computational cost - Systems with smooth nonlinear behavior amenable to low-rank approximation\nThe method assumes the nonlinear terms can be well-approximated by a low-rank representation, which is typically valid for many physical systems.\n\n\n\n.. [1] Chaturantabut, S. and Sorensen, D.C., 2010. Nonlinear model reduction via discrete empirical interpolation method. SIAM journal on scientific computing, 32(5), pp.2737-2764.\n\n\n\n&gt;&gt;&gt; # Generate nonlinear force snapshots\n&gt;&gt;&gt; F_snapshots = compute_nonlinear_snapshots(problem, param_list)\n&gt;&gt;&gt; # Create DEIM approximation\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, reduced_basis, tol_f=1e-3)\n&gt;&gt;&gt; deim_matrix, sample_points = deim_obj.select_elems()\n&gt;&gt;&gt; # Use in ROM: F_approx = V.T @ U @ deim_matrix @ F_sampled\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim_red\nExecute greedy DEIM algorithm for optimal interpolation point selection.\n\n\nselect_elems\nSelect interpolation points and construct DEIM projection matrix.\n\n\n\n\n\nrom.deim.deim.deim.deim_red(f_basis, num_f_basis_vectors_used)\nExecute greedy DEIM algorithm for optimal interpolation point selection.\nTL;DR: Implements the core greedy algorithm that iteratively selects interpolation points to minimize approximation error in the empirical subspace.\nThe DEIM greedy algorithm works by:\n\nInitial Selection: Chooses the DOF with maximum absolute value in the first empirical mode as the starting interpolation point.\nIterative Refinement: For each subsequent mode, solves for optimal interpolation coefficients using previously selected points, then selects the DOF with maximum residual as the next point.\nResidual Minimization: Each new point is chosen to minimize the approximation error when reconstructing the current empirical mode from previously selected points.\n\nThis greedy strategy ensures that interpolation points capture maximum information content while maintaining numerical stability through well-conditioned interpolation matrices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf_basis\nndarray of shape (n_dofs, n_modes)\nEmpirical basis matrix from SVD of nonlinear force snapshots. Each column represents one empirical mode.\nrequired\n\n\nnum_f_basis_vectors_used\nint\nNumber of empirical modes to use for interpolation point selection. Cannot exceed the total number of available modes.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_basis_sampled\nndarray of shape (num_modes, num_modes)\nSquare matrix containing rows of the empirical basis corresponding to selected interpolation points. Used to construct the projection matrix.\n\n\nsampled_rows\nlist of int\nOrdered list of DOF indices selected as interpolation points. The order reflects the greedy selection sequence.\n\n\n\n\n\n\nThe algorithm ensures that the interpolation matrix f_basis_sampled remains well-conditioned by construction, as each new point is chosen to maximize the residual norm.\nFor problems with strong locality in nonlinear effects, DEIM typically selects points near regions of highest nonlinear activity, leading to physically intuitive sampling patterns.\nThe computational complexity is O(m³) where m is the number of modes, making it efficient even for moderately large empirical subspaces.\n\n\n\n&gt;&gt;&gt; # Empirical basis from SVD  \n&gt;&gt;&gt; U, s, Vt = np.linalg.svd(F_snapshots, full_matrices=False)\n&gt;&gt;&gt; sampled_basis, indices = deim_obj.deim_red(U, n_modes=10)\n&gt;&gt;&gt; print(f\"Condition number: {np.linalg.cond(sampled_basis):.2e}\")\n\n\n\n\nrom.deim.deim.deim.select_elems()\nSelect interpolation points and construct DEIM projection matrix.\nTL;DR: Core DEIM algorithm that identifies optimal sampling points and builds the projection matrix for fast nonlinear term approximation.\nThis method performs the complete DEIM setup:\n\nSVD Analysis: Decomposes nonlinear snapshots to identify dominant empirical modes that capture essential nonlinear behavior patterns.\nMode Selection: Applies tolerance-based truncation with optional extra modes to balance accuracy and computational efficiency.\nPoint Selection: Uses greedy DEIM algorithm to select interpolation points that minimize approximation error in the empirical subspace.\nElement Mapping: Maps selected DOFs to finite element indicators for efficient sparse matrix assembly during online evaluation.\nProjection Construction: Builds the DEIM projection matrix that enables reconstruction: F_full ≈ U_fs @ pinv(U_fs[selected_rows, :]) @ F_sampled\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndeim_mat\nndarray of shape (n_modes, n_selected_points)\nDEIM projection matrix for reconstructing full nonlinear terms from sampled values. Used as: F_approx = V.T @ U_fs @ deim_mat @ F_sampled\n\n\nsampled_rows\nlist of int\nIndices of degrees of freedom selected as DEIM interpolation points. These are the only DOFs where nonlinear terms need evaluation.\n\n\n\n\n\n\nThe projection matrix construction uses the Moore-Penrose pseudoinverse to ensure numerical stability even when the empirical basis is not perfectly conditioned.\nThe element mapping (self.xi) enables efficient assembly by identifying which finite elements contribute to the selected DOFs, allowing sparse matrix operations during online evaluation.\n\n\n\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, basis_matrix)\n&gt;&gt;&gt; proj_matrix, points = deim_obj.select_elems()\n&gt;&gt;&gt; print(f\"Selected {len(points)} points from {F_snapshots.shape[0]} DOFs\")\n&gt;&gt;&gt; print(f\"Reduction ratio: {F_snapshots.shape[0]/len(points):.1f}x\")",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.deim"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.bilinear_form_hyperrom_ecsw\nECSW-based hyperreduction for finite element bilinear forms with element clustering.\nThis module provides hyperreduction of bilinear forms using Energy-Conserving Sampling and Weighting (ECSW) combined with intelligent element clustering for efficient reduced-order stiffness assembly. It achieves dramatic computational speedups by: - Clustering elements by number of free DOFs for vectorized operations - Extracting and projecting element stiffness blocks onto reduced bases and weighing them - Assembling global reduced matrices via vectorized Einstein summation\nTL;DR: Enables substantial speedup in bilinear form assembly for ROMs while preserving stability and energy conservation through intelligent element clustering and weighted assembly strategies.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through energy-conserving element clustering and weighted sampling, providing both computational efficiency and numerical stability for real-time ROM applications.\nThis class implements a sophisticated hyperreduction strategy that combines Energy-Conserving Sampling and Weighting (ECSW) with intelligent element clustering to achieve massive computational savings while preserving crucial physical properties. The approach works through several key innovations:\nThis hyperreduction is particularly effective for problems where: - Energy conservation is critical (structural dynamics, wave propagation)\n\nElement distributions are relatively uniform (similar local DOF counts)\nComputational stability is paramount for long-time integration\nReal-time performance is required for control or optimization\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept test and trial basis functions and return element-wise stiffness contributions.\nrequired\n\n\nelem_weight\nscalar or array_like of shape (n_elements,)\nElement-wise ECSW weights determining the contribution of each element to the reduced assembly. Can be a single scalar applied to all elements or individual weights per element from ECSW analysis.\nrequired\n\n\nubasis\nBasis\nTrial-space finite element basis containing full DOF count, element connectivity, and quadrature information for the original mesh.\nrequired\n\n\nlob\nndarray of shape (n_free, r) or (n_full, r)\nLeft (test) reduced basis matrix. Shape depends on whether free_dofs is provided - if so, basis is defined only on free DOFs.\nrequired\n\n\nrob\nndarray of shape (n_free, r) or (n_full, r)\nRight (trial) reduced basis matrix with same shape requirements as lob. Projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, all reduced bases and operations are performed only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector for solution centering. Required if snapshot data was mean-subtracted during reduced basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable multi-threaded assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob, rob\nndarray\nLeft and right reduced basis matrices, possibly restricted to free DOFs.\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet boundary conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering and reconstruction.\n\n\nr\nint\nReduced dimension (number of reduced basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices, with Dirichlet DOFs mapped to -1.\n\n\ncluster_idx\nlist of ndarray\nElement indices grouped by number of free DOFs per element. Each entry contains indices of elements with the same free DOF count.\n\n\norder_cluster\nlist of ndarray\nLocal DOF ordering within each cluster for efficient submatrix extraction. Shape: (cluster_size, n_free_dofs_in_cluster).\n\n\nw_cluster\nlist of ndarray\nECSW weights corresponding to elements in each cluster.\n\n\nR_test_free, R_trial_free\nlist of ndarray\nTest and trial basis matrices restricted to free DOFs for each cluster. Shape: (cluster_size, n_free_dofs, r).\n\n\nunique_freedom\nndarray of int\nUnique counts of free DOFs per element, determining the number of clusters.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix using ECSW.\n\n\nextract_element_matrices_rom\nExtract element stiffness matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix using ECSW.\nTL;DR: Main assembly method that orchestrates element clustering, vectorized stiffness extraction, ECSW weighting, and reduced basis projection to produce the final r×r reduced-order stiffness matrix.\nThis method performs the complete ECSW hyperreduction assembly process through a sophisticated multi-stage algorithm:\n\nElement Matrix Extraction: Calls element extraction routines to compute local stiffness matrices for all active elements, leveraging parallel processing when available.\nCluster-Based Processing: Processes elements in clusters based on their free DOF count, enabling highly efficient vectorized operations and eliminating expensive Python loops.\nSubmatrix Extraction: For each cluster, extracts the free DOF submatrices from local element matrices using advanced NumPy indexing for maximum efficiency.\nECSW Weighting: Applies energy-conserving weights to preserve physical properties while enabling computational reduction.\nVectorized Contraction: Uses Einstein summation to perform parallel contractions over entire clusters: A_reduced += Σ_e R_test[e]^T @ (w[e] * K_local[e]) @ R_trial[e]\n\nThe final result preserves the mathematical structure of the full-order operator while achieving dramatic computational savings through intelligent clustering and vectorization strategies.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to element extraction routines for controlling assembly behavior, such as material parameters or quadrature settings.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\nndarray of shape (r, r)\nAssembled reduced-order stiffness matrix ready for use in ROM systems. This matrix preserves the energy conservation properties of the full-order operator while enabling real-time evaluation.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element stiffness matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for ECSW-weighted global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost while maintaining accuracy through ECSW weighting.\nThe method supports both execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and integration uses the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through energy-conserving element clustering and weighted sampling, providing both computational efficiency and numerical stability for real-time ROM applications.\nThis class implements a sophisticated hyperreduction strategy that combines Energy-Conserving Sampling and Weighting (ECSW) with intelligent element clustering to achieve massive computational savings while preserving crucial physical properties. The approach works through several key innovations:\nThis hyperreduction is particularly effective for problems where: - Energy conservation is critical (structural dynamics, wave propagation)\n\nElement distributions are relatively uniform (similar local DOF counts)\nComputational stability is paramount for long-time integration\nReal-time performance is required for control or optimization\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept test and trial basis functions and return element-wise stiffness contributions.\nrequired\n\n\nelem_weight\nscalar or array_like of shape (n_elements,)\nElement-wise ECSW weights determining the contribution of each element to the reduced assembly. Can be a single scalar applied to all elements or individual weights per element from ECSW analysis.\nrequired\n\n\nubasis\nBasis\nTrial-space finite element basis containing full DOF count, element connectivity, and quadrature information for the original mesh.\nrequired\n\n\nlob\nndarray of shape (n_free, r) or (n_full, r)\nLeft (test) reduced basis matrix. Shape depends on whether free_dofs is provided - if so, basis is defined only on free DOFs.\nrequired\n\n\nrob\nndarray of shape (n_free, r) or (n_full, r)\nRight (trial) reduced basis matrix with same shape requirements as lob. Projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, all reduced bases and operations are performed only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector for solution centering. Required if snapshot data was mean-subtracted during reduced basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable multi-threaded assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob, rob\nndarray\nLeft and right reduced basis matrices, possibly restricted to free DOFs.\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet boundary conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering and reconstruction.\n\n\nr\nint\nReduced dimension (number of reduced basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices, with Dirichlet DOFs mapped to -1.\n\n\ncluster_idx\nlist of ndarray\nElement indices grouped by number of free DOFs per element. Each entry contains indices of elements with the same free DOF count.\n\n\norder_cluster\nlist of ndarray\nLocal DOF ordering within each cluster for efficient submatrix extraction. Shape: (cluster_size, n_free_dofs_in_cluster).\n\n\nw_cluster\nlist of ndarray\nECSW weights corresponding to elements in each cluster.\n\n\nR_test_free, R_trial_free\nlist of ndarray\nTest and trial basis matrices restricted to free DOFs for each cluster. Shape: (cluster_size, n_free_dofs, r).\n\n\nunique_freedom\nndarray of int\nUnique counts of free DOFs per element, determining the number of clusters.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix using ECSW.\n\n\nextract_element_matrices_rom\nExtract element stiffness matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix using ECSW.\nTL;DR: Main assembly method that orchestrates element clustering, vectorized stiffness extraction, ECSW weighting, and reduced basis projection to produce the final r×r reduced-order stiffness matrix.\nThis method performs the complete ECSW hyperreduction assembly process through a sophisticated multi-stage algorithm:\n\nElement Matrix Extraction: Calls element extraction routines to compute local stiffness matrices for all active elements, leveraging parallel processing when available.\nCluster-Based Processing: Processes elements in clusters based on their free DOF count, enabling highly efficient vectorized operations and eliminating expensive Python loops.\nSubmatrix Extraction: For each cluster, extracts the free DOF submatrices from local element matrices using advanced NumPy indexing for maximum efficiency.\nECSW Weighting: Applies energy-conserving weights to preserve physical properties while enabling computational reduction.\nVectorized Contraction: Uses Einstein summation to perform parallel contractions over entire clusters: A_reduced += Σ_e R_test[e]^T @ (w[e] * K_local[e]) @ R_trial[e]\n\nThe final result preserves the mathematical structure of the full-order operator while achieving dramatic computational savings through intelligent clustering and vectorization strategies.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to element extraction routines for controlling assembly behavior, such as material parameters or quadrature settings.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\nndarray of shape (r, r)\nAssembled reduced-order stiffness matrix ready for use in ROM systems. This matrix preserves the energy conservation properties of the full-order operator while enabling real-time evaluation.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element stiffness matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for ECSW-weighted global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost while maintaining accuracy through ECSW weighting.\nThe method supports both execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and integration uses the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html",
    "href": "reference/rom.ecsw.hyperreduce.html",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "rom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by:\n1. Optionally applying randomized SVD for dimensionality reduction\n\n2. Constructing bounded constraints for NNLS from projected data\n\n3. Solving a bounded NNLS problem via `NNLSSolver`\n\n4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including:\n\nRandomized SVD preprocessing routines\nBounded NNLS solve integrations (custom_nnls)\nPlotting helpers for diagnostic visualization of reduction errors\n\nDependencies:\n\nNumPy for array operations\nscikit-learn’s randomized_svd for fast SVD\nMatplotlib for plotting diagnostics\nCustom NNLSSolver implementation in custom_nnls\n\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n[Code: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html#functions",
    "href": "reference/rom.ecsw.hyperreduce.html#functions",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.html",
    "href": "reference/rom.ecsw.html",
    "title": "rom.ecsw",
    "section": "",
    "text": "rom.ecsw\nThe ecsw folder implements Empirical Cubature Subset Weighting (ECSW) methods.\nContents: - nnls_solver.py: Active‐set bounded NNLS solver (NNLSSolver) with L₂/L∞ criteria for computing nonnegative cubature weights under per-entry bounds. - Utilities for convergence testing (NNLS_termination), argument verification, and solver configuration.\nTogether, these tools select and weight integration points to approximate high‐dimensional integrals with a sparse subset, enabling efficient reduced‐order model assembly."
  },
  {
    "objectID": "reference/rom.linear_form_rom.html",
    "href": "reference/rom.linear_form_rom.html",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "rom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\nThis module provides: - LinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including:\n\nClasses for projecting and assembling reduced-order bilinear and linear forms\nUtilities for handling Dirichlet boundary conditions in reduced spaces\nChunked and clustered assembly routines to manage large-scale stiffness/load data\nMapping utilities between full-order and reduced-order degrees of freedom\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html#classes",
    "href": "reference/rom.linear_form_rom.html#classes",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html",
    "href": "reference/rom.rom_error_est.html",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "rom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\nThis module provides:\n\ncompute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm).\nplot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up.\ngenerate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console.\n\nThe rom folder contains core tools for reduced-order modeling, including:\n\nAssembly abstractions for reduced bilinear and linear forms\nError evaluation and reporting utilities (this module)\nHyper-reduction and cubature integration tools\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html#functions",
    "href": "reference/rom.rom_error_est.html#functions",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.bilinear_forms.html",
    "href": "reference/templates.problem_template.bilinear_forms.html",
    "title": "templates.problem_template.bilinear_forms",
    "section": "",
    "text": "templates.problem_template.bilinear_forms\n\n\n\n\n\nName\nDescription\n\n\n\n\na\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver):\n\n\n\n\n\ntemplates.problem_template.bilinear_forms.a(u, v, w)\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver): ∫_Ω [your integrand here] dx\n\n\nu : array_like or callable Trial (or current Newton iterate) values at quadrature points. v : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for global matrix assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the Jacobian matrix.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.bilinear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.bilinear_forms.html#functions",
    "href": "reference/templates.problem_template.bilinear_forms.html#functions",
    "title": "templates.problem_template.bilinear_forms",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\na\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver):\n\n\n\n\n\ntemplates.problem_template.bilinear_forms.a(u, v, w)\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver): ∫_Ω [your integrand here] dx\n\n\nu : array_like or callable Trial (or current Newton iterate) values at quadrature points. v : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for global matrix assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the Jacobian matrix.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.bilinear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.linear_forms.html",
    "href": "reference/templates.problem_template.linear_forms.html",
    "title": "templates.problem_template.linear_forms",
    "section": "",
    "text": "templates.problem_template.linear_forms\n\n\n\n\n\nName\nDescription\n\n\n\n\nl\nTemplate for your problem’s linear (load or residual) form:\n\n\n\n\n\ntemplates.problem_template.linear_forms.l(v, w)\nTemplate for your problem’s linear (load or residual) form: ∫_Ω [your integrand here] dx\n\n\nv : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for right-hand side vector assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the residual vector.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.linear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.linear_forms.html#functions",
    "href": "reference/templates.problem_template.linear_forms.html#functions",
    "title": "templates.problem_template.linear_forms",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nl\nTemplate for your problem’s linear (load or residual) form:\n\n\n\n\n\ntemplates.problem_template.linear_forms.l(v, w)\nTemplate for your problem’s linear (load or residual) form: ∫_Ω [your integrand here] dx\n\n\nv : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for right-hand side vector assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the residual vector.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.linear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.problem_def.html",
    "href": "reference/templates.problem_template.problem_def.html",
    "title": "templates.problem_template.problem_def",
    "section": "",
    "text": "templates.problem_template.problem_def\n\n\n\n\n\nName\nDescription\n\n\n\n\nProblemTemplate\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate()\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nImport element-level bilinear (or Jacobian) forms from\n\n\ndomain\nImport domain information from domain.py in the local directory.\n\n\nfom_operators\nAssemble (and cache) full-order operators (e.g. stiffness, mass)\n\n\nfom_rhs\nAssemble (and cache) the full-order RHS vector consumed by\n\n\nfom_solver\nSolve the high-fidelity model for one parameter point.\n\n\nhyper_rom_operators_deim\nCompute operators (interpolation indices, projection matrices, …)\n\n\nhyper_rom_operators_ecsw\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\nhyper_rom_solver_deim\nSolve the DEIM hyper-reduced model.\n\n\nhyper_rom_solver_ecsw\nSolve the ECSW hyper-reduced model.\n\n\nlinear_forms\nImport element-level linear / residual forms from linear_forms.py.\n\n\nparameters\nImport a sampling-design generator from params.py. The helper\n\n\nproperties\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from\n\n\nreduced_operators\nProject FOM operators onto the reduced basis so rom_solver can work\n\n\nrom_solver\nSolve the reduced-order model and reconstruct the high-dimensional\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.bilinear_forms()\nImport element-level bilinear (or Jacobian) forms from bilinear_forms.py. Nothing is assembled here – we merely hand back the callables.\n\n\n\n\n\nfrom bilinear_forms import a1, a2 return [a1, a2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.domain()\nImport domain information from domain.py in the local directory. No geometry is built here – we simply delegate to domain_.\n\n\n\n\n\nfrom domain import domain_ return domain_()\n\n\n\nRequired keys (but not limited to) in the returned dict: * ‘mesh’, ‘basis’ * ‘free_dofs’, ‘dirichlet_dofs’, ‘dirichlet_value’\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_operators(cls)\nAssemble (and cache) full-order operators (e.g. stiffness, mass) used by fom_solver.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nRuntime-state container injected by the master class. Provides simulation metadata such as cls.cur_itr (current sample), solver tolerances, logging utilities, etc.\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_rhs(cls)\nAssemble (and cache) the full-order RHS vector consumed by fom_solver and hyper-reduction routines.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nSimulation context (see fom_operators docstring).\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_solver(cls, param)\nSolve the high-fidelity model for one parameter point.\nCalled automatically by the master class when a simulation is run.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nContains run-time info such as cls.cur_itr.\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ at which to solve.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfull_solution\nndarray\n\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_deim(\n    cls,\n    param,\n)\nCompute operators (interpolation indices, projection matrices, …) for the DEIM method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_ecsw(\n    cls,\n    param,\n)\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_deim(\n    cls,\n    param,\n)\nSolve the DEIM hyper-reduced model.\nCalled automatically by the master class when a DEIM-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_ecsw(\n    cls,\n    param,\n)\nSolve the ECSW hyper-reduced model.\nCalled automatically by the master class when an ECSW-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.linear_forms()\nImport element-level linear / residual forms from linear_forms.py. No assembly happens here – we just return the callables.\n\n\n\n\n\nfrom linear_forms import f1, f2 return [f1, f2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.parameters(n_samples)\nImport a sampling-design generator from params.py. The helper function constructs training / test parameter sets.\n\n\n\n\n\nfrom params import parameters return parameters(n_samples)\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.properties()\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from properties.py located in the same folder.\n\n\n\n\n\nfrom properties import k_func, q_func return [k_func, q_func]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.reduced_operators(\n    cls,\n    param,\n)\nProject FOM operators onto the reduced basis so rom_solver can work in a low-dimensional space.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.rom_solver(cls, param)\nSolve the reduced-order model and reconstruct the high-dimensional field.\nCalled automatically by the master class during a simulation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nGives access to run-time metadata (e.g. cls.cur_itr).\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nu_red\nu_red – parameter-scaled modal coefficients",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.problem_def"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.problem_def.html#classes",
    "href": "reference/templates.problem_template.problem_def.html#classes",
    "title": "templates.problem_template.problem_def",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nProblemTemplate\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate()\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nImport element-level bilinear (or Jacobian) forms from\n\n\ndomain\nImport domain information from domain.py in the local directory.\n\n\nfom_operators\nAssemble (and cache) full-order operators (e.g. stiffness, mass)\n\n\nfom_rhs\nAssemble (and cache) the full-order RHS vector consumed by\n\n\nfom_solver\nSolve the high-fidelity model for one parameter point.\n\n\nhyper_rom_operators_deim\nCompute operators (interpolation indices, projection matrices, …)\n\n\nhyper_rom_operators_ecsw\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\nhyper_rom_solver_deim\nSolve the DEIM hyper-reduced model.\n\n\nhyper_rom_solver_ecsw\nSolve the ECSW hyper-reduced model.\n\n\nlinear_forms\nImport element-level linear / residual forms from linear_forms.py.\n\n\nparameters\nImport a sampling-design generator from params.py. The helper\n\n\nproperties\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from\n\n\nreduced_operators\nProject FOM operators onto the reduced basis so rom_solver can work\n\n\nrom_solver\nSolve the reduced-order model and reconstruct the high-dimensional\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.bilinear_forms()\nImport element-level bilinear (or Jacobian) forms from bilinear_forms.py. Nothing is assembled here – we merely hand back the callables.\n\n\n\n\n\nfrom bilinear_forms import a1, a2 return [a1, a2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.domain()\nImport domain information from domain.py in the local directory. No geometry is built here – we simply delegate to domain_.\n\n\n\n\n\nfrom domain import domain_ return domain_()\n\n\n\nRequired keys (but not limited to) in the returned dict: * ‘mesh’, ‘basis’ * ‘free_dofs’, ‘dirichlet_dofs’, ‘dirichlet_value’\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_operators(cls)\nAssemble (and cache) full-order operators (e.g. stiffness, mass) used by fom_solver.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nRuntime-state container injected by the master class. Provides simulation metadata such as cls.cur_itr (current sample), solver tolerances, logging utilities, etc.\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_rhs(cls)\nAssemble (and cache) the full-order RHS vector consumed by fom_solver and hyper-reduction routines.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nSimulation context (see fom_operators docstring).\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_solver(cls, param)\nSolve the high-fidelity model for one parameter point.\nCalled automatically by the master class when a simulation is run.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nContains run-time info such as cls.cur_itr.\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ at which to solve.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfull_solution\nndarray\n\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_deim(\n    cls,\n    param,\n)\nCompute operators (interpolation indices, projection matrices, …) for the DEIM method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_ecsw(\n    cls,\n    param,\n)\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_deim(\n    cls,\n    param,\n)\nSolve the DEIM hyper-reduced model.\nCalled automatically by the master class when a DEIM-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_ecsw(\n    cls,\n    param,\n)\nSolve the ECSW hyper-reduced model.\nCalled automatically by the master class when an ECSW-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.linear_forms()\nImport element-level linear / residual forms from linear_forms.py. No assembly happens here – we just return the callables.\n\n\n\n\n\nfrom linear_forms import f1, f2 return [f1, f2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.parameters(n_samples)\nImport a sampling-design generator from params.py. The helper function constructs training / test parameter sets.\n\n\n\n\n\nfrom params import parameters return parameters(n_samples)\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.properties()\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from properties.py located in the same folder.\n\n\n\n\n\nfrom properties import k_func, q_func return [k_func, q_func]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.reduced_operators(\n    cls,\n    param,\n)\nProject FOM operators onto the reduced basis so rom_solver can work in a low-dimensional space.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.rom_solver(cls, param)\nSolve the reduced-order model and reconstruct the high-dimensional field.\nCalled automatically by the master class during a simulation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nGives access to run-time metadata (e.g. cls.cur_itr).\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nu_red\nu_red – parameter-scaled modal coefficients",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.problem_def"
    ]
  },
  {
    "objectID": "reference/utils.basic.html",
    "href": "reference/utils.basic.html",
    "title": "utils.basic",
    "section": "",
    "text": "utils.basic\nutils.basic\nThis module imports essential libraries commonly used in pyHyperRom. By using from pyHyperRom.basic import *, users can access frequently utilized libraries."
  },
  {
    "objectID": "reference/utils.custom_nnls.html",
    "href": "reference/utils.custom_nnls.html",
    "title": "utils.custom_nnls",
    "section": "",
    "text": "utils.custom_nnls\nutils.custom_nnls"
  },
  {
    "objectID": "reference/utils.dynamics.newmark_beta.html",
    "href": "reference/utils.dynamics.newmark_beta.html",
    "title": "utils.dynamics.newmark_beta",
    "section": "",
    "text": "utils.dynamics.newmark_beta\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\n\n\n\nutils.dynamics.newmark_beta.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i]."
  },
  {
    "objectID": "reference/utils.dynamics.newmark_beta.html#functions",
    "href": "reference/utils.dynamics.newmark_beta.html#functions",
    "title": "utils.dynamics.newmark_beta",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\n\n\n\nutils.dynamics.newmark_beta.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i]."
  },
  {
    "objectID": "reference/utils.fem_utils.html",
    "href": "reference/utils.fem_utils.html",
    "title": "utils.fem_utils",
    "section": "",
    "text": "utils.fem_utils\nutils.fem_utils"
  },
  {
    "objectID": "reference/utils.newton_solver.html",
    "href": "reference/utils.newton_solver.html",
    "title": "utils.newton_solver",
    "section": "",
    "text": "utils.newton_solver\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.newton_solver.html#functions",
    "href": "reference/utils.newton_solver.html#functions",
    "title": "utils.newton_solver",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.html",
    "href": "reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils"
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html",
    "href": "reference/utils.reduced_basis.svd.html",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "utils.reduced_basis.svd\n\n\n\n\n\nName\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html#functions",
    "href": "reference/utils.reduced_basis.svd.html#functions",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.rom_utils.html",
    "href": "reference/utils.rom_utils.html",
    "title": "utils.rom_utils",
    "section": "",
    "text": "utils.rom_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.rom_utils.html#functions",
    "href": "reference/utils.rom_utils.html#functions",
    "title": "utils.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html",
    "href": "reference/utils.visualization.generate_vtk.html",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html#functions",
    "href": "reference/utils.visualization.generate_vtk.html#functions",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.plot_utils.html",
    "href": "reference/utils.visualization.plot_utils.html",
    "title": "utils.visualization.plot_utils",
    "section": "",
    "text": "utils.visualization.plot_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\nplot_deim_weights\nCreate a stem plot of xi with a zoomed inset.\n\n\nplot_ecsw_weights_3d\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\nutils.visualization.plot_utils.plot_deim_weights(\n    xi,\n    zoom_indices=(0, 1),\n    figsize=(12, 3),\n    nbins=6,\n    line_color='#163e64',\n    stem_color='#a6a6a6',\n    zoom_loc='upper left',\n    zoom_size=('25%', '40%'),\n    zoom_title='Zoomed-in view',\n    zoom_box_offset_x=-0.5,\n    zoom_box_offset_y=-0.2,\n    zoom_box_width=1.0,\n    zoom_box_height_scale=0.4,\n    zoom_box_color='red',\n    zoom_box_linestyle='--',\n    zoom_box_linewidth=1.0,\n)\nCreate a stem plot of xi with a zoomed inset. Uses constrained_layout for automatic spacing.\n\n\n\nutils.visualization.plot_utils.plot_ecsw_weights_3d(\n    mesh,\n    weights,\n    projection='3d',\n    plane='xy',\n    figsize=(8, 6),\n    cmap='viridis',\n    zero_color='#eeeeee',\n    zero_alpha=0.3,\n    weight_threshold=0.001,\n)\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh with attributes: - p: array of shape (3, n_nodes) for node coords. - t: array of shape (nodes_per_elem, n_elems).\nrequired\n\n\nweights\n1D ndarray of length n_elems\nECSW weight per element.\nrequired\n\n\nprojection\n'3d' or projected\n‘3d’ = scatter in 3D; ‘projected’ = heatmap on a plane.\n'3d'\n\n\nplane\n'xy', 'xz', or 'yz'\nwhich plane to project onto if projected.\n'xy'\n\n\nfigsize\nfigure size.\n\n(8, 6)\n\n\ncmap\nname of colormap for &gt;threshold weights.\n\n'viridis'\n\n\nzero_color\ncolor for weights ≤ threshold.\n\n'#eeeeee'\n\n\nzero_alpha\nalpha for zero_color points.\n\n0.3\n\n\nweight_threshold\nfloat\nany w ≤ this will be considered “zero” for display.\n0.001\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fig, ax)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.plot_utils"
    ]
  },
  {
    "objectID": "reference/utils.visualization.plot_utils.html#functions",
    "href": "reference/utils.visualization.plot_utils.html#functions",
    "title": "utils.visualization.plot_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nplot_deim_weights\nCreate a stem plot of xi with a zoomed inset.\n\n\nplot_ecsw_weights_3d\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\nutils.visualization.plot_utils.plot_deim_weights(\n    xi,\n    zoom_indices=(0, 1),\n    figsize=(12, 3),\n    nbins=6,\n    line_color='#163e64',\n    stem_color='#a6a6a6',\n    zoom_loc='upper left',\n    zoom_size=('25%', '40%'),\n    zoom_title='Zoomed-in view',\n    zoom_box_offset_x=-0.5,\n    zoom_box_offset_y=-0.2,\n    zoom_box_width=1.0,\n    zoom_box_height_scale=0.4,\n    zoom_box_color='red',\n    zoom_box_linestyle='--',\n    zoom_box_linewidth=1.0,\n)\nCreate a stem plot of xi with a zoomed inset. Uses constrained_layout for automatic spacing.\n\n\n\nutils.visualization.plot_utils.plot_ecsw_weights_3d(\n    mesh,\n    weights,\n    projection='3d',\n    plane='xy',\n    figsize=(8, 6),\n    cmap='viridis',\n    zero_color='#eeeeee',\n    zero_alpha=0.3,\n    weight_threshold=0.001,\n)\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh with attributes: - p: array of shape (3, n_nodes) for node coords. - t: array of shape (nodes_per_elem, n_elems).\nrequired\n\n\nweights\n1D ndarray of length n_elems\nECSW weight per element.\nrequired\n\n\nprojection\n'3d' or projected\n‘3d’ = scatter in 3D; ‘projected’ = heatmap on a plane.\n'3d'\n\n\nplane\n'xy', 'xz', or 'yz'\nwhich plane to project onto if projected.\n'xy'\n\n\nfigsize\nfigure size.\n\n(8, 6)\n\n\ncmap\nname of colormap for &gt;threshold weights.\n\n'viridis'\n\n\nzero_color\ncolor for weights ≤ threshold.\n\n'#eeeeee'\n\n\nzero_alpha\nalpha for zero_color points.\n\n0.3\n\n\nweight_threshold\nfloat\nany w ≤ this will be considered “zero” for display.\n0.001\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fig, ax)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.plot_utils"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html",
    "href": "reference/utils.visualization.vtuwriter.html",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "utils.visualization.vtuwriter\n\n\n\n\n\nName\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html#classes",
    "href": "reference/utils.visualization.vtuwriter.html#classes",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html",
    "href": "Resources/intro/rom_intro_ex.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling",
    "text": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling\nWe consider the boundary value problem\n\\[\n- \\frac{d}{dx}\\left(k\\,\\frac{dT}{dx}\\right) = q, \\quad x \\in [0, L],\n\\]\nsubject to the boundary conditions:\n\nNeumann: \\(\\left. \\dfrac{dT}{dx} \\right|_{x=0} = 0\\),\nDirichlet: \\(T(L) = T_L\\),\n\nwhere the material parameters are defined as:\n\\[\nk = 16 + \\mu, \\qquad q = 35000 + \\beta,\n\\]\nwith \\(\\mu\\) and \\(\\beta\\) denoting input parameters.\n\n\nWeak Formulation\nMultiplying the governing equation by a test function \\(v \\in V\\) that vanishes at \\(x = L\\), and integrating over the domain yields the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q\\,v(x)\\, dx.\n\\]\n\n\n\nFinite Element Discretization\nDiscretize the interval \\([0, L]\\) into \\(N\\) uniform linear elements of length \\(h = L / N\\). Approximate the solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are piecewise linear basis functions, and \\(T_j\\) are the nodal temperatures. Choosing \\(v = \\phi_i(x)\\) leads to the discrete form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q\\, \\phi_i(x) \\, dx.\n\\]\nThe global system can be written as:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwith\n\n\\(K_{ij} = \\int_0^L k, \\dfrac{d\\phi_j}{dx} \\dfrac{d\\phi_i}{dx} , dx\\) (stiffness matrix),\n\\(F_i = \\int_0^L q, \\phi_i(x) , dx\\) (load vector),\n\\(\\mathbf{T} = [T_1, \\dots, T_n]^\\top\\) (nodal temperatures).\n\nOn each element, the local contributions are:\n\nStiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLoad vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}.\n\\]\n\nThe Neumann condition at \\(x = 0\\) is naturally satisfied. The Dirichlet condition \\(T(L) = T_L\\) is imposed directly on the final equation.\n\n\n\nAnalytical Reference Solution\nFor constant \\(k\\) and \\(q\\), the exact solution is:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2),\n\\]\nwhich provides a useful reference for numerical verification."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "Motivation for Reduced-Order Modeling",
    "text": "Motivation for Reduced-Order Modeling\nWhen evaluating \\(\\mathbf{T}\\) for multiple parameter pairs \\((\\mu, \\beta)\\), solving the full system \\(\\mathbf{K} \\mathbf{T} = \\mathbf{F}\\) repeatedly becomes computationally expensive. This challenge arises in applications such as parameter studies, optimization loops, or real-time simulation.\nReduced-order modeling (ROM) mitigates this cost by projecting the full system onto a lower-dimensional subspace, enabling rapid evaluation with minimal accuracy loss. The approach involves:\n\nAn offline phase where representative solutions (“snapshots”) are collected and used to construct a low-dimensional basis,\nAn online phase where the system is solved in the reduced space, avoiding expensive computations at full resolution.\n\nIn problems with affine parameter dependence, the ROM can be formulated such that no linear solves are required in the online stage, making it suitable for many-query scenarios."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "href": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "title": "SCIKIT-ROM",
    "section": "Affine Reduced-Order Modeling (ROM)",
    "text": "Affine Reduced-Order Modeling (ROM)\nWe approximate the full-order solution using a reduced affine expansion:\n\\[\n\\mathbf{T} \\approx \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a},\n\\]\nwhere:\n\n\\(\\mathbf{T}_{\\text{mean}} \\in \\mathbb{R}^N\\) is the mean of collected snapshots,\n\\(\\mathbf{U} \\in \\mathbb{R}^{N \\times r}\\) is the reduced basis (e.g., from POD),\n\\(\\mathbf{a} \\in \\mathbb{R}^r\\) are reduced coordinates.\n\nSubstituting into the system and applying Galerkin projection:\n\\[\n\\mathbf{K} (\\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}) = \\mathbf{f}\n\\;\\Rightarrow\\;\n\\mathbf{U}^\\top \\mathbf{K} \\mathbf{U} \\mathbf{a} = \\mathbf{U}^\\top(\\mathbf{f} - \\mathbf{K} \\mathbf{T}_{\\text{mean}}).\n\\]\nDefine:\n\nReduced stiffness: \\(\\mathbf{K}_r = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{U}\\),\nReduced source: \\(\\mathbf{b} = \\mathbf{U}^\\top \\mathbf{f}\\),\nProjected offset: \\(\\mathbf{g} = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{T}_{\\text{mean}}\\).\n\nThen:\n\\[\n\\mathbf{a} = \\mathbf{K}_r^{-1}(\\mathbf{b} - \\mathbf{g}),\n\\qquad\n\\hat{\\mathbf{T}} = \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}.\n\\]"
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "href": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "title": "SCIKIT-ROM",
    "section": "Efficient Online Evaluation for Affine Parametric Systems",
    "text": "Efficient Online Evaluation for Affine Parametric Systems\nAssume the system admits the following affine form:\n\\[\n\\mathbf{K}(\\mu) = \\mu\\, \\mathbf{K}_1,\n\\quad\n\\mathbf{f}(\\beta) = \\beta\\, \\mathbf{f}_1.\n\\]\nThen, in the offline phase, precompute:\nIn the online phase, for any \\((\\mu, \\beta)\\):\n\\[\n\\boxed{\n\\hat{\\mathbf{T}}(\\mu, \\beta)\n= \\mathbf{T}_{\\text{mean}}\n+ \\mathbf{U} \\left( \\frac{\\beta}{\\mu} \\mathbf{a}_1 - \\mathbf{c}_1 \\right)\n}\n\\]\nThis avoids matrix assembly and linear solves during inference, resulting in fast and scalable evaluation. Below we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
<<<<<<< Updated upstream
=======
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Welcome to skrom",
    "section": "Getting Started",
    "text": "Getting Started"
  },
  {
    "objectID": "Test.html",
    "href": "Test.html",
    "title": "Nonlinear Heat Conduction Jacobian",
    "section": "",
    "text": "Jacobian bilinear form\nThis section defines the Jacobian bilinear form for nonlinear heat conduction, using scikit-fem’s BilinearForm decorator and helper functions grad and dot.\nimport numpy as np                      # core numerical arrays\nfrom skfem import BilinearForm          # decorator for bilinear forms\nfrom skfem.helpers import grad, dot     # gradient and inner-product ops\nfrom properties import k, q             # conductivity and source functions\n\n\n@BilinearForm\ndef J_form(du, v, p):\n    \"\"\"\n    Assemble Jacobian bilinear form for nonlinear heat conduction.\n\n    Weak form\n    ---------\n    J(du, v) = ∫ [ k(u) ∇du·∇v\n                   + dk(u)·du·⟨∇u,∇v⟩\n                   − dq(u)·du·v ] dx\n\n    Parameters\n    ----------\n    du : array_like or callable\n        Trial function increment at quadrature points.\n    v : array_like or callable\n        Test function at quadrature points.\n    p : dict\n        Assembly context:\n        - u_prev       : ndarray, current solution u\n        - k_param      : float, conductivity offset\n        - q_param      : float, source offset\n        - global_mask  : dict of region masks\n        - elem_indices : ndarray of int, optional subset indices\n\n    Returns\n    -------\n    array_like\n        Elementwise contributions for the Jacobian.\n    \"\"\"\n    # unpack current state and parameters\n    u           = p['u_prev']\n    k_param     = p['k_param']\n    q_param     = p['q_param']\n    mask_dict   = p['global_mask']\n    elems       = p.get('elem_indices', None)\n\n    # evaluate conductivity and its derivative\n    k_val, dk_val = k(\n        u,\n        k_param,\n        global_mask=mask_dict,\n        elem_indices=elems,\n    )\n\n    # evaluate source derivative (we ignore q_val here)\n    _, dq_val = q(\n        u,\n        q_param,\n        global_mask=mask_dict,\n        elem_indices=elems,\n    )\n\n    # return the bilinear integrand\n    return (\n        k_val  * dot(grad(du), grad(v))\n        + dk_val * du * dot(grad(u), grad(v))\n        - dq_val * du * v\n    )"
  },
  {
    "objectID": "src/fom.html",
    "href": "src/fom.html",
    "title": "Finite‐element utilities for full‐order model (FOM) workflows",
    "section": "",
    "text": "Finite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "src/fom.html#fem_utils.py",
    "href": "src/fom.html#fem_utils.py",
    "title": "Finite‐element utilities for full‐order model (FOM) workflows",
    "section": "",
    "text": "Finite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "src/fom_fem_utils.html",
    "href": "src/fom_fem_utils.html",
    "title": "Finite element utilities for preconditioning, mesh operations, and nonlinear solving",
    "section": "",
    "text": "This module provides utilities for finite element computations including AMG preconditioner construction, element-to-coordinate mappings, Newton-Raphson nonlinear solvers with Dirichlet boundary condition handling, regional basis computation, domain loading utilities, and attribute unwrapping helpers."
  },
  {
    "objectID": "src/fom_fem_utils.html#notes",
    "href": "src/fom_fem_utils.html#notes",
    "title": "Finite element utilities for preconditioning, mesh operations, and nonlinear solving",
    "section": "Notes",
    "text": "Notes\nTL;DR: Comprehensive toolkit for finite element method computations with focus on efficient iterative solving, mesh operations, and nonlinear problem handling.\nAuthor: Suparno Bhattacharyya\nimport numpy as np\nfrom skrom.utils.imports import *\nfrom pyamg import smoothed_aggregation_solver\nfrom skfem import solve\n\n\n\ndef build_pc_amgsa(A, **kwargs):\n    \"\"\"\n    Build an algebraic multigrid smoothed aggregation preconditioner.\n\n    **TL;DR**: Creates an AMG preconditioner from a system matrix for efficient \n    iterative solving of large sparse linear systems.\n\n    Parameters\n    ----------\n    A : scipy.sparse matrix or array_like\n        The system matrix for which the preconditioner is constructed\n    **kwargs : dict\n        Additional keyword arguments passed to pyamg.smoothed_aggregation_solver\n\n    Returns\n    -------\n    M : scipy.sparse.linalg.LinearOperator\n        The preconditioner as a linear operator suitable for use in iterative \n        solvers like conjugate gradient\n    \"\"\"\n    return smoothed_aggregation_solver(A, **kwargs).aspreconditioner()\n\n\n\ndef element2location(mesh):\n    \"\"\"\n    Map mesh elements to their spatial coordinates.\n\n    **TL;DR**: Extracts element-wise coordinate information from mesh connectivity,\n    useful for element-based computations in finite element methods.\n\n    Parameters\n    ----------\n    mesh : object\n        Mesh object with attributes `p` (node coordinates) and `t` (element \n        connectivity). Expected to have `p` as shape (spatial_dim, n_nodes) \n        and `t` as shape (n_local_nodes_per_element, n_elements)\n\n    Returns\n    -------\n    element_coords : ndarray of shape (n_elements, n_local_nodes)\n        Array of element coordinates, where each row corresponds to an element \n        and each column corresponds to a local node within the element. For 1D \n        meshes, this gives coordinates of element endpoints\n    \"\"\"\n    # Access node coordinates\n    node_coords = mesh.p  # (spatial_dim, n_nodes)\n\n    # Access element connectivity\n    element_nodes = mesh.t  # (n_local_nodes_per_element, n_elements)\n\n    # Get element-to-location mapping\n    element_coords = node_coords[:, element_nodes]  # (spatial_dim, n_local_nodes, n_elements)\n\n    # Reshape for clarity (for 1D)\n    element_coords = element_coords.squeeze().T  # (n_elements, n_local_nodes)\n\n    return element_coords\n\n\n\ndef compute_basis_regions(basis, masks):\n    \"\"\"\n    Create reduced basis functions for specified mesh regions.\n\n    **TL;DR**: Given boolean masks defining mesh regions, returns basis functions\n    restricted to each region for efficient regional computations.\n\n    Parameters\n    ----------\n    basis : object\n        Finite element basis object with `nelems` attribute and `with_elements` method\n    masks : dict of str to ndarray of bool\n        Dictionary mapping region names to boolean element masks of shape \n        (basis.nelems,). True values indicate elements belonging to the region\n\n    Returns\n    -------\n    region_bases : dict of str to object\n        Dictionary mapping region names to reduced basis objects containing only \n        elements specified by the corresponding mask\n    \"\"\"\n    elem_indices = np.arange(basis.nelems)\n    return {\n        name: basis.with_elements(elem_indices[mask])\n        for name, mask in masks.items()\n    }\n\n\n\ndef load_domain(instance):\n    \"\"\"\n    Load domain information and assign attributes to instance.\n\n    **TL;DR**: Calls instance.domain() and assigns all returned attributes \n    to the instance object for convenient access.\n\n    Parameters\n    ----------\n    instance : object\n        Object with a `domain()` method that returns a dictionary of domain \n        attributes\n\n    Notes\n    -----\n    This function modifies the instance in-place by setting attributes based \n    on the domain dictionary keys and values.\n    \"\"\"\n    dom = instance.domain()\n    for name, val in dom.items():\n        setattr(instance, name, val)\n\n\n\ndef load_mesh_and_basis(instance):\n    \"\"\"\n    Load only mesh and basis from domain and assign to instance.\n\n    **TL;DR**: Extracts just mesh and basis from instance.domain() for cases \n    where only these two components are needed.\n\n    Parameters\n    ----------\n    instance : object\n        Object with a `domain()` method returning a dictionary containing \n        at least 'mesh' and 'basis' keys\n\n    Notes\n    -----\n    This function modifies the instance in-place by setting only `mesh` and \n    `basis` attributes, ignoring other domain components.\n    \"\"\"\n    # grab only the first two returned values\n    dom = instance.domain()\n    mesh = dom[\"mesh\"]\n    basis = dom[\"basis\"]\n\n    # automatically set the attributes\n    for name, val in zip((\"mesh\", \"basis\"), (mesh, basis)):\n        setattr(instance, name, val)\n\n\n\ndef unwrap_attr(instance, attr_name: str):\n    \"\"\"\n    Unwrap 0-dimensional object arrays to their scalar values.\n\n    **TL;DR**: Converts 0-d numpy object arrays to their contained scalar value\n    using .item(), useful for cleaning up attributes after certain operations.\n\n    Parameters\n    ----------\n    instance : object\n        Object containing the attribute to unwrap\n    attr_name : str\n        Name of the attribute to unwrap\n\n    Notes\n    -----\n    Only applies unwrapping if the attribute is a 0-dimensional numpy array \n    with object dtype. The instance is modified in-place.\n    \"\"\"\n    val = getattr(instance, attr_name, None)\n    if isinstance(val, np.ndarray) and val.dtype == object and val.shape == ():\n        setattr(instance, attr_name, val.item())\n\n\n\n# ------------------------------------------------------------\n# PETSc availability + SciPy CSR -&gt; PETSc KSP solve (cached)\n# ------------------------------------------------------------\ndef _petsc_is_available() -&gt; bool:\n    try:\n        import petsc4py  # noqa: F401\n        from petsc4py import PETSc  # noqa: F401\n        return True\n    except Exception:\n        return False\n\n\n\n\ndef petsc_solve_csr(\n    A_csr,\n    b,\n    *,\n    ksp_type: str = \"cg\",\n    pc_type: str = \"ilu\",\n    rtol: float = 1e-8,\n    atol: float = 0.0,\n    max_it: int = 2000,\n    petsc_options: dict | None = None,\n    cache: dict | None = None,\n    ):\n\n    \"\"\"\n    Solve A x = b using PETSc KSP, where A_csr is SciPy CSR (CPU).\n    Uses a small cache to reuse PETSc Mat/KSP objects across calls.\n    \"\"\"\n    from petsc4py import PETSc\n    import scipy.sparse as sp\n\n    if not sp.isspmatrix_csr(A_csr):\n        A_csr = A_csr.tocsr()\n\n    b = np.asarray(b, dtype=np.float64)\n    n = A_csr.shape[0]\n    if b.shape[0] != n:\n        raise ValueError(f\"b has shape {b.shape}, expected ({n},)\")\n\n    # PETSc wants int32 indices/indptr for CSR setters on most builds\n    indptr = np.asarray(A_csr.indptr, dtype=np.int32)\n    indices = np.asarray(A_csr.indices, dtype=np.int32)\n    data = np.asarray(A_csr.data, dtype=np.float64)\n\n    # --- cache key: size + nnz + pointer arrays identity-ish ---\n    # We assume the sparsity pattern is fixed for your FE assembly.\n    key = (n, int(indptr[-1]))\n\n    if cache is None:\n        cache = {}\n\n    state = cache.get(\"state\", None)\n    if state is None or state.get(\"key\", None) != key:\n        # (Re)build PETSc objects\n        A = PETSc.Mat().createAIJ(size=A_csr.shape, csr=(indptr, indices, data))\n        A.setUp()\n        A.assemble()\n\n        x = PETSc.Vec().createSeq(n)\n        bb = PETSc.Vec().createSeq(n)\n\n        ksp = PETSc.KSP().create()\n        ksp.setOperators(A)\n\n        # Set KSP/PC basics\n        ksp.setType(ksp_type)\n        pc = ksp.getPC()\n        pc.setType(pc_type)\n\n        ksp.setTolerances(rtol=rtol, atol=atol, max_it=max_it)\n\n        # Apply options database entries (optional)\n        # These are the same keys you would pass via -ksp_* -pc_* etc.\n        if petsc_options:\n            opts = PETSc.Options()\n            for kk, vv in petsc_options.items():\n                if vv is None:\n                    # allow toggles like {\"ksp_monitor\": None}\n                    opts.setValue(kk, \"\")\n                else:\n                    opts.setValue(kk, str(vv))\n            ksp.setFromOptions()\n        else:\n            ksp.setFromOptions()\n\n        state = {\"key\": key, \"A\": A, \"ksp\": ksp, \"x\": x, \"b\": bb, \"indptr\": indptr, \"indices\": indices}\n        cache[\"state\"] = state\n\n    else:\n        # Reuse PETSc objects; only update numeric values.\n        A = state[\"A\"]\n        ksp = state[\"ksp\"]\n        x = state[\"x\"]\n        bb = state[\"b\"]\n\n        # If pattern changed (should not in FE), rebuild to avoid PETSc \"new nonzero\" errors.\n        if (state[\"indptr\"].shape != indptr.shape) or (state[\"indices\"].shape != indices.shape) \\\n           or (not np.array_equal(state[\"indptr\"], indptr)) or (not np.array_equal(state[\"indices\"], indices)):\n            cache.pop(\"state\", None)\n            return petsc_solve_csr(\n                A_csr, b,\n                ksp_type=ksp_type, pc_type=pc_type,\n                rtol=rtol, atol=atol, max_it=max_it,\n                petsc_options=petsc_options, cache=cache,\n            )\n\n        A.zeroEntries()\n        # This will fail if you try to insert a new nonzero -&gt; but we guarded pattern.\n        A.setValuesCSR(indptr, indices, data)\n        A.assemble()\n\n        # You can still update tolerances per-call if you want\n        ksp.setTolerances(rtol=rtol, atol=atol, max_it=max_it)\n\n    bb.setArray(b)\n    x.set(0.0)\n\n    ksp.solve(bb, x)\n    return x.getArray().copy()\n\n\n# ------------------------------------------------------------\n# Your previous SciPy-only Newton implementation (fallback)\n# (kept as-is; assumes your helpers exist in your codebase)\n# ------------------------------------------------------------\ndef newton_solver_scipy_fallback(\n    assemble_fn,\n    rhs_fn,\n    u0: np.ndarray,\n    dirichlet_dofs: np.ndarray | None = None,\n    dirichlet_vals: np.ndarray | None = None,\n    *assemble_args,\n    tol: float = 1e-2,\n    maxit: int = 50,\n    alpha: float = 1.0,\n    rhs_args: tuple = (),\n    jac_conditioner=False\n):\n    if dirichlet_dofs is None or len(dirichlet_dofs) == 0:\n        return _newton_no_dirichlet_bc(\n            assemble_fn, rhs_fn, u0,\n            *assemble_args,\n            rhs_args=rhs_args,\n            tol=tol, maxit=maxit, alpha=alpha, jac_conditioner=jac_conditioner\n        )\n    else:\n        return _newton_with_dirichlet_bc(\n            assemble_fn, rhs_fn, u0,\n            dirichlet_dofs, dirichlet_vals,\n            *assemble_args,\n            rhs_args=rhs_args,\n            tol=tol, maxit=maxit, alpha=alpha,\n            jac_conditioner=jac_conditioner,\n        )\n\n\ndef _newton_with_dirichlet_bc(\n    assemble_fn, rhs_fn, u0, dofs, vals,\n    *assemble_args,\n    rhs_args=(),\n    tol=1e-2,\n    maxit=50,\n    jac_conditioner=False,\n    alpha=1.0,\n):\n    from skfem import condense, solve\n    # These come from your codebase (leave as-is)\n    # - build_pc_amgsa\n    # - solver_iter_pcg\n    u = u0.copy()\n    pc = None\n    u[dofs] = vals\n    free_dofs = np.setdiff1d(np.arange(len(u)), dofs)\n    delta = np.zeros_like(u)\n\n    for itr in range(maxit):\n        delta.fill(0.0)\n\n        J = assemble_fn(u, *assemble_args)\n        RHS = rhs_fn(u, *rhs_args)\n\n        if jac_conditioner:\n            Jc, RHSc, _, free = condense(J, RHS, D=dofs)\n            if itr &lt; 2:\n                pc = build_pc_amgsa(Jc)\n            delta_free = solve(\n                Jc, -RHSc,\n                solver=solver_iter_pcg(verbose=False, M=pc, tol=1e-16, atol=1e-16)\n            )\n            delta[free] = delta_free\n        else:\n            if (itr + 1) % 40 == 0:\n                alpha *= 0.5\n                print(f\"Iteration {itr}: reducing α → {alpha}\")\n\n            Jc, RHSc, _, _ = condense(J, -RHS, I=free_dofs)\n            delta_free = solve(Jc, RHSc)\n            delta[free_dofs] = alpha * delta_free\n\n        u += delta\n\n        if np.linalg.norm(delta) &lt; tol:\n            return u\n\n    print(\"Newton solver did not converge!\")\n    return u\n\n\ndef _newton_no_dirichlet_bc(\n    assemble_fn, rhs_fn, u0,\n    *assemble_args,\n    rhs_args=(),\n    tol=1e-2,\n    maxit=50,\n    alpha=1.0,\n    jac_conditioner=False,\n):\n    from skfem import solve\n    # These come from your codebase (leave as-is)\n    # - build_pc_amgsa\n    # - solver_iter_pcg\n    u = u0.copy()\n    pc = None\n\n    for itr in range(maxit):\n        J = assemble_fn(u, *assemble_args)\n        RHS = rhs_fn(u, *rhs_args)\n        u_prev = u.copy()\n\n        if itr &lt; 2 and jac_conditioner:\n            pc = build_pc_amgsa(J)\n\n        delta = solve(\n            J, -RHS,\n            solver=solver_iter_pcg(verbose=False, M=pc, tol=1e-16, atol=1e-16)\n        )\n        u += delta*alpha\n\n        if np.linalg.norm(u - u_prev) &lt; tol:\n            return u\n\n    raise RuntimeError(\"Newton solver did not converge!\")\n\n\n# ------------------------------------------------------------\n# AUTO Newton: PETSc for linear solves if available, else fallback\n# ------------------------------------------------------------\ndef newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0: np.ndarray,\n    dirichlet_dofs: np.ndarray | None = None,\n    dirichlet_vals: np.ndarray | None = None,\n    *assemble_args,\n    rhs_args: tuple = (),\n    tol: float = 1e-2,\n    maxit: int = 50,\n    alpha: float = 1.0,\n    jac_conditioner: bool = False,   # used only by SciPy fallback\n    # PETSc KSP options (used only if PETSc import works)\n    ksp_type: str = \"cg\",\n    pc_type: str = \"ilu\",\n    ksp_rtol: float = 1e-8,\n    ksp_atol: float = 0.0,\n    ksp_max_it: int = 2000,\n    petsc_options: dict | None = None,\n    reuse_ksp: bool = True,\n    force_backend: str = \"auto\",  # \"auto\" | \"petsc\" | \"scipy\"\n):\n    \"\"\"\n    If PETSc is available (and not forced off), uses PETSc KSP for the *linear solves only*.\n    Otherwise, falls back to your existing SciPy-based Newton implementation.\n    \"\"\"\n    use_petsc = _petsc_is_available() and (force_backend in (\"auto\", \"petsc\"))\n\n    if force_backend == \"scipy\":\n        use_petsc = False\n    if force_backend == \"petsc\" and not _petsc_is_available():\n        # user forced PETSc but it's not installed -&gt; fallback cleanly\n        use_petsc = False\n\n    if not use_petsc:\n        # Fallback to your previous implementation (unchanged behavior)\n        return newton_solver_scipy_fallback(\n            assemble_fn, rhs_fn, u0,\n            dirichlet_dofs=dirichlet_dofs,\n            dirichlet_vals=dirichlet_vals,\n            *assemble_args,\n            tol=tol, maxit=maxit, alpha=alpha,\n            rhs_args=rhs_args,\n            jac_conditioner=jac_conditioner\n        )\n\n    # --- PETSc-linear-solve path ---\n    from skfem import condense\n    import scipy.sparse as sp\n\n    u = np.array(u0, dtype=np.float64, copy=True)\n\n    dofs = None if dirichlet_dofs is None or len(dirichlet_dofs) == 0 else np.asarray(dirichlet_dofs)\n    vals = None if dofs is None else np.asarray(dirichlet_vals)\n\n    if dofs is not None:\n        u[dofs] = vals\n        free_dofs = np.setdiff1d(np.arange(u.size), dofs)\n    else:\n        free_dofs = None\n\n    ksp_cache = {} if reuse_ksp else None\n\n    for itr in range(maxit):\n        J = assemble_fn(u, *assemble_args)\n        R = rhs_fn(u, *rhs_args)\n\n        if sp.issparse(J) and not sp.isspmatrix_csr(J):\n            J = J.tocsr()\n\n        if dofs is not None:\n            # Reduced system for free dofs\n            Jc, Rc, _, _ = condense(J, -R, I=free_dofs)\n            if sp.issparse(Jc) and not sp.isspmatrix_csr(Jc):\n                Jc = Jc.tocsr()\n\n            delta_free = petsc_solve_csr(\n                Jc, Rc,\n                ksp_type=ksp_type, pc_type=pc_type,\n                rtol=ksp_rtol, atol=ksp_atol, max_it=ksp_max_it,\n                petsc_options=petsc_options,\n                cache=ksp_cache,\n            )\n\n            delta = np.zeros_like(u)\n            delta[free_dofs] = alpha * delta_free\n            delta[dofs] = 0.0\n        else:\n            b = -R\n            delta = petsc_solve_csr(\n                J, b,\n                ksp_type=ksp_type, pc_type=pc_type,\n                rtol=ksp_rtol, atol=ksp_atol, max_it=ksp_max_it,\n                petsc_options=petsc_options,\n                cache=ksp_cache,\n            )\n            delta = alpha * delta\n\n        u += delta\n\n        if dofs is not None:\n            u[dofs] = vals\n\n        if np.linalg.norm(delta) &lt; tol:\n            return u\n\n    raise RuntimeError(\"Newton did not converge within maxit.\")"
  },
  {
    "objectID": "src/fom_fem_utils.html#author",
    "href": "src/fom_fem_utils.html#author",
    "title": "Finite element utilities for preconditioning, mesh operations, and nonlinear solving",
    "section": "Author",
    "text": "Author\nSuparno Bhattacharyya\n```python import numpy as np from skrom.utils.imports import * from pyamg import smoothed_aggregation_solver from skfem import solve\ndef build_pc_amgsa(A, **kwargs): ““” Build an algebraic multigrid smoothed aggregation preconditioner.\n**TL;DR**: Creates an AMG preconditioner from a system matrix for efficient \niterative solving of large sparse linear systems.\n\nParameters\n----------\nA : scipy.sparse matrix or array_like\n    The system matrix for which the preconditioner is constructed\n**kwargs : dict\n    Additional keyword arguments passed to pyamg.smoothed_aggregation_solver\n\nReturns\n-------\nM : scipy.sparse.linalg.LinearOperator\n    The preconditioner as a linear operator suitable for use in iterative \n    solvers like conjugate gradient\n\"\"\"\nreturn smoothed_aggregation_solver(A, **kwargs).aspreconditioner()\ndef element2location(mesh): ““” Map mesh elements to their spatial coordinates.\n**TL;DR**: Extracts element-wise coordinate information from mesh connectivity,\nuseful for element-based computations in finite element methods.\n\nParameters\n----------\nmesh : object\n    Mesh object with attributes `p` (node coordinates) and `t` (element \n    connectivity). Expected to have `p` as shape (spatial_dim, n_nodes) \n    and `t` as shape (n_local_nodes_per_element, n_elements)\n\nReturns\n-------\nelement_coords : ndarray of shape (n_elements, n_local_nodes)\n    Array of element coordinates, where each row corresponds to an element \n    and each column corresponds to a local node within the element. For 1D \n    meshes, this gives coordinates of element endpoints\n\"\"\"\n# Access node coordinates\nnode_coords = mesh.p  # (spatial_dim, n_nodes)\n\n# Access element connectivity\nelement_nodes = mesh.t  # (n_local_nodes_per_element, n_elements)\n\n# Get element-to-location mapping\nelement_coords = node_coords[:, element_nodes]  # (spatial_dim, n_local_nodes, n_elements)\n\n# Reshape for clarity (for 1D)\nelement_coords = element_coords.squeeze().T  # (n_elements, n_local_nodes)\n\nreturn element_coords\ndef compute_basis_regions(basis, masks): ““” Create reduced basis functions for specified mesh regions.\n**TL;DR**: Given boolean masks defining mesh regions, returns basis functions\nrestricted to each region for efficient regional computations.\n\nParameters\n----------\nbasis : object\n    Finite element basis object with `nelems` attribute and `with_elements` method\nmasks : dict of str to ndarray of bool\n    Dictionary mapping region names to boolean element masks of shape \n    (basis.nelems,). True values indicate elements belonging to the region\n\nReturns\n-------\nregion_bases : dict of str to object\n    Dictionary mapping region names to reduced basis objects containing only \n    elements specified by the corresponding mask\n\"\"\"\nelem_indices = np.arange(basis.nelems)\nreturn {\n    name: basis.with_elements(elem_indices[mask])\n    for name, mask in masks.items()\n}\ndef load_domain(instance): ““” Load domain information and assign attributes to instance.\n**TL;DR**: Calls instance.domain() and assigns all returned attributes \nto the instance object for convenient access.\n\nParameters\n----------\ninstance : object\n    Object with a `domain()` method that returns a dictionary of domain \n    attributes\n\nNotes\n-----\nThis function modifies the instance in-place by setting attributes based \non the domain dictionary keys and values.\n\"\"\"\ndom = instance.domain()\nfor name, val in dom.items():\n    setattr(instance, name, val)\ndef load_mesh_and_basis(instance): ““” Load only mesh and basis from domain and assign to instance.\n**TL;DR**: Extracts just mesh and basis from instance.domain() for cases \nwhere only these two components are needed.\n\nParameters\n----------\ninstance : object\n    Object with a `domain()` method returning a dictionary containing \n    at least 'mesh' and 'basis' keys\n\nNotes\n-----\nThis function modifies the instance in-place by setting only `mesh` and \n`basis` attributes, ignoring other domain components.\n\"\"\"\n# grab only the first two returned values\ndom = instance.domain()\nmesh = dom[\"mesh\"]\nbasis = dom[\"basis\"]\n\n# automatically set the attributes\nfor name, val in zip((\"mesh\", \"basis\"), (mesh, basis)):\n    setattr(instance, name, val)\ndef unwrap_attr(instance, attr_name: str): ““” Unwrap 0-dimensional object arrays to their scalar values.\n**TL;DR**: Converts 0-d numpy object arrays to their contained scalar value\nusing .item(), useful for cleaning up attributes after certain operations.\n\nParameters\n----------\ninstance : object\n    Object containing the attribute to unwrap\nattr_name : str\n    Name of the attribute to unwrap\n\nNotes\n-----\nOnly applies unwrapping if the attribute is a 0-dimensional numpy array \nwith object dtype. The instance is modified in-place.\n\"\"\"\nval = getattr(instance, attr_name, None)\nif isinstance(val, np.ndarray) and val.dtype == object and val.shape == ():\n    setattr(instance, attr_name, val.item())"
  },
  {
    "objectID": "src/fom_fem_utils.html#author-suparno-bhattacharyya",
    "href": "src/fom_fem_utils.html#author-suparno-bhattacharyya",
    "title": "Finite element utilities for preconditioning, mesh operations, and nonlinear solving",
    "section": "Author: Suparno Bhattacharyya",
    "text": "Author: Suparno Bhattacharyya\nimport numpy as np\nfrom skrom.utils.imports import *\nfrom pyamg import smoothed_aggregation_solver\nfrom skfem import solve\n\n\n\ndef build_pc_amgsa(A, **kwargs):\n    \"\"\"\n    Build an algebraic multigrid smoothed aggregation preconditioner.\n\n    **TL;DR**: Creates an AMG preconditioner from a system matrix for efficient \n    iterative solving of large sparse linear systems.\n\n    Parameters\n    ----------\n    A : scipy.sparse matrix or array_like\n        The system matrix for which the preconditioner is constructed\n    **kwargs : dict\n        Additional keyword arguments passed to pyamg.smoothed_aggregation_solver\n\n    Returns\n    -------\n    M : scipy.sparse.linalg.LinearOperator\n        The preconditioner as a linear operator suitable for use in iterative \n        solvers like conjugate gradient\n    \"\"\"\n    return smoothed_aggregation_solver(A, **kwargs).aspreconditioner()\n\n\n\ndef element2location(mesh):\n    \"\"\"\n    Map mesh elements to their spatial coordinates.\n\n    **TL;DR**: Extracts element-wise coordinate information from mesh connectivity,\n    useful for element-based computations in finite element methods.\n\n    Parameters\n    ----------\n    mesh : object\n        Mesh object with attributes `p` (node coordinates) and `t` (element \n        connectivity). Expected to have `p` as shape (spatial_dim, n_nodes) \n        and `t` as shape (n_local_nodes_per_element, n_elements)\n\n    Returns\n    -------\n    element_coords : ndarray of shape (n_elements, n_local_nodes)\n        Array of element coordinates, where each row corresponds to an element \n        and each column corresponds to a local node within the element. For 1D \n        meshes, this gives coordinates of element endpoints\n    \"\"\"\n    # Access node coordinates\n    node_coords = mesh.p  # (spatial_dim, n_nodes)\n\n    # Access element connectivity\n    element_nodes = mesh.t  # (n_local_nodes_per_element, n_elements)\n\n    # Get element-to-location mapping\n    element_coords = node_coords[:, element_nodes]  # (spatial_dim, n_local_nodes, n_elements)\n\n    # Reshape for clarity (for 1D)\n    element_coords = element_coords.squeeze().T  # (n_elements, n_local_nodes)\n\n    return element_coords\n\n\n\ndef compute_basis_regions(basis, masks):\n    \"\"\"\n    Create reduced basis functions for specified mesh regions.\n\n    **TL;DR**: Given boolean masks defining mesh regions, returns basis functions\n    restricted to each region for efficient regional computations.\n\n    Parameters\n    ----------\n    basis : object\n        Finite element basis object with `nelems` attribute and `with_elements` method\n    masks : dict of str to ndarray of bool\n        Dictionary mapping region names to boolean element masks of shape \n        (basis.nelems,). True values indicate elements belonging to the region\n\n    Returns\n    -------\n    region_bases : dict of str to object\n        Dictionary mapping region names to reduced basis objects containing only \n        elements specified by the corresponding mask\n    \"\"\"\n    elem_indices = np.arange(basis.nelems)\n    return {\n        name: basis.with_elements(elem_indices[mask])\n        for name, mask in masks.items()\n    }\n\n\n\ndef load_domain(instance):\n    \"\"\"\n    Load domain information and assign attributes to instance.\n\n    **TL;DR**: Calls instance.domain() and assigns all returned attributes \n    to the instance object for convenient access.\n\n    Parameters\n    ----------\n    instance : object\n        Object with a `domain()` method that returns a dictionary of domain \n        attributes\n\n    Notes\n    -----\n    This function modifies the instance in-place by setting attributes based \n    on the domain dictionary keys and values.\n    \"\"\"\n    dom = instance.domain()\n    for name, val in dom.items():\n        setattr(instance, name, val)\n\n\n\ndef load_mesh_and_basis(instance):\n    \"\"\"\n    Load only mesh and basis from domain and assign to instance.\n\n    **TL;DR**: Extracts just mesh and basis from instance.domain() for cases \n    where only these two components are needed.\n\n    Parameters\n    ----------\n    instance : object\n        Object with a `domain()` method returning a dictionary containing \n        at least 'mesh' and 'basis' keys\n\n    Notes\n    -----\n    This function modifies the instance in-place by setting only `mesh` and \n    `basis` attributes, ignoring other domain components.\n    \"\"\"\n    # grab only the first two returned values\n    dom = instance.domain()\n    mesh = dom[\"mesh\"]\n    basis = dom[\"basis\"]\n\n    # automatically set the attributes\n    for name, val in zip((\"mesh\", \"basis\"), (mesh, basis)):\n        setattr(instance, name, val)\n\n\n\ndef unwrap_attr(instance, attr_name: str):\n    \"\"\"\n    Unwrap 0-dimensional object arrays to their scalar values.\n\n    **TL;DR**: Converts 0-d numpy object arrays to their contained scalar value\n    using .item(), useful for cleaning up attributes after certain operations.\n\n    Parameters\n    ----------\n    instance : object\n        Object containing the attribute to unwrap\n    attr_name : str\n        Name of the attribute to unwrap\n\n    Notes\n    -----\n    Only applies unwrapping if the attribute is a 0-dimensional numpy array \n    with object dtype. The instance is modified in-place.\n    \"\"\"\n    val = getattr(instance, attr_name, None)\n    if isinstance(val, np.ndarray) and val.dtype == object and val.shape == ():\n        setattr(instance, attr_name, val.item())\n\n\n\n# ------------------------------------------------------------\n# PETSc availability + SciPy CSR -&gt; PETSc KSP solve (cached)\n# ------------------------------------------------------------\ndef _petsc_is_available() -&gt; bool:\n    try:\n        import petsc4py  # noqa: F401\n        from petsc4py import PETSc  # noqa: F401\n        return True\n    except Exception:\n        return False\n\n\n\n\ndef petsc_solve_csr(\n    A_csr,\n    b,\n    *,\n    ksp_type: str = \"cg\",\n    pc_type: str = \"ilu\",\n    rtol: float = 1e-8,\n    atol: float = 0.0,\n    max_it: int = 2000,\n    petsc_options: dict | None = None,\n    cache: dict | None = None,\n    ):\n\n    \"\"\"\n    Solve A x = b using PETSc KSP, where A_csr is SciPy CSR (CPU).\n    Uses a small cache to reuse PETSc Mat/KSP objects across calls.\n    \"\"\"\n    from petsc4py import PETSc\n    import scipy.sparse as sp\n\n    if not sp.isspmatrix_csr(A_csr):\n        A_csr = A_csr.tocsr()\n\n    b = np.asarray(b, dtype=np.float64)\n    n = A_csr.shape[0]\n    if b.shape[0] != n:\n        raise ValueError(f\"b has shape {b.shape}, expected ({n},)\")\n\n    # PETSc wants int32 indices/indptr for CSR setters on most builds\n    indptr = np.asarray(A_csr.indptr, dtype=np.int32)\n    indices = np.asarray(A_csr.indices, dtype=np.int32)\n    data = np.asarray(A_csr.data, dtype=np.float64)\n\n    # --- cache key: size + nnz + pointer arrays identity-ish ---\n    # We assume the sparsity pattern is fixed for your FE assembly.\n    key = (n, int(indptr[-1]))\n\n    if cache is None:\n        cache = {}\n\n    state = cache.get(\"state\", None)\n    if state is None or state.get(\"key\", None) != key:\n        # (Re)build PETSc objects\n        A = PETSc.Mat().createAIJ(size=A_csr.shape, csr=(indptr, indices, data))\n        A.setUp()\n        A.assemble()\n\n        x = PETSc.Vec().createSeq(n)\n        bb = PETSc.Vec().createSeq(n)\n\n        ksp = PETSc.KSP().create()\n        ksp.setOperators(A)\n\n        # Set KSP/PC basics\n        ksp.setType(ksp_type)\n        pc = ksp.getPC()\n        pc.setType(pc_type)\n\n        ksp.setTolerances(rtol=rtol, atol=atol, max_it=max_it)\n\n        # Apply options database entries (optional)\n        # These are the same keys you would pass via -ksp_* -pc_* etc.\n        if petsc_options:\n            opts = PETSc.Options()\n            for kk, vv in petsc_options.items():\n                if vv is None:\n                    # allow toggles like {\"ksp_monitor\": None}\n                    opts.setValue(kk, \"\")\n                else:\n                    opts.setValue(kk, str(vv))\n            ksp.setFromOptions()\n        else:\n            ksp.setFromOptions()\n\n        state = {\"key\": key, \"A\": A, \"ksp\": ksp, \"x\": x, \"b\": bb, \"indptr\": indptr, \"indices\": indices}\n        cache[\"state\"] = state\n\n    else:\n        # Reuse PETSc objects; only update numeric values.\n        A = state[\"A\"]\n        ksp = state[\"ksp\"]\n        x = state[\"x\"]\n        bb = state[\"b\"]\n\n        # If pattern changed (should not in FE), rebuild to avoid PETSc \"new nonzero\" errors.\n        if (state[\"indptr\"].shape != indptr.shape) or (state[\"indices\"].shape != indices.shape) \\\n           or (not np.array_equal(state[\"indptr\"], indptr)) or (not np.array_equal(state[\"indices\"], indices)):\n            cache.pop(\"state\", None)\n            return petsc_solve_csr(\n                A_csr, b,\n                ksp_type=ksp_type, pc_type=pc_type,\n                rtol=rtol, atol=atol, max_it=max_it,\n                petsc_options=petsc_options, cache=cache,\n            )\n\n        A.zeroEntries()\n        # This will fail if you try to insert a new nonzero -&gt; but we guarded pattern.\n        A.setValuesCSR(indptr, indices, data)\n        A.assemble()\n\n        # You can still update tolerances per-call if you want\n        ksp.setTolerances(rtol=rtol, atol=atol, max_it=max_it)\n\n    bb.setArray(b)\n    x.set(0.0)\n\n    ksp.solve(bb, x)\n    return x.getArray().copy()\n\n\n# ------------------------------------------------------------\n# Your previous SciPy-only Newton implementation (fallback)\n# (kept as-is; assumes your helpers exist in your codebase)\n# ------------------------------------------------------------\ndef newton_solver_scipy_fallback(\n    assemble_fn,\n    rhs_fn,\n    u0: np.ndarray,\n    dirichlet_dofs: np.ndarray | None = None,\n    dirichlet_vals: np.ndarray | None = None,\n    *assemble_args,\n    tol: float = 1e-2,\n    maxit: int = 50,\n    alpha: float = 1.0,\n    rhs_args: tuple = (),\n    jac_conditioner=False\n):\n    if dirichlet_dofs is None or len(dirichlet_dofs) == 0:\n        return _newton_no_dirichlet_bc(\n            assemble_fn, rhs_fn, u0,\n            *assemble_args,\n            rhs_args=rhs_args,\n            tol=tol, maxit=maxit, alpha=alpha, jac_conditioner=jac_conditioner\n        )\n    else:\n        return _newton_with_dirichlet_bc(\n            assemble_fn, rhs_fn, u0,\n            dirichlet_dofs, dirichlet_vals,\n            *assemble_args,\n            rhs_args=rhs_args,\n            tol=tol, maxit=maxit, alpha=alpha,\n            jac_conditioner=jac_conditioner,\n        )\n\n\ndef _newton_with_dirichlet_bc(\n    assemble_fn, rhs_fn, u0, dofs, vals,\n    *assemble_args,\n    rhs_args=(),\n    tol=1e-2,\n    maxit=50,\n    jac_conditioner=False,\n    alpha=1.0,\n):\n    from skfem import condense, solve\n    # These come from your codebase (leave as-is)\n    # - build_pc_amgsa\n    # - solver_iter_pcg\n    u = u0.copy()\n    pc = None\n    u[dofs] = vals\n    free_dofs = np.setdiff1d(np.arange(len(u)), dofs)\n    delta = np.zeros_like(u)\n\n    for itr in range(maxit):\n        delta.fill(0.0)\n\n        J = assemble_fn(u, *assemble_args)\n        RHS = rhs_fn(u, *rhs_args)\n\n        if jac_conditioner:\n            Jc, RHSc, _, free = condense(J, RHS, D=dofs)\n            if itr &lt; 2:\n                pc = build_pc_amgsa(Jc)\n            delta_free = solve(\n                Jc, -RHSc,\n                solver=solver_iter_pcg(verbose=False, M=pc, tol=1e-16, atol=1e-16)\n            )\n            delta[free] = delta_free\n        else:\n            if (itr + 1) % 40 == 0:\n                alpha *= 0.5\n                print(f\"Iteration {itr}: reducing α → {alpha}\")\n\n            Jc, RHSc, _, _ = condense(J, -RHS, I=free_dofs)\n            delta_free = solve(Jc, RHSc)\n            delta[free_dofs] = alpha * delta_free\n\n        u += delta\n\n        if np.linalg.norm(delta) &lt; tol:\n            return u\n\n    print(\"Newton solver did not converge!\")\n    return u\n\n\ndef _newton_no_dirichlet_bc(\n    assemble_fn, rhs_fn, u0,\n    *assemble_args,\n    rhs_args=(),\n    tol=1e-2,\n    maxit=50,\n    alpha=1.0,\n    jac_conditioner=False,\n):\n    from skfem import solve\n    # These come from your codebase (leave as-is)\n    # - build_pc_amgsa\n    # - solver_iter_pcg\n    u = u0.copy()\n    pc = None\n\n    for itr in range(maxit):\n        J = assemble_fn(u, *assemble_args)\n        RHS = rhs_fn(u, *rhs_args)\n        u_prev = u.copy()\n\n        if itr &lt; 2 and jac_conditioner:\n            pc = build_pc_amgsa(J)\n\n        delta = solve(\n            J, -RHS,\n            solver=solver_iter_pcg(verbose=False, M=pc, tol=1e-16, atol=1e-16)\n        )\n        u += delta*alpha\n\n        if np.linalg.norm(u - u_prev) &lt; tol:\n            return u\n\n    raise RuntimeError(\"Newton solver did not converge!\")\n\n\n# ------------------------------------------------------------\n# AUTO Newton: PETSc for linear solves if available, else fallback\n# ------------------------------------------------------------\ndef newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0: np.ndarray,\n    dirichlet_dofs: np.ndarray | None = None,\n    dirichlet_vals: np.ndarray | None = None,\n    *assemble_args,\n    rhs_args: tuple = (),\n    tol: float = 1e-2,\n    maxit: int = 50,\n    alpha: float = 1.0,\n    jac_conditioner: bool = False,   # used only by SciPy fallback\n    # PETSc KSP options (used only if PETSc import works)\n    ksp_type: str = \"cg\",\n    pc_type: str = \"ilu\",\n    ksp_rtol: float = 1e-8,\n    ksp_atol: float = 0.0,\n    ksp_max_it: int = 2000,\n    petsc_options: dict | None = None,\n    reuse_ksp: bool = True,\n    force_backend: str = \"auto\",  # \"auto\" | \"petsc\" | \"scipy\"\n):\n    \"\"\"\n    If PETSc is available (and not forced off), uses PETSc KSP for the *linear solves only*.\n    Otherwise, falls back to your existing SciPy-based Newton implementation.\n    \"\"\"\n    use_petsc = _petsc_is_available() and (force_backend in (\"auto\", \"petsc\"))\n\n    if force_backend == \"scipy\":\n        use_petsc = False\n    if force_backend == \"petsc\" and not _petsc_is_available():\n        # user forced PETSc but it's not installed -&gt; fallback cleanly\n        use_petsc = False\n\n    if not use_petsc:\n        # Fallback to your previous implementation (unchanged behavior)\n        return newton_solver_scipy_fallback(\n            assemble_fn, rhs_fn, u0,\n            dirichlet_dofs=dirichlet_dofs,\n            dirichlet_vals=dirichlet_vals,\n            *assemble_args,\n            tol=tol, maxit=maxit, alpha=alpha,\n            rhs_args=rhs_args,\n            jac_conditioner=jac_conditioner\n        )\n\n    # --- PETSc-linear-solve path ---\n    from skfem import condense\n    import scipy.sparse as sp\n\n    u = np.array(u0, dtype=np.float64, copy=True)\n\n    dofs = None if dirichlet_dofs is None or len(dirichlet_dofs) == 0 else np.asarray(dirichlet_dofs)\n    vals = None if dofs is None else np.asarray(dirichlet_vals)\n\n    if dofs is not None:\n        u[dofs] = vals\n        free_dofs = np.setdiff1d(np.arange(u.size), dofs)\n    else:\n        free_dofs = None\n\n    ksp_cache = {} if reuse_ksp else None\n\n    for itr in range(maxit):\n        J = assemble_fn(u, *assemble_args)\n        R = rhs_fn(u, *rhs_args)\n\n        if sp.issparse(J) and not sp.isspmatrix_csr(J):\n            J = J.tocsr()\n\n        if dofs is not None:\n            # Reduced system for free dofs\n            Jc, Rc, _, _ = condense(J, -R, I=free_dofs)\n            if sp.issparse(Jc) and not sp.isspmatrix_csr(Jc):\n                Jc = Jc.tocsr()\n\n            delta_free = petsc_solve_csr(\n                Jc, Rc,\n                ksp_type=ksp_type, pc_type=pc_type,\n                rtol=ksp_rtol, atol=ksp_atol, max_it=ksp_max_it,\n                petsc_options=petsc_options,\n                cache=ksp_cache,\n            )\n\n            delta = np.zeros_like(u)\n            delta[free_dofs] = alpha * delta_free\n            delta[dofs] = 0.0\n        else:\n            b = -R\n            delta = petsc_solve_csr(\n                J, b,\n                ksp_type=ksp_type, pc_type=pc_type,\n                rtol=ksp_rtol, atol=ksp_atol, max_it=ksp_max_it,\n                petsc_options=petsc_options,\n                cache=ksp_cache,\n            )\n            delta = alpha * delta\n\n        u += delta\n\n        if dofs is not None:\n            u[dofs] = vals\n\n        if np.linalg.norm(delta) &lt; tol:\n            return u\n\n    raise RuntimeError(\"Newton did not converge within maxit.\")"
  },
  {
    "objectID": "src/skrom_problrm_classes_static_master_class.html",
    "href": "src/skrom_problrm_classes_static_master_class.html",
    "title": "Static reduced-order modeling (ROM) framework",
    "section": "",
    "text": "Static reduced-order modeling (ROM) framework."
  },
  {
    "objectID": "src/skrom_problrm_classes_static_master_class.html#tldr",
    "href": "src/skrom_problrm_classes_static_master_class.html#tldr",
    "title": "Static reduced-order modeling (ROM) framework",
    "section": "TL;DR",
    "text": "TL;DR\nRuns an offline full-order FEM snapshot stage and an online reduced-order solve stage, with optional hyper-reduction (DEIM, ECSW) to lower cost while tracking error and speed.\nThe module defines: - a problem interface based on an abstract base class - a registry for problem classes and a factory to instantiate them - an offline workflow that runs full-order solves to generate snapshots - an online workflow that runs ROM and computes error and timing metrics - hooks for hyper-reduction workflows based on DEIM and ECSW"
  },
  {
    "objectID": "src/skrom_problrm_classes_static_master_class.html#notes",
    "href": "src/skrom_problrm_classes_static_master_class.html#notes",
    "title": "Static reduced-order modeling (ROM) framework",
    "section": "Notes",
    "text": "Notes\nAuthors: Suparno Bhattacharyya; Ali Hamza Abidi Syed\nfrom pathlib import Path\nimport os,re,json,time,hashlib,tempfile\nimport numpy as np\nimport time\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, Dict, Type\nfrom skrom.fom.fem_utils import unwrap_attr\nfrom skrom.rom.rom_utils import rom_data_gen, load_rom_data, reconstruct_solution\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM DETECTION\n# ─────────────────────────────────────────────────────────────\ncwd = Path.cwd()\n# If running inside a folder named \"problem_X\", use that; else raise an error\nif cwd.name.startswith(\"problem_\"):\n    PROBLEM = cwd.name\nelse:\n    raise ValueError(\n        \"Current directory must be named 'problem_X' where X can be a number/string.\")\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM REGISTRY AND INTERFACE\n# ─────────────────────────────────────────────────────────────\nclass Problem(ABC):\n    \"\"\"\n    Interface for parameterized problems used by the ROM workflow.\n\n    The class defines the required methods for:\n    - mesh and basis setup\n    - affine components of bilinear and linear forms\n    - parameter-dependent coefficient evaluation\n    - sampling of the parameter space\n    - full-order and reduced-order solvers\n    - hyper-reduced solvers based on DEIM and ECSW\n    \"\"\"\n    @abstractmethod\n    def domain(self):\n        \"\"\"Return geometry and FEM bases.\"\"\"\n        pass\n\n    @abstractmethod\n    def bilinear_forms(self):\n        \"\"\"Return affine bilinear form components.\"\"\"\n        pass\n\n    @abstractmethod\n    def linear_forms(self):\n        \"\"\"Return affine linear form components.\"\"\"\n        pass\n\n    @abstractmethod\n    def properties(self):\n        \"\"\"Return function to compute parameter-dependent coefficients.\"\"\"\n        pass\n\n    @abstractmethod\n    def parameters(self):\n        \"\"\"Generate sampling of parameter space.\"\"\"\n        pass\n\n    @abstractmethod\n    def fom_solver(self):\n        \"\"\"Solve full-order FEM system for given parameters.\"\"\"\n        pass\n\n    @abstractmethod\n    def rom_solver(self):\n        \"\"\"Solve reduced-order model for given parameters.\"\"\"\n        pass\n\n    @abstractmethod\n    def hyper_rom_solver_deim(self):\n        \"\"\"Solve DEIM-based hyper-reduced system for given parameters.\"\"\"\n        pass\n\n    @abstractmethod\n    def hyper_rom_solver_ecsw(self):\n        \"\"\"Solve ECSW-based hyper-reduced system for given parameters.\"\"\"\n        pass\n\n\n# Decorator to register problem classes by name\nPROBLEM_REGISTRY: Dict[str, Type[Problem]] = {}\n\n\ndef register_problem(name: str):\n    \"\"\"\n    Register a problem class under a string key.\n\n    Parameters\n    ----------\n    name : str\n        Registry key for the problem class.\n\n    Returns\n    -------\n    deco : callable\n        Decorator that adds the class to ``PROBLEM_REGISTRY`` and returns it.\n\n    Notes\n    -----\n    The registry supports dynamic selection of a problem class based on the\n    working directory name.\n    \"\"\"\n    def deco(cls: Type[Problem]) -&gt; Type[Problem]:\n        PROBLEM_REGISTRY[name] = cls\n        return cls\n    return deco\n\n\ndef get_problem(name: str) -&gt; Problem:\n    \"\"\"\n    Instantiate a registered problem class.\n\n    Parameters\n    ----------\n    name : str\n        Registry key used in ``PROBLEM_REGISTRY``.\n\n    Returns\n    -------\n    problem_instance : Problem\n        Instance of the registered class.\n\n    Raises\n    ------\n    ValueError\n        If ``name`` is not present in the registry.\n    \"\"\"\n    try:\n        return PROBLEM_REGISTRY[name]()\n    except KeyError:\n        raise ValueError(f\"Unknown problem '{name}'. Available problems: {list(PROBLEM_REGISTRY.keys())}\")\n\n\ndef assign_properties(prob: Problem) -&gt; Tuple:\n    \"\"\"\n    Collect callable handles from a problem instance.\n\n    Parameters\n    ----------\n    prob : Problem\n        Problem instance.\n\n    Returns\n    -------\n    properties : tuple\n        Tuple with:\n        (parameters, bilinear_forms, linear_forms, domain, properties,\n        fom_solver, rom_solver, hyper_deim_solver, hyper_ecsw_solver).\n    \"\"\"\n    parameters        = prob.parameters\n    a                 = prob.bilinear_forms()\n    l                 = prob.linear_forms()\n    domain_           = prob.domain\n    properties        = prob.properties()\n    fom_solver        = prob.fom_solver\n    rom_solver        = prob.rom_solver\n    hyper_deim_solver = prob.hyper_rom_solver_deim\n    hyper_ecsw_solver = prob.hyper_rom_solver_ecsw\n\n    return (\n        parameters, a, l, domain_, properties,\n        fom_solver,\n        rom_solver,\n        hyper_deim_solver,\n        hyper_ecsw_solver,\n    )\n\n\n# ─────────────────────────────────────────────────────────────\n# OFFLINE SNAPSHOT GENERATION\n# ─────────────────────────────────────────────────────────────\nclass fom_simulation:\n    \"\"\"\n    Offline snapshot generation workflow.\n\n    The workflow:\n    - draws parameter samples\n    - runs full-order solves\n    - stores solutions and solve times\n    - computes a reference field for centering\n    - saves outputs to a ROM_data directory\n\n    Attributes\n    ----------\n    num_snapshots : int\n        Number of parameter samples.\n    param_list : array_like\n        Parameter samples.\n    fos_solutions : list of ndarray\n        Full-order solutions for each parameter sample.\n    fos_time : list of float\n        Solve time for each full-order solve.\n    train_ref : ndarray\n        Mean field computed from training snapshots.\n    \"\"\"\n\n    def __init__(self, num_snapshots: int = 32):\n        \"\"\"\n        Initialize the offline workflow.\n\n        Parameters\n        ----------\n        num_snapshots : int, optional\n            Number of snapshots used in the offline run. Default is 32.\n        \"\"\"\n        # Bind prob methods\n        prob = get_problem(PROBLEM)\n        (\n        self.parameters,\n        self.bilinear_forms,\n        self.linear_forms,\n        self.domain,\n        self.properties,\n        self.fom_solver,\n        *_\n        ) = assign_properties(prob)\n\n        # Track attributes introduced by this class\n        self._baseline_attrs = set(vars(self))\n\n        # Load domain and basis\n        data = self.domain()\n        self.mesh  = data[\"mesh\"]\n        self.basis = data[\"basis\"]\n\n        # Prepare parameter sampling\n        self.num_snapshots = num_snapshots\n        (\n            self.param_list,\n            self.param_range,\n            self.train_mask,\n            self.test_mask\n        ) = self.parameters(num_snapshots)\n\n        # Containers for solutions and timings\n        self.fos_solutions = []\n        self.fos_time      = []\n\n\n\n    def run_simulation(self) -&gt; None:\n        \"\"\"\n        Run full-order solves and save offline outputs.\n\n        Adds:\n        - per-sample checkpointing to .npz\n        - resume: if checkpoint exists, load it and skip the solve\n        - long-path-safe filenames (Windows): hash-first + fallback to hash-only\n        - crash-safe writes (atomic replace)\n        - corrupt checkpoint handling (recompute + overwrite)\n        \"\"\"\n\n        # reset in-memory containers (important when re-running in notebooks)\n        self.fos_solutions = []\n        self.fos_time = []\n\n        cur_dir = os.getcwd()\n\n        # keep directory name short to reduce Windows path length risk\n        ckpt_dir = Path(cur_dir) / \"ckpt\"\n        ckpt_dir.mkdir(parents=True, exist_ok=True)\n\n        # ---------- helpers ----------\n        def _safe_token(s: str, maxlen: int) -&gt; str:\n            s = re.sub(r\"\\s+\", \"\", s)\n            s = re.sub(r\"[^0-9A-Za-z,.\\-+eE_]\", \"_\", s)\n            return s[:maxlen]\n\n        def _problem_tag() -&gt; str:\n            return (\n                getattr(self, \"PROBLEM_NAME\", None)\n                or getattr(self, \"problem_name\", None)\n                or self.__class__.__name__\n            )\n\n        def _param_signature(param):\n            \"\"\"\n            Returns:\n            preview_token (short, human-readable),\n            hash10 (stable),\n            stored_param (array or string array for saving inside .npz)\n            \"\"\"\n            try:\n                arr = np.asarray(param, dtype=float).ravel()\n                b = arr.tobytes()\n                preview = \",\".join(f\"{x:.12g}\" for x in arr[:6])\n                if arr.size &gt; 6:\n                    preview += f\",...n{arr.size}\"\n                stored = arr\n            except Exception:\n                js = json.dumps(param, sort_keys=True, default=str)\n                b = js.encode(\"utf-8\")\n                preview = js\n                stored = np.array([js], dtype=\"U\")\n\n            h10 = hashlib.sha1(b).hexdigest()[:10]\n            return preview, h10, stored\n\n        def _ckpt_path(param) -&gt; Path:\n            preview, h10, _ = _param_signature(param)\n            prob = _safe_token(_problem_tag(), maxlen=20)\n\n            # Keep preview very short; uniqueness comes from hash\n            preview = _safe_token(preview, maxlen=30)\n\n            # Option 1: slightly descriptive\n            name1 = f\"fos_{prob}_p{preview}_h{h10}.npz\"\n            path1 = ckpt_dir / name1\n\n            # Option 2: hash-only (short path fallback)\n            name2 = f\"fos_{prob}_h{h10}.npz\"\n            path2 = ckpt_dir / name2\n\n            # Windows long path guard\n            if os.name == \"nt\":\n                # keep headroom below 260\n                if len(str(path1)) &gt;= 240:\n                    return path2\n\n            return path1\n\n        def _atomic_save_npz(path: Path, payload: dict):\n            # IMPORTANT: temp file must end with \".npz\" (np.savez appends otherwise)\n            path.parent.mkdir(parents=True, exist_ok=True)\n            with tempfile.NamedTemporaryFile(\n                dir=str(path.parent),\n                prefix=path.stem + \"_\",\n                suffix=\".npz\",\n                delete=False,\n            ) as tf:\n                tmp_name = tf.name\n\n            try:\n                np.savez_compressed(tmp_name, **payload)\n                os.replace(tmp_name, str(path))  # atomic on same filesystem\n            finally:\n                if os.path.exists(tmp_name):\n                    try:\n                        os.remove(tmp_name)\n                    except OSError:\n                        pass\n\n        def _save_solution(path: Path, sol, param, elapsed: float, snap_index: int):\n            _, _, param_store = _param_signature(param)\n\n            payload = {\n                \"snap_index\": np.array([snap_index], dtype=np.int64),\n                \"solve_time\": np.array([elapsed], dtype=float),\n                \"param\": param_store,\n            }\n\n            if isinstance(sol, tuple):\n                payload[\"nsol\"] = np.array([len(sol)], dtype=np.int32)\n                for j, x in enumerate(sol):\n                    payload[f\"sol{j}\"] = np.asarray(x)\n            else:\n                payload[\"nsol\"] = np.array([1], dtype=np.int32)\n                payload[\"sol0\"] = np.asarray(sol)\n\n            _atomic_save_npz(path, payload)\n\n        def _load_solution(path: Path):\n            with np.load(path, allow_pickle=False) as data:\n                nsol = int(data[\"nsol\"][0]) if \"nsol\" in data.files else 1\n                t = float(data[\"solve_time\"][0]) if \"solve_time\" in data.files else np.nan\n                if nsol == 1:\n                    sol = data[\"sol0\"]\n                else:\n                    sol = tuple(data[f\"sol{j}\"] for j in range(nsol))\n            return sol, t\n\n        # ---------- main loop ----------\n        for i, param in enumerate(self.param_list):\n            print(f\"Snap {i+1}/{len(self.param_list)} params={param}\")\n            self.cur_itr = i\n\n            path = _ckpt_path(param)\n\n            if path.exists():\n                try:\n                    sol, t_saved = _load_solution(path)\n                    self.fos_time.append(t_saved)\n                except Exception:\n                    # corrupt/partial file -&gt; delete and recompute\n                    try:\n                        path.unlink(missing_ok=True)\n                    except Exception:\n                        pass\n\n                    t0 = time.perf_counter()\n                    sol = self.fom_solver(cls=self, param=param)\n                    elapsed = time.perf_counter() - t0\n                    self.fos_time.append(elapsed)\n                    _save_solution(path, sol, param, elapsed, snap_index=i)\n            else:\n                t0 = time.perf_counter()\n                sol = self.fom_solver(cls=self, param=param)\n                elapsed = time.perf_counter() - t0\n                self.fos_time.append(elapsed)\n                _save_solution(path, sol, param, elapsed, snap_index=i)\n\n            # store solution copy (in-memory)\n            if isinstance(sol, tuple):\n                self.fos_solutions.append(tuple(np.copy(x) for x in sol))\n            else:\n                self.fos_solutions.append(np.copy(sol))\n\n        # ---------- convert + mean over training subset ----------\n        if len(self.fos_solutions) == 0:\n            return\n\n        first = self.fos_solutions[0]\n        if isinstance(first, tuple):\n            self.fos_solutions = np.array(self.fos_solutions, dtype=object)\n\n            train_ids = np.where(self.train_mask)[0]\n            ncomp = len(first)\n            train_ref = []\n            for j in range(ncomp):\n                stack_j = np.stack([self.fos_solutions[k][j] for k in train_ids], axis=0)\n                train_ref.append(np.mean(stack_j, axis=0))\n            self.train_ref = tuple(train_ref)\n        else:\n            self.fos_solutions = np.asarray(self.fos_solutions)\n            self.train_ref = np.mean(self.fos_solutions[self.train_mask], axis=0)\n\n        # ---------- Persist new attributes to disk ----------\n        new = set(vars(self)) - self._baseline_attrs\n        save_dict = {k: getattr(self, k) for k in new if not k.startswith(\"_\")}\n        rom_data_gen(save_dict, cur_dir)\n\n\n\n# ─────────────────────────────────────────────────────────────\n# ONLINE ROM EVALUATION\n# ─────────────────────────────────────────────────────────────\nclass rom_simulation:\n    \"\"\"\n    Online ROM evaluation workflow.\n\n    The workflow:\n    - loads ROM_data outputs from disk\n    - selects test parameters and reference full-order solutions\n    - runs ROM solvers and reconstructs full fields\n    - computes relative error and time ratio metrics\n    - supports hyper-reduced solvers based on DEIM and ECSW\n\n    Attributes\n    ----------\n    V_sel : ndarray\n        Basis matrix used for reconstruction.\n    n_sel : int\n        Mode count used by the ROM.\n    param_list_test : array_like\n        Test parameter samples.\n    rom_error : list of float\n        Relative error values in percent for each test case.\n    speed_up : list of float\n        Time ratios computed as (full-order time) / (ROM time).\n    \"\"\"\n\n    def __init__(\n        self, train_ref=None, test_ref=None, fos_solutions=None,\n        train_mask=None, test_mask=None,\n        V_sel=None, n_sel=None, N_rom_snap=None\n    ):\n        \"\"\"\n        Initialize the online workflow and load ROM_data outputs.\n\n        Parameters\n        ----------\n        train_ref : ndarray, optional\n            Reference field used for centering during training.\n        test_ref : ndarray, optional\n            Reference field used for reconstruction on the test set.\n        fos_solutions : ndarray, optional\n            Full-order snapshots. If None, data are loaded from disk.\n        train_mask : array_like of bool, optional\n            Training mask. If None, data are loaded from disk.\n        test_mask : array_like of bool, optional\n            Test mask. If None, data are loaded from disk.\n        V_sel : ndarray, optional\n            Basis matrix used in reconstruction.\n        n_sel : int, optional\n            Mode count used by the ROM.\n        N_rom_snap : int, optional\n            Test case count evaluated in the run. If None, uses all test cases.\n\n        Notes\n        -----\n        The initializer loads ``ROM_data`` from the current working directory.\n        \"\"\"\n        # Bind prob methods\n        prob = get_problem(PROBLEM)\n        (\n            self.parameters,\n            self.bilinear_forms,\n            self.linear_forms,\n            self.domain,\n            self.properties,\n            _,\n            self.rom_solver,\n            self.hyper_rom_solver_deim,\n            self.hyper_rom_solver_ecsw,\n        ) = assign_properties(prob)\n\n        # Load ROM data from disk\n        cur_dir = os.getcwd()\n        rom_dir = os.path.join(cur_dir, \"ROM_data\")\n        load_rom_data(self, rom_dir)\n\n        if train_ref is not None:\n            self.train_ref = train_ref\n\n        if test_ref is not None:\n            self.test_ref = test_ref\n        else:\n            self.test_ref = self.train_ref\n\n        if fos_solutions is not None:\n            self.fos_solutions = fos_solutions\n\n        if train_mask is not None:\n            self.train_mask = train_mask\n        \n        if test_mask is not None:\n            self.test_mask = test_mask\n\n        # Prepare test/training splits\n        self.param_list_test = self.param_list[self.test_mask]\n        self.fos_test_data   = self.fos_solutions[self.test_mask]\n        self.fos_test_time   = np.asarray(self.fos_time)[self.test_mask]\n        self.sol_train_ms    = self.fos_solutions[self.train_mask] - self.train_ref\n\n        # Store basis info\n        self.V_sel      = V_sel\n        self.n_sel      = n_sel\n        self.N_rom_snap = N_rom_snap or len(self.param_list_test)\n\n        # Ensure attributes are unwrapped if zero-dimensional\n        unwrap_attr(self, 'basis')\n        unwrap_attr(self, 'mesh')\n\n    def run_rom_simulation(self):\n        \"\"\"\n        Run ROM evaluation on the test set.\n\n        The method:\n        - runs the reduced solver for each test parameter\n        - reconstructs a full field from reduced coordinates\n        - computes relative error in percent\n        - computes time ratio (full-order time) / (ROM time)\n\n        Returns\n        -------\n        rom_error : list of float\n            Relative error values in percent.\n        speed_up : list of float\n            Time ratios for each test case.\n        \"\"\"\n        self.speed_up     = []\n        self.rom_error    = []\n        self.rom_solutions = []\n\n        for i, param in enumerate(self.param_list_test[:self.N_rom_snap]):\n            print(f\"Snap {i+1}/{len(self.param_list)} params={param}\")\n            self.cur_itr = i\n\n            # Time the ROM solve\n            t0 = time.perf_counter()\n            sol_red_ = self.rom_solver(cls=self, param=param)\n\n            if self.test_ref is not None:\n\n                if len(self.test_ref.shape)==3:\n                    sol_rom = reconstruct_solution(sol_red_, self.V_sel, self.test_ref[i])\n                else:\n                    sol_rom = reconstruct_solution(sol_red_, self.V_sel, self.test_ref)\n\n            dt = time.perf_counter() - t0\n            # Compute error & speed-up\n            sol_fos = self.fos_test_data[i]\n\n            if sol_rom.shape != sol_fos.shape and sol_rom.ndim == 2 and sol_rom.T.shape == sol_fos.shape:\n                sol_rom = sol_rom.T\n\n            if sol_rom.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_rom.shape}\")\n            \n            err   = 100 * np.linalg.norm(sol_fos - sol_rom) \\\n                    / np.linalg.norm(sol_fos)\n            speed = self.fos_test_time[i] / dt\n\n            self.rom_error.append(err)\n            self.speed_up.append(speed)\n            self.rom_solutions.append(sol_rom.copy())\n\n        return self.rom_error, self.speed_up\n    \n    def run_hyper_rom_simulation_ecsw(self, z):\n        \"\"\"\n        Run ECSW hyper-ROM evaluation on the test set.\n\n        Parameters\n        ----------\n        z : array_like\n            Element weight vector used by the ECSW solver.\n\n        Returns\n        -------\n        hyper_rom_error : list of float\n            Relative error values in percent.\n        hyper_speed_up : list of float\n            Time ratios for each test case.\n        \"\"\"\n        self.hyper_speed_up    = []\n        self.hyper_rom_error   = []\n        self.hyper_rom_solutions = []\n        # Store hyper-reduction parameters\n        self.z            = z\n\n        for i, param in enumerate(self.param_list_test[:self.N_rom_snap]):\n            print(f\"Snap {i+1}/{len(self.param_list_test)} params={param}\")\n            self.cur_itr = i\n\n            # Time the hyper-ROM solve + reconstruction\n            t0 = time.perf_counter()\n            sol_red_ = self.hyper_rom_solver_ecsw(cls=self, param=param)\n\n            if len(self.test_ref.shape)==3:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref[i])\n            else:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref)\n\n\n            dt = time.perf_counter() - t0\n\n            # record speed-up and solution\n            self.hyper_speed_up.append(self.fos_test_time[i] / dt)\n\n            # compute and record error\n            sol_fos = self.fos_test_data[i]\n\n            if sol_hyper.shape != sol_fos.shape and sol_hyper.ndim == 2 and sol_hyper.T.shape == sol_fos.shape:\n                sol_hyper = sol_hyper.T\n\n            if sol_hyper.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyper.shape}\")\n\n            self.hyper_rom_solutions.append(sol_hyper.copy())\n\n            err = 100 * np.linalg.norm(sol_fos - sol_hyper) / np.linalg.norm(sol_fos)\n            self.hyper_rom_error.append(err)\n\n        return self.hyper_rom_error, self.hyper_speed_up\n\n\n    def run_hyper_rom_simulation_deim(self, z, deim_mat, sampled_rows):\n        \"\"\"\n        Run DEIM hyper-ROM evaluation on the test set.\n\n        Parameters\n        ----------\n        z : array_like\n            Weight vector stored on the instance.\n        deim_mat : ndarray\n            Interpolation matrix used by the DEIM workflow.\n        sampled_rows : array_like of int\n            Indices of sampled degrees of freedom.\n\n        Returns\n        -------\n        hyper_rom_error : list of float\n            Relative error values in percent.\n        hyper_speed_up : list of float\n            Time ratios for each test case.\n        \"\"\"\n        self.hyper_speed_up    = []\n        self.hyper_rom_error   = []\n        self.hyper_rom_solutions = []\n        # Store hyper-reduction parameters\n        self.z            = z\n        self.deim_mat   = deim_mat\n        self.sampled_rows = sampled_rows\n\n        for i, param in enumerate(self.param_list_test[:self.N_rom_snap]):\n            print(f\"Snap {i+1}/{len(self.param_list)} params={param}\")\n            self.cur_itr = i\n\n            # Time the hyper-ROM solve + reconstruction\n            t0 = time.perf_counter()\n            sol_red_ = self.hyper_rom_solver_deim(cls=self, param=param)\n\n            if len(self.test_ref.shape)==3:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref[i])\n            else:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref)\n\n            dt = time.perf_counter() - t0\n\n            # record speed-up and solution\n            self.hyper_speed_up.append(self.fos_test_time[i] / dt)\n            self.hyper_rom_solutions.append(sol_hyper.copy())\n\n            # compute and record error\n            sol_fos = self.fos_test_data[i]\n\n            if sol_hyper.shape != sol_fos.shape and sol_hyper.ndim == 2 and sol_hyper.T.shape == sol_fos.shape:\n                sol_hyper = sol_hyper.T\n\n            if sol_hyper.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyper.shape}\")\n            \n            \n            err = 100 * np.linalg.norm(sol_fos - sol_hyper) / np.linalg.norm(sol_fos)\n            self.hyper_rom_error.append(err)\n\n        return self.hyper_rom_error, self.hyper_speed_up"
  },
  {
    "objectID": "src/fom_init.html",
    "href": "src/fom_init.html",
    "title": "Finite‐element utilities for full‐order model (FOM) workflows",
    "section": "",
    "text": "Finite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "src/fom_init.html#fem_utils.py",
    "href": "src/fom_init.html#fem_utils.py",
    "title": "Finite‐element utilities for full‐order model (FOM) workflows",
    "section": "",
    "text": "Finite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "src/skrom_problem_classes_static_master_class_parallel.html",
    "href": "src/skrom_problem_classes_static_master_class_parallel.html",
    "title": "Parallel implementation of master_class using multithreading for snapshot generation and ROM evaluation",
    "section": "",
    "text": "Authors: Suparno Bhattacharyya\nfrom __future__ import annotations\n\nfrom pathlib import Path\nimport os\nimport sys\nimport time\nimport logging\nimport contextvars\nfrom contextlib import contextmanager\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, Dict, Type, Any, Optional, List\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport threading\nimport importlib\nimport traceback\nimport numpy as np\n\nfrom skrom.fom.fem_utils import unwrap_attr\nfrom skrom.rom.rom_utils import rom_data_gen, load_rom_data, reconstruct_solution\n\n\n# ─────────────────────────────────────────────────────────────\n# BASIC LOGGER (optional)\n# ─────────────────────────────────────────────────────────────\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s [%(levelname)s] %(message)s\")\nLOGGER = logging.getLogger(__name__)\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM DETECTION (keep your workflow; allow env override too)\n# ─────────────────────────────────────────────────────────────\ncwd = Path.cwd()\nPROBLEM = os.environ.get(\"SKROM_PROBLEM\", \"\").strip()\nif not PROBLEM:\n    if cwd.name.startswith(\"problem_\"):\n        PROBLEM = cwd.name\n    else:\n        raise ValueError(\n            \"Current directory must be named 'problem_X' where X can be a number/string, \"\n            \"or set env var SKROM_PROBLEM=problem_X.\"\n        )\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM REGISTRY AND INTERFACE\n# ─────────────────────────────────────────────────────────────\nclass Problem(ABC):\n    @abstractmethod\n    def domain(self): ...\n    @abstractmethod\n    def bilinear_forms(self): ...\n    @abstractmethod\n    def linear_forms(self): ...\n    @abstractmethod\n    def properties(self): ...\n    @abstractmethod\n    def parameters(self): ...\n    @abstractmethod\n    def fom_solver(self): ...\n    @abstractmethod\n    def rom_solver(self): ...\n    @abstractmethod\n    def hyper_rom_solver_deim(self): ...\n    @abstractmethod\n    def hyper_rom_solver_ecsw(self): ...\n\n\n# IMPORTANT: reuse shared registry if it exists (your problems likely register there)\n_USING_SHARED_REGISTRY = False\ntry:\n    import skrom.problem_classes.static.master_class as _mc\n    PROBLEM_REGISTRY = _mc.PROBLEM_REGISTRY  # shared dict reference\n    register_problem = _mc.register_problem  # shared decorator\n    _USING_SHARED_REGISTRY = True\nexcept Exception:\n    PROBLEM_REGISTRY: Dict[str, Type[Problem]] = {}\n    def register_problem(name: str):\n        def deco(cls: Type[Problem]) -&gt; Type[Problem]:\n            PROBLEM_REGISTRY[name] = cls\n            return cls\n        return deco\n\n\ndef _add_sys_path(p: Path) -&gt; None:\n    sp = str(p)\n    if sp and sp not in sys.path:\n        sys.path.insert(0, sp)\n\n\ndef _merge_registry_from_module(modname: str) -&gt; None:\n    \"\"\"Merge any PROBLEM_REGISTRY found in an imported module into ours.\"\"\"\n    mod = sys.modules.get(modname)\n    if mod is None:\n        return\n    reg = getattr(mod, \"PROBLEM_REGISTRY\", None)\n    if isinstance(reg, dict) and reg:\n        PROBLEM_REGISTRY.update(reg)  # if shared, updates master_class registry too\n\n\ndef ensure_problem_registered(problem_name: str) -&gt; None:\n    \"\"\"\n    Import the module that defines the problem (so @register_problem runs).\n\n    Supports:\n      - local file: ./problem_name.py  (when cwd is repo root OR problem folder)\n      - local package: ./problem_name/__init__.py\n      - package module: skrom.problem_classes.static.problem_name\n    \"\"\"\n    if problem_name in PROBLEM_REGISTRY:\n        return\n\n    cwd = Path.cwd()\n\n    # Make cwd and parent importable (covers running inside problem folder)\n    _add_sys_path(cwd)\n    _add_sys_path(cwd.parent)\n\n    attempted: List[str] = []\n    errors: List[str] = []\n\n    def _try(modname: str) -&gt; None:\n        attempted.append(modname)\n        try:\n            importlib.import_module(modname)\n            _merge_registry_from_module(modname)\n        except Exception as e:\n            errors.append(f\"{modname}: {type(e).__name__}: {e}\")\n\n    # 1) Try direct import by name (works if problem_name.py exists on sys.path,\n    #    or if problem_name is a package folder with __init__.py)\n    _try(problem_name)\n    if problem_name in PROBLEM_REGISTRY:\n        return\n\n    # 2) If cwd contains folder ./problem_name, try importing it as package\n    if (cwd / problem_name).is_dir():\n        _add_sys_path(cwd)\n        _try(problem_name)\n        if problem_name in PROBLEM_REGISTRY:\n            return\n\n    # 3) Try package namespace\n    _try(f\"skrom.problem_classes.static.{problem_name}\")\n    if problem_name in PROBLEM_REGISTRY:\n        return\n\n    raise ValueError(\n        f\"Problem '{problem_name}' not registered.\\n\"\n        f\"Registry keys currently visible: {list(PROBLEM_REGISTRY.keys())}\\n\"\n        f\"Using shared registry from master_class: {_USING_SHARED_REGISTRY}\\n\"\n        f\"Attempted imports: {attempted}\\n\"\n        \"Import errors:\\n  - \" + \"\\n  - \".join(errors)\n    )\n\n\ndef get_problem(name: str) -&gt; Problem:\n    ensure_problem_registered(name)\n    try:\n        return PROBLEM_REGISTRY[name]()\n    except KeyError:\n        raise ValueError(f\"Unknown problem '{name}'. Available problems: {list(PROBLEM_REGISTRY.keys())}\")\n\n\ndef assign_properties(prob: Problem) -&gt; Tuple:\n    parameters        = prob.parameters\n    a                 = prob.bilinear_forms()\n    l                 = prob.linear_forms()\n    domain_           = prob.domain\n    properties        = prob.properties()\n    fom_solver        = prob.fom_solver\n    rom_solver        = prob.rom_solver\n    hyper_deim_solver = prob.hyper_rom_solver_deim\n    hyper_ecsw_solver = prob.hyper_rom_solver_ecsw\n    return (\n        parameters, a, l, domain_, properties,\n        fom_solver, rom_solver, hyper_deim_solver, hyper_ecsw_solver\n    )\n\n\n# ─────────────────────────────────────────────────────────────\n# PARALLEL SWEEP CORE (THREADS ONLY)\n# ─────────────────────────────────────────────────────────────\nclass _ThreadedSweepMixin:\n    def __init__(self, logger: Optional[logging.Logger] = None):\n        self._cur_itr_var = contextvars.ContextVar(\"cur_itr\", default=None)\n        self._print_lock = threading.Lock()\n        self.logger = logger or LOGGER\n\n    @property\n    def cur_itr(self) -&gt; Optional[int]:\n        return self._cur_itr_var.get()\n\n    @cur_itr.setter\n    def cur_itr(self, v: int) -&gt; None:\n        self._cur_itr_var.set(v)\n\n    @contextmanager\n    def _set_cur_itr(self, v: int):\n        token = self._cur_itr_var.set(v)\n        try:\n            yield\n        finally:\n            self._cur_itr_var.reset(token)\n\n    @staticmethod\n    def _copy_solution(sol: Any) -&gt; Any:\n        if isinstance(sol, tuple):\n            return tuple(np.copy(x) if isinstance(x, np.ndarray) else x for x in sol)\n        if isinstance(sol, np.ndarray):\n            return np.copy(sol)\n        return sol\n\n    def _log(self, msg: str, level: int = logging.INFO, verbose: bool = True):\n        if not verbose:\n            return\n        with self._print_lock:\n            if self.logger is not None:\n                self.logger.log(level, msg)\n            else:\n                print(msg)\n\n\n    def _threaded_sweep(\n        self,\n        params: np.ndarray,\n        worker_fn,\n        *,\n        global_indices: Optional[np.ndarray] = None,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        label: str = \"Snap\",\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n    ) -&gt; Tuple[List[Any], List[float]]:\n        n = len(params)\n        if global_indices is None:\n            global_indices = np.arange(n, dtype=int)\n        else:\n            global_indices = np.asarray(global_indices, dtype=int)\n            if len(global_indices) != n:\n                raise ValueError(\"global_indices must have same length as params\")\n\n        outs: List[Any] = [None] * n\n        times: List[float] = [0.0] * n\n\n        def run_one(i_local: int):\n            i_global = int(global_indices[i_local])\n            param = params[i_local]\n            print(f\"Running {param=}\")\n\n            last_exc = None\n            for attempt in range(max_retries):\n                try:\n                    with self._set_cur_itr(i_local):\n                        t0 = time.perf_counter()\n                        out = worker_fn(param, i_local, i_global)\n                        dt = time.perf_counter() - t0\n                    return i_local, i_global, param, self._copy_solution(out), dt, None\n                except BaseException as e:\n                    last_exc = e\n                    if attempt &lt; max_retries - 1:\n                        time.sleep(retry_delay)\n\n            return i_local, i_global, param, None, 0.0, last_exc\n\n        # ---- Sequential ----\n        if not parallel:\n            for i_local in range(n):\n                iL, iG, p, out, dt, exc = run_one(i_local)\n                if exc is not None:\n                    self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} ERROR: {exc}\",\n                            logging.ERROR, verbose)\n                    if fail_fast:\n                        raise exc\n                else:\n                    outs[iL] = out\n                    times[iL] = dt\n                    self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} time={dt:.3f}s\",\n                            logging.INFO, verbose)\n            return outs, times\n\n        # ---- Parallel (collect results, then log in input order) ----\n        results: List[Optional[Tuple[int, np.ndarray, Any, float, Optional[BaseException]]]] = [None] * n\n\n        with ThreadPoolExecutor(max_workers=max_workers) as ex:\n            futs = [ex.submit(run_one, i_local) for i_local in range(n)]\n            try:\n                for fut in as_completed(futs):\n                    iL, iG, p, out, dt, exc = fut.result()\n                    if exc is not None and fail_fast:\n                        for f in futs:\n                            f.cancel()\n                        # log the failure once\n                        self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} ERROR: {exc}\",\n                                logging.ERROR, verbose)\n                        raise exc\n                    results[iL] = (iG, p, out, dt, exc)\n            except:\n                for f in futs:\n                    f.cancel()\n                raise\n\n        # emit logs in local index order + fill arrays in local index order\n        for iL in range(n):\n            iG, p, out, dt, exc = results[iL]  # type: ignore[misc]\n            if exc is not None:\n                self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} ERROR: {exc}\",\n                        logging.ERROR, verbose)\n            else:\n                outs[iL] = out\n                times[iL] = dt\n                self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} time={dt:.3f}s\",\n                        logging.INFO, verbose)\n\n        return outs, times\n\n# ─────────────────────────────────────────────────────────────\n# OFFLINE SNAPSHOT GENERATION\n# ─────────────────────────────────────────────────────────────\nimport os\nimport re\nimport json\nimport time\nimport hashlib\nimport tempfile\nfrom pathlib import Path\n\nimport numpy as np\n\n\nclass fom_simulation(_ThreadedSweepMixin):\n    def __init__(self, num_snapshots: int = 32, logger: Optional[logging.Logger] = None):\n        super().__init__(logger=logger)\n\n        prob = get_problem(PROBLEM)\n        (\n            self.parameters,\n            self.bilinear_forms,\n            self.linear_forms,\n            self.domain,\n            self.properties,\n            self.fom_solver,\n            *_,\n        ) = assign_properties(prob)\n\n        self._baseline_attrs = set(vars(self))\n\n        data = self.domain()\n        self.mesh = data[\"mesh\"]\n        self.basis = data[\"basis\"]\n\n        self.num_snapshots = num_snapshots\n        (\n            self.param_list,\n            self.param_range,\n            self.train_mask,\n            self.test_mask,\n        ) = self.parameters(num_snapshots)\n\n        self.fos_solutions: Any = []\n        self.fos_time: List[float] = []\n\n\n    def run_simulation(\n        self,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n    ) -&gt; None:\n        cur_dir = Path(os.getcwd())\n        ckpt_dir = cur_dir / \"fos_checkpoints\"\n        ckpt_dir.mkdir(parents=True, exist_ok=True)\n\n        def _problem_tag() -&gt; str:\n            return (\n                getattr(self, \"PROBLEM_NAME\", None)\n                or getattr(self, \"problem_name\", None)\n                or self.__class__.__name__\n            )\n\n        def _param_bytes(param) -&gt; bytes:\n            # numeric params -&gt; stable bytes; fallback -&gt; stable JSON bytes\n            try:\n                arr = np.asarray(param, dtype=float).ravel()\n                return arr.tobytes()\n            except Exception:\n                js = json.dumps(param, sort_keys=True, default=str)\n                return js.encode(\"utf-8\")\n\n        def _param_store(param):\n            # store param in file for inspection\n            try:\n                return np.asarray(param, dtype=float).ravel()\n            except Exception:\n                js = json.dumps(param, sort_keys=True, default=str)\n                return np.array([js], dtype=\"U\")\n\n        def _param_hash(param) -&gt; str:\n            return hashlib.sha1(_param_bytes(param)).hexdigest()[:16]\n\n        def _ckpt_path(param) -&gt; Path:\n            h = _param_hash(param)\n            # short filename to avoid Windows path issues\n            return ckpt_dir / f\"fos_{_problem_tag()}_h{h}.npz\"\n\n        def _atomic_save_npz(path: Path, payload: dict):\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n            # IMPORTANT: suffix \".npz\" so numpy does not append \".npz\" again\n            fd, tmp_path = tempfile.mkstemp(\n                dir=str(path.parent),\n                prefix=\"tmp_fos_\",\n                suffix=\".npz\",\n            )\n            os.close(fd)\n\n            try:\n                np.savez_compressed(tmp_path, **payload)\n                os.replace(tmp_path, str(path))\n            finally:\n                if os.path.exists(tmp_path):\n                    try:\n                        os.remove(tmp_path)\n                    except OSError:\n                        pass\n\n        def _save_solution(path: Path, sol, param, elapsed: float, snap_index: int):\n            payload = {\n                \"snap_index\": np.array([snap_index], dtype=np.int64),\n                \"solve_time\": np.array([elapsed], dtype=float),\n                \"param\": _param_store(param),\n            }\n\n            if isinstance(sol, tuple):\n                payload[\"nsol\"] = np.array([len(sol)], dtype=np.int32)\n                for j, x in enumerate(sol):\n                    payload[f\"sol{j}\"] = np.asarray(x)\n            else:\n                payload[\"nsol\"] = np.array([1], dtype=np.int32)\n                payload[\"sol0\"] = np.asarray(sol)\n\n            _atomic_save_npz(path, payload)\n\n        def _load_solution(path: Path):\n            with np.load(path, allow_pickle=False) as data:\n                nsol = int(data[\"nsol\"][0]) if \"nsol\" in data.files else 1\n                t = float(data[\"solve_time\"][0]) if \"solve_time\" in data.files else np.nan\n                if nsol == 1:\n                    sol = data[\"sol0\"]\n                else:\n                    sol = tuple(data[f\"sol{j}\"] for j in range(nsol))\n            return sol, t\n\n        def worker(param, i_local, i_global):\n            path = _ckpt_path(param)\n\n            # resume\n            if path.exists():\n                sol, t_saved = _load_solution(path)\n                return sol, t_saved\n\n            # compute + checkpoint\n            t0 = time.perf_counter()\n            sol = self.fom_solver(cls=self, param=param)\n            elapsed = time.perf_counter() - t0\n\n            _save_solution(path, sol, param, elapsed, snap_index=int(i_global))\n            return sol, elapsed\n\n        results, _times_measured = self._threaded_sweep(\n            self.param_list,\n            worker,\n            global_indices=np.arange(len(self.param_list)),\n            parallel=parallel,\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"FOM\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        if any(r is None for r in results):\n            bad = [i for i, r in enumerate(results) if r is None]\n            raise RuntimeError(f\"FOM had failed snapshots at indices: {bad}.\")\n\n        sols = [r[0] for r in results]\n        self.fos_time = [float(r[1]) for r in results]\n\n        if len(sols) == 0:\n            return\n\n        first = sols[0]\n        if isinstance(first, tuple):\n            self.fos_solutions = np.array(sols, dtype=object)\n\n            train_ids = np.where(self.train_mask)[0]\n            ncomp = len(first)\n            train_ref = []\n            for j in range(ncomp):\n                stack_j = np.stack([self.fos_solutions[k][j] for k in train_ids], axis=0)\n                train_ref.append(np.mean(stack_j, axis=0))\n            self.train_ref = tuple(train_ref)\n        else:\n            self.fos_solutions = np.asarray(sols)\n            self.train_ref = np.mean(self.fos_solutions[self.train_mask], axis=0)\n\n        new = set(vars(self)) - self._baseline_attrs\n        save_dict = {k: getattr(self, k) for k in new if not k.startswith(\"_\")}\n        rom_data_gen(save_dict, str(cur_dir))\n\n# ─────────────────────────────────────────────────────────────\n# ONLINE ROM EVALUATION\n# ─────────────────────────────────────────────────────────────\nclass rom_simulation(_ThreadedSweepMixin):\n    def __init__(\n        self,\n        train_ref=None, test_ref = None, fos_solutions=None,\n        train_mask=None, test_mask=None,\n        V_sel=None, n_sel=None, N_rom_snap=None,\n        logger: Optional[logging.Logger] = None,\n    ):\n        super().__init__(logger=logger)\n\n        prob = get_problem(PROBLEM)\n        (\n            self.parameters,\n            self.bilinear_forms,\n            self.linear_forms,\n            self.domain,\n            self.properties,\n            _,\n            self.rom_solver,\n            self.hyper_rom_solver_deim,\n            self.hyper_rom_solver_ecsw,\n        ) = assign_properties(prob)\n\n        cur_dir = os.getcwd()\n        rom_dir = os.path.join(cur_dir, \"ROM_data\")\n        load_rom_data(self, rom_dir)\n\n        if train_ref is not None:\n            self.train_ref = train_ref\n        if test_ref is not None:\n            self.test_ref = test_ref\n        if fos_solutions is not None:\n            self.fos_solutions = fos_solutions\n        if train_mask is not None:\n            self.train_mask = train_mask\n        if test_mask is not None:\n            self.test_mask = test_mask\n\n        self.param_list_test = self.param_list[self.test_mask]\n        self.fos_test_data   = self.fos_solutions[self.test_mask].astype(np.float32, copy=False)\n        self.fos_test_time   = np.asarray(self.fos_time)[self.test_mask]\n\n\n        self.sol_train_ms    = self.fos_solutions[self.train_mask].astype(np.float32, copy=False) - self.train_ref.astype(np.float32, copy=False)\n\n        self.V_sel      = V_sel\n        self.n_sel      = n_sel\n        self.N_rom_snap = N_rom_snap or len(self.param_list_test)\n\n        unwrap_attr(self, \"basis\")\n        unwrap_attr(self, \"mesh\")\n\n        self._test_global_idx = np.flatnonzero(self.test_mask)\n\n    def _ref_for(self, i_local_test: int, i_global_param: int):\n        if hasattr(self.test_ref, \"ndim\") and self.test_ref.ndim == 3:\n            if self.test_ref.shape[0] == len(self.param_list):\n                return self.test_ref[i_global_param]\n            if self.test_ref.shape[0] == len(self.param_list_test):\n                return self.test_ref[i_local_test]\n            return self.test_ref[i_local_test]\n        return self.test_ref\n\n    @staticmethod\n    def _maybe_transpose_like(sol_candidate: np.ndarray, sol_ref: np.ndarray) -&gt; np.ndarray:\n        if sol_candidate.shape != sol_ref.shape and sol_candidate.ndim == 2 and sol_candidate.T.shape == sol_ref.shape:\n            return sol_candidate.T\n        return sol_candidate\n\n\n    def _run_one_serial_with_retries(\n        self,\n        worker,\n        param,\n        i_local: int,\n        i_global: int,\n        *,\n        max_retries: int,\n        retry_delay: float,\n        fail_fast: bool,\n        label: str,\n        verbose: bool,\n    ):\n        last_exc = None\n        for attempt in range(max_retries + 1):\n            t0 = time.perf_counter()\n            try:\n                out = worker(param, i_local, i_global)\n                dt = time.perf_counter() - t0\n                if verbose:\n                    print(f\"[{label}] serial warm-up done (i={i_local}) in {dt:.3e}s\")\n                return out, dt\n            except Exception as e:\n                dt = time.perf_counter() - t0\n                last_exc = e\n                if self.logger is not None:\n                    self.logger.exception(\n                        f\"[{label}] serial warm-up failed (i={i_local}, attempt={attempt+1}/{max_retries+1})\"\n                    )\n                if verbose:\n                    print(f\"[{label}] serial warm-up failed (attempt {attempt+1}/{max_retries+1})\")\n                    traceback.print_exc()\n\n                if attempt &lt; max_retries:\n                    time.sleep(retry_delay)\n                    continue\n\n                if fail_fast:\n                    raise\n                return None, dt  # keep alignment; caller already handles outs[i] is None\n\n        if fail_fast and last_exc is not None:\n            raise last_exc\n        return None, 0.0\n\n    def _threaded_sweep_serial_first(\n        self,\n        params,\n        worker,\n        *,\n        global_indices,\n        parallel: bool,\n        serial_first: bool,\n        max_workers,\n        verbose: bool,\n        label: str,\n        max_retries: int,\n        retry_delay: float,\n        fail_fast: bool,\n    ):\n        n = len(params)\n        if n == 0:\n            return [], []\n\n        # default: your existing behavior\n        if (not parallel) or (not serial_first) or (n == 1):\n            return self._threaded_sweep(\n                params,\n                worker,\n                global_indices=global_indices,\n                parallel=parallel,\n                max_workers=max_workers,\n                verbose=verbose,\n                label=label,\n                max_retries=max_retries,\n                retry_delay=retry_delay,\n                fail_fast=fail_fast,\n            )\n\n        # allocate full outputs\n        outs = [None] * n\n        times = [0.0] * n\n\n        # 1) run first item serially in the main thread\n        outs[0], times[0] = self._run_one_serial_with_retries(\n            worker,\n            params[0],\n            0,\n            global_indices[0],\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n            label=label,\n            verbose=verbose,\n        )\n\n        # 2) run the remaining items with your threaded sweep\n        def worker_rest(param, i_local_rest, i_global_rest):\n            # IMPORTANT: shift local index by +1 to keep alignment with fos_test_data\n            return worker(param, i_local_rest + 1, i_global_rest)\n\n        outs_rest, times_rest = self._threaded_sweep(\n            params[1:],\n            worker_rest,\n            global_indices=global_indices[1:],\n            parallel=True,  # force parallel for the remainder\n            max_workers=max_workers,\n            verbose=verbose,\n            label=label,\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        outs[1:] = outs_rest\n        times[1:] = times_rest\n        return outs, times\n\n\n    def run_rom_simulation(\n        self,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n        serial_first: bool = False,   # &lt;-- add this\n    ):\n        self.speed_up      = []\n        self.rom_error     = []\n        self.rom_solutions = []\n\n        n = min(self.N_rom_snap, len(self.param_list_test))\n        params = self.param_list_test[:n]\n        global_idx = self._test_global_idx[:n]\n\n        def worker(param, i_local, i_global):\n            self.cur_itr = i_local\n            sol_red_ = self.rom_solver(cls=self, param=param)\n            sol_rom = reconstruct_solution(sol_red_, self.V_sel, self._ref_for(i_local, i_global))\n\n            sol_fos = self.fos_test_data[i_local]  # FIX\n            sol_rom = self._maybe_transpose_like(sol_rom, sol_fos)\n            if sol_rom.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, rom{sol_rom.shape}\")\n\n            err = 100.0 * np.linalg.norm(sol_fos - sol_rom) / np.linalg.norm(sol_fos)\n            return sol_rom.copy(), float(err)\n\n        outs, times = self._threaded_sweep_serial_first(\n            params,\n            worker,\n            global_indices=global_idx,\n            parallel=parallel,\n            serial_first=serial_first,     # &lt;-- use it\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"ROM\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        rom_solutions: List[np.ndarray] = [None] * n  # type: ignore\n        rom_error: List[float] = [np.nan] * n\n        speed_up: List[float] = [np.nan] * n\n\n        for i in range(n):\n            if outs[i] is None:\n                continue\n            sol_rom, err = outs[i]\n            rom_solutions[i] = sol_rom\n            rom_error[i] = err\n            speed_up[i] = float(self.fos_test_time[i] / times[i]) if times[i] &gt; 0 else np.nan\n\n        self.rom_solutions = rom_solutions\n        self.rom_error = rom_error\n        self.speed_up = speed_up\n        return self.rom_error, self.speed_up\n\n    def run_hyper_rom_simulation_ecsw(\n        self,\n        z,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n        serial_first: bool = False,   # &lt;-- add this\n    ):\n        self.hyper_speed_up      = []\n        self.hyper_rom_error     = []\n        self.hyper_rom_solutions = []\n        self.z = z\n\n        n = min(self.N_rom_snap, len(self.param_list_test))\n        params = self.param_list_test[:n]\n        global_idx = self._test_global_idx[:n]\n\n        def worker(param, i_local, i_global):\n            self.cur_itr = i_local\n            sol_red_ = self.hyper_rom_solver_ecsw(cls=self, param=param)\n            sol_hyp = reconstruct_solution(sol_red_, self.V_sel, self._ref_for(i_local, i_global))\n\n            sol_fos = self.fos_test_data[i_local]\n            sol_hyp = self._maybe_transpose_like(sol_hyp, sol_fos)\n            if sol_hyp.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyp.shape}\")\n\n            err = 100.0 * np.linalg.norm(sol_fos - sol_hyp) / np.linalg.norm(sol_fos)\n            return sol_hyp.copy(), float(err)\n\n        outs, times = self._threaded_sweep_serial_first(\n            params,\n            worker,\n            global_indices=global_idx,\n            parallel=parallel,\n            serial_first=serial_first,\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"ECSW\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        hyp_solutions: List[np.ndarray] = [None] * n  # type: ignore\n        hyp_error: List[float] = [np.nan] * n\n        hyp_speed: List[float] = [np.nan] * n\n\n        for i in range(n):\n            if outs[i] is None:\n                continue\n            sol_hyp, err = outs[i]\n            hyp_solutions[i] = sol_hyp\n            hyp_error[i] = err\n            hyp_speed[i] = float(self.fos_test_time[i] / times[i]) if times[i] &gt; 0 else np.nan\n\n        self.hyper_rom_solutions = hyp_solutions\n        self.hyper_rom_error = hyp_error\n        self.hyper_speed_up = hyp_speed\n        return self.hyper_rom_error, self.hyper_speed_up\n\n    def run_hyper_rom_simulation_deim(\n        self,\n        z,\n        deim_mat,\n        sampled_rows,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n        serial_first: bool = False,   # &lt;-- add this\n    ):\n        self.hyper_speed_up      = []\n        self.hyper_rom_error     = []\n        self.hyper_rom_solutions = []\n        self.z = z\n        self.deim_mat = deim_mat\n        self.sampled_rows = sampled_rows\n\n        n = min(self.N_rom_snap, len(self.param_list_test))\n        params = self.param_list_test[:n]\n        global_idx = self._test_global_idx[:n]\n\n        def worker(param, i_local, i_global):\n            self.cur_itr = i_local\n            sol_red_ = self.hyper_rom_solver_deim(cls=self, param=param)\n\n            # FIX: reconstruct once\n            sol_hyp = reconstruct_solution(sol_red_, self.V_sel, self._ref_for(i_local, i_global))\n\n            sol_fos = self.fos_test_data[i_local]\n            sol_hyp = self._maybe_transpose_like(sol_hyp, sol_fos)\n            if sol_hyp.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyp.shape}\")\n\n            err = 100.0 * np.linalg.norm(sol_fos - sol_hyp) / np.linalg.norm(sol_fos)\n            return sol_hyp.copy(), float(err)\n\n        outs, times = self._threaded_sweep_serial_first(\n            params,\n            worker,\n            global_indices=global_idx,\n            parallel=parallel,\n            serial_first=serial_first,\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"DEIM\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        hyp_solutions: List[np.ndarray] = [None] * n  # type: ignore\n        hyp_error: List[float] = [np.nan] * n\n        hyp_speed: List[float] = [np.nan] * n\n\n        for i in range(n):\n            if outs[i] is None:\n                continue\n            sol_hyp, err = outs[i]\n            hyp_solutions[i] = sol_hyp\n            hyp_error[i] = err\n            hyp_speed[i] = float(self.fos_test_time[i] / times[i]) if times[i] &gt; 0 else np.nan\n\n        self.hyper_rom_solutions = hyp_solutions\n        self.hyper_rom_error = hyp_error\n        self.hyper_speed_up = hyp_speed\n        return self.hyper_rom_error, self.hyper_speed_up"
  },
  {
    "objectID": "src/skrom_problem_classes_static_master_class_parallel.html#notes",
    "href": "src/skrom_problem_classes_static_master_class_parallel.html#notes",
    "title": "Parallel implementation of master_class using multithreading for snapshot generation and ROM evaluation",
    "section": "",
    "text": "Authors: Suparno Bhattacharyya\nfrom __future__ import annotations\n\nfrom pathlib import Path\nimport os\nimport sys\nimport time\nimport logging\nimport contextvars\nfrom contextlib import contextmanager\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, Dict, Type, Any, Optional, List\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport threading\nimport importlib\nimport traceback\nimport numpy as np\n\nfrom skrom.fom.fem_utils import unwrap_attr\nfrom skrom.rom.rom_utils import rom_data_gen, load_rom_data, reconstruct_solution\n\n\n# ─────────────────────────────────────────────────────────────\n# BASIC LOGGER (optional)\n# ─────────────────────────────────────────────────────────────\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s [%(levelname)s] %(message)s\")\nLOGGER = logging.getLogger(__name__)\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM DETECTION (keep your workflow; allow env override too)\n# ─────────────────────────────────────────────────────────────\ncwd = Path.cwd()\nPROBLEM = os.environ.get(\"SKROM_PROBLEM\", \"\").strip()\nif not PROBLEM:\n    if cwd.name.startswith(\"problem_\"):\n        PROBLEM = cwd.name\n    else:\n        raise ValueError(\n            \"Current directory must be named 'problem_X' where X can be a number/string, \"\n            \"or set env var SKROM_PROBLEM=problem_X.\"\n        )\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM REGISTRY AND INTERFACE\n# ─────────────────────────────────────────────────────────────\nclass Problem(ABC):\n    @abstractmethod\n    def domain(self): ...\n    @abstractmethod\n    def bilinear_forms(self): ...\n    @abstractmethod\n    def linear_forms(self): ...\n    @abstractmethod\n    def properties(self): ...\n    @abstractmethod\n    def parameters(self): ...\n    @abstractmethod\n    def fom_solver(self): ...\n    @abstractmethod\n    def rom_solver(self): ...\n    @abstractmethod\n    def hyper_rom_solver_deim(self): ...\n    @abstractmethod\n    def hyper_rom_solver_ecsw(self): ...\n\n\n# IMPORTANT: reuse shared registry if it exists (your problems likely register there)\n_USING_SHARED_REGISTRY = False\ntry:\n    import skrom.problem_classes.static.master_class as _mc\n    PROBLEM_REGISTRY = _mc.PROBLEM_REGISTRY  # shared dict reference\n    register_problem = _mc.register_problem  # shared decorator\n    _USING_SHARED_REGISTRY = True\nexcept Exception:\n    PROBLEM_REGISTRY: Dict[str, Type[Problem]] = {}\n    def register_problem(name: str):\n        def deco(cls: Type[Problem]) -&gt; Type[Problem]:\n            PROBLEM_REGISTRY[name] = cls\n            return cls\n        return deco\n\n\ndef _add_sys_path(p: Path) -&gt; None:\n    sp = str(p)\n    if sp and sp not in sys.path:\n        sys.path.insert(0, sp)\n\n\ndef _merge_registry_from_module(modname: str) -&gt; None:\n    \"\"\"Merge any PROBLEM_REGISTRY found in an imported module into ours.\"\"\"\n    mod = sys.modules.get(modname)\n    if mod is None:\n        return\n    reg = getattr(mod, \"PROBLEM_REGISTRY\", None)\n    if isinstance(reg, dict) and reg:\n        PROBLEM_REGISTRY.update(reg)  # if shared, updates master_class registry too\n\n\ndef ensure_problem_registered(problem_name: str) -&gt; None:\n    \"\"\"\n    Import the module that defines the problem (so @register_problem runs).\n\n    Supports:\n      - local file: ./problem_name.py  (when cwd is repo root OR problem folder)\n      - local package: ./problem_name/__init__.py\n      - package module: skrom.problem_classes.static.problem_name\n    \"\"\"\n    if problem_name in PROBLEM_REGISTRY:\n        return\n\n    cwd = Path.cwd()\n\n    # Make cwd and parent importable (covers running inside problem folder)\n    _add_sys_path(cwd)\n    _add_sys_path(cwd.parent)\n\n    attempted: List[str] = []\n    errors: List[str] = []\n\n    def _try(modname: str) -&gt; None:\n        attempted.append(modname)\n        try:\n            importlib.import_module(modname)\n            _merge_registry_from_module(modname)\n        except Exception as e:\n            errors.append(f\"{modname}: {type(e).__name__}: {e}\")\n\n    # 1) Try direct import by name (works if problem_name.py exists on sys.path,\n    #    or if problem_name is a package folder with __init__.py)\n    _try(problem_name)\n    if problem_name in PROBLEM_REGISTRY:\n        return\n\n    # 2) If cwd contains folder ./problem_name, try importing it as package\n    if (cwd / problem_name).is_dir():\n        _add_sys_path(cwd)\n        _try(problem_name)\n        if problem_name in PROBLEM_REGISTRY:\n            return\n\n    # 3) Try package namespace\n    _try(f\"skrom.problem_classes.static.{problem_name}\")\n    if problem_name in PROBLEM_REGISTRY:\n        return\n\n    raise ValueError(\n        f\"Problem '{problem_name}' not registered.\\n\"\n        f\"Registry keys currently visible: {list(PROBLEM_REGISTRY.keys())}\\n\"\n        f\"Using shared registry from master_class: {_USING_SHARED_REGISTRY}\\n\"\n        f\"Attempted imports: {attempted}\\n\"\n        \"Import errors:\\n  - \" + \"\\n  - \".join(errors)\n    )\n\n\ndef get_problem(name: str) -&gt; Problem:\n    ensure_problem_registered(name)\n    try:\n        return PROBLEM_REGISTRY[name]()\n    except KeyError:\n        raise ValueError(f\"Unknown problem '{name}'. Available problems: {list(PROBLEM_REGISTRY.keys())}\")\n\n\ndef assign_properties(prob: Problem) -&gt; Tuple:\n    parameters        = prob.parameters\n    a                 = prob.bilinear_forms()\n    l                 = prob.linear_forms()\n    domain_           = prob.domain\n    properties        = prob.properties()\n    fom_solver        = prob.fom_solver\n    rom_solver        = prob.rom_solver\n    hyper_deim_solver = prob.hyper_rom_solver_deim\n    hyper_ecsw_solver = prob.hyper_rom_solver_ecsw\n    return (\n        parameters, a, l, domain_, properties,\n        fom_solver, rom_solver, hyper_deim_solver, hyper_ecsw_solver\n    )\n\n\n# ─────────────────────────────────────────────────────────────\n# PARALLEL SWEEP CORE (THREADS ONLY)\n# ─────────────────────────────────────────────────────────────\nclass _ThreadedSweepMixin:\n    def __init__(self, logger: Optional[logging.Logger] = None):\n        self._cur_itr_var = contextvars.ContextVar(\"cur_itr\", default=None)\n        self._print_lock = threading.Lock()\n        self.logger = logger or LOGGER\n\n    @property\n    def cur_itr(self) -&gt; Optional[int]:\n        return self._cur_itr_var.get()\n\n    @cur_itr.setter\n    def cur_itr(self, v: int) -&gt; None:\n        self._cur_itr_var.set(v)\n\n    @contextmanager\n    def _set_cur_itr(self, v: int):\n        token = self._cur_itr_var.set(v)\n        try:\n            yield\n        finally:\n            self._cur_itr_var.reset(token)\n\n    @staticmethod\n    def _copy_solution(sol: Any) -&gt; Any:\n        if isinstance(sol, tuple):\n            return tuple(np.copy(x) if isinstance(x, np.ndarray) else x for x in sol)\n        if isinstance(sol, np.ndarray):\n            return np.copy(sol)\n        return sol\n\n    def _log(self, msg: str, level: int = logging.INFO, verbose: bool = True):\n        if not verbose:\n            return\n        with self._print_lock:\n            if self.logger is not None:\n                self.logger.log(level, msg)\n            else:\n                print(msg)\n\n\n    def _threaded_sweep(\n        self,\n        params: np.ndarray,\n        worker_fn,\n        *,\n        global_indices: Optional[np.ndarray] = None,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        label: str = \"Snap\",\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n    ) -&gt; Tuple[List[Any], List[float]]:\n        n = len(params)\n        if global_indices is None:\n            global_indices = np.arange(n, dtype=int)\n        else:\n            global_indices = np.asarray(global_indices, dtype=int)\n            if len(global_indices) != n:\n                raise ValueError(\"global_indices must have same length as params\")\n\n        outs: List[Any] = [None] * n\n        times: List[float] = [0.0] * n\n\n        def run_one(i_local: int):\n            i_global = int(global_indices[i_local])\n            param = params[i_local]\n            print(f\"Running {param=}\")\n\n            last_exc = None\n            for attempt in range(max_retries):\n                try:\n                    with self._set_cur_itr(i_local):\n                        t0 = time.perf_counter()\n                        out = worker_fn(param, i_local, i_global)\n                        dt = time.perf_counter() - t0\n                    return i_local, i_global, param, self._copy_solution(out), dt, None\n                except BaseException as e:\n                    last_exc = e\n                    if attempt &lt; max_retries - 1:\n                        time.sleep(retry_delay)\n\n            return i_local, i_global, param, None, 0.0, last_exc\n\n        # ---- Sequential ----\n        if not parallel:\n            for i_local in range(n):\n                iL, iG, p, out, dt, exc = run_one(i_local)\n                if exc is not None:\n                    self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} ERROR: {exc}\",\n                            logging.ERROR, verbose)\n                    if fail_fast:\n                        raise exc\n                else:\n                    outs[iL] = out\n                    times[iL] = dt\n                    self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} time={dt:.3f}s\",\n                            logging.INFO, verbose)\n            return outs, times\n\n        # ---- Parallel (collect results, then log in input order) ----\n        results: List[Optional[Tuple[int, np.ndarray, Any, float, Optional[BaseException]]]] = [None] * n\n\n        with ThreadPoolExecutor(max_workers=max_workers) as ex:\n            futs = [ex.submit(run_one, i_local) for i_local in range(n)]\n            try:\n                for fut in as_completed(futs):\n                    iL, iG, p, out, dt, exc = fut.result()\n                    if exc is not None and fail_fast:\n                        for f in futs:\n                            f.cancel()\n                        # log the failure once\n                        self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} ERROR: {exc}\",\n                                logging.ERROR, verbose)\n                        raise exc\n                    results[iL] = (iG, p, out, dt, exc)\n            except:\n                for f in futs:\n                    f.cancel()\n                raise\n\n        # emit logs in local index order + fill arrays in local index order\n        for iL in range(n):\n            iG, p, out, dt, exc = results[iL]  # type: ignore[misc]\n            if exc is not None:\n                self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} ERROR: {exc}\",\n                        logging.ERROR, verbose)\n            else:\n                outs[iL] = out\n                times[iL] = dt\n                self._log(f\"{label} {iL+1}/{n} (global={iG}) params={p} time={dt:.3f}s\",\n                        logging.INFO, verbose)\n\n        return outs, times\n\n# ─────────────────────────────────────────────────────────────\n# OFFLINE SNAPSHOT GENERATION\n# ─────────────────────────────────────────────────────────────\nimport os\nimport re\nimport json\nimport time\nimport hashlib\nimport tempfile\nfrom pathlib import Path\n\nimport numpy as np\n\n\nclass fom_simulation(_ThreadedSweepMixin):\n    def __init__(self, num_snapshots: int = 32, logger: Optional[logging.Logger] = None):\n        super().__init__(logger=logger)\n\n        prob = get_problem(PROBLEM)\n        (\n            self.parameters,\n            self.bilinear_forms,\n            self.linear_forms,\n            self.domain,\n            self.properties,\n            self.fom_solver,\n            *_,\n        ) = assign_properties(prob)\n\n        self._baseline_attrs = set(vars(self))\n\n        data = self.domain()\n        self.mesh = data[\"mesh\"]\n        self.basis = data[\"basis\"]\n\n        self.num_snapshots = num_snapshots\n        (\n            self.param_list,\n            self.param_range,\n            self.train_mask,\n            self.test_mask,\n        ) = self.parameters(num_snapshots)\n\n        self.fos_solutions: Any = []\n        self.fos_time: List[float] = []\n\n\n    def run_simulation(\n        self,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n    ) -&gt; None:\n        cur_dir = Path(os.getcwd())\n        ckpt_dir = cur_dir / \"fos_checkpoints\"\n        ckpt_dir.mkdir(parents=True, exist_ok=True)\n\n        def _problem_tag() -&gt; str:\n            return (\n                getattr(self, \"PROBLEM_NAME\", None)\n                or getattr(self, \"problem_name\", None)\n                or self.__class__.__name__\n            )\n\n        def _param_bytes(param) -&gt; bytes:\n            # numeric params -&gt; stable bytes; fallback -&gt; stable JSON bytes\n            try:\n                arr = np.asarray(param, dtype=float).ravel()\n                return arr.tobytes()\n            except Exception:\n                js = json.dumps(param, sort_keys=True, default=str)\n                return js.encode(\"utf-8\")\n\n        def _param_store(param):\n            # store param in file for inspection\n            try:\n                return np.asarray(param, dtype=float).ravel()\n            except Exception:\n                js = json.dumps(param, sort_keys=True, default=str)\n                return np.array([js], dtype=\"U\")\n\n        def _param_hash(param) -&gt; str:\n            return hashlib.sha1(_param_bytes(param)).hexdigest()[:16]\n\n        def _ckpt_path(param) -&gt; Path:\n            h = _param_hash(param)\n            # short filename to avoid Windows path issues\n            return ckpt_dir / f\"fos_{_problem_tag()}_h{h}.npz\"\n\n        def _atomic_save_npz(path: Path, payload: dict):\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n            # IMPORTANT: suffix \".npz\" so numpy does not append \".npz\" again\n            fd, tmp_path = tempfile.mkstemp(\n                dir=str(path.parent),\n                prefix=\"tmp_fos_\",\n                suffix=\".npz\",\n            )\n            os.close(fd)\n\n            try:\n                np.savez_compressed(tmp_path, **payload)\n                os.replace(tmp_path, str(path))\n            finally:\n                if os.path.exists(tmp_path):\n                    try:\n                        os.remove(tmp_path)\n                    except OSError:\n                        pass\n\n        def _save_solution(path: Path, sol, param, elapsed: float, snap_index: int):\n            payload = {\n                \"snap_index\": np.array([snap_index], dtype=np.int64),\n                \"solve_time\": np.array([elapsed], dtype=float),\n                \"param\": _param_store(param),\n            }\n\n            if isinstance(sol, tuple):\n                payload[\"nsol\"] = np.array([len(sol)], dtype=np.int32)\n                for j, x in enumerate(sol):\n                    payload[f\"sol{j}\"] = np.asarray(x)\n            else:\n                payload[\"nsol\"] = np.array([1], dtype=np.int32)\n                payload[\"sol0\"] = np.asarray(sol)\n\n            _atomic_save_npz(path, payload)\n\n        def _load_solution(path: Path):\n            with np.load(path, allow_pickle=False) as data:\n                nsol = int(data[\"nsol\"][0]) if \"nsol\" in data.files else 1\n                t = float(data[\"solve_time\"][0]) if \"solve_time\" in data.files else np.nan\n                if nsol == 1:\n                    sol = data[\"sol0\"]\n                else:\n                    sol = tuple(data[f\"sol{j}\"] for j in range(nsol))\n            return sol, t\n\n        def worker(param, i_local, i_global):\n            path = _ckpt_path(param)\n\n            # resume\n            if path.exists():\n                sol, t_saved = _load_solution(path)\n                return sol, t_saved\n\n            # compute + checkpoint\n            t0 = time.perf_counter()\n            sol = self.fom_solver(cls=self, param=param)\n            elapsed = time.perf_counter() - t0\n\n            _save_solution(path, sol, param, elapsed, snap_index=int(i_global))\n            return sol, elapsed\n\n        results, _times_measured = self._threaded_sweep(\n            self.param_list,\n            worker,\n            global_indices=np.arange(len(self.param_list)),\n            parallel=parallel,\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"FOM\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        if any(r is None for r in results):\n            bad = [i for i, r in enumerate(results) if r is None]\n            raise RuntimeError(f\"FOM had failed snapshots at indices: {bad}.\")\n\n        sols = [r[0] for r in results]\n        self.fos_time = [float(r[1]) for r in results]\n\n        if len(sols) == 0:\n            return\n\n        first = sols[0]\n        if isinstance(first, tuple):\n            self.fos_solutions = np.array(sols, dtype=object)\n\n            train_ids = np.where(self.train_mask)[0]\n            ncomp = len(first)\n            train_ref = []\n            for j in range(ncomp):\n                stack_j = np.stack([self.fos_solutions[k][j] for k in train_ids], axis=0)\n                train_ref.append(np.mean(stack_j, axis=0))\n            self.train_ref = tuple(train_ref)\n        else:\n            self.fos_solutions = np.asarray(sols)\n            self.train_ref = np.mean(self.fos_solutions[self.train_mask], axis=0)\n\n        new = set(vars(self)) - self._baseline_attrs\n        save_dict = {k: getattr(self, k) for k in new if not k.startswith(\"_\")}\n        rom_data_gen(save_dict, str(cur_dir))\n\n# ─────────────────────────────────────────────────────────────\n# ONLINE ROM EVALUATION\n# ─────────────────────────────────────────────────────────────\nclass rom_simulation(_ThreadedSweepMixin):\n    def __init__(\n        self,\n        train_ref=None, test_ref = None, fos_solutions=None,\n        train_mask=None, test_mask=None,\n        V_sel=None, n_sel=None, N_rom_snap=None,\n        logger: Optional[logging.Logger] = None,\n    ):\n        super().__init__(logger=logger)\n\n        prob = get_problem(PROBLEM)\n        (\n            self.parameters,\n            self.bilinear_forms,\n            self.linear_forms,\n            self.domain,\n            self.properties,\n            _,\n            self.rom_solver,\n            self.hyper_rom_solver_deim,\n            self.hyper_rom_solver_ecsw,\n        ) = assign_properties(prob)\n\n        cur_dir = os.getcwd()\n        rom_dir = os.path.join(cur_dir, \"ROM_data\")\n        load_rom_data(self, rom_dir)\n\n        if train_ref is not None:\n            self.train_ref = train_ref\n        if test_ref is not None:\n            self.test_ref = test_ref\n        if fos_solutions is not None:\n            self.fos_solutions = fos_solutions\n        if train_mask is not None:\n            self.train_mask = train_mask\n        if test_mask is not None:\n            self.test_mask = test_mask\n\n        self.param_list_test = self.param_list[self.test_mask]\n        self.fos_test_data   = self.fos_solutions[self.test_mask].astype(np.float32, copy=False)\n        self.fos_test_time   = np.asarray(self.fos_time)[self.test_mask]\n\n\n        self.sol_train_ms    = self.fos_solutions[self.train_mask].astype(np.float32, copy=False) - self.train_ref.astype(np.float32, copy=False)\n\n        self.V_sel      = V_sel\n        self.n_sel      = n_sel\n        self.N_rom_snap = N_rom_snap or len(self.param_list_test)\n\n        unwrap_attr(self, \"basis\")\n        unwrap_attr(self, \"mesh\")\n\n        self._test_global_idx = np.flatnonzero(self.test_mask)\n\n    def _ref_for(self, i_local_test: int, i_global_param: int):\n        if hasattr(self.test_ref, \"ndim\") and self.test_ref.ndim == 3:\n            if self.test_ref.shape[0] == len(self.param_list):\n                return self.test_ref[i_global_param]\n            if self.test_ref.shape[0] == len(self.param_list_test):\n                return self.test_ref[i_local_test]\n            return self.test_ref[i_local_test]\n        return self.test_ref\n\n    @staticmethod\n    def _maybe_transpose_like(sol_candidate: np.ndarray, sol_ref: np.ndarray) -&gt; np.ndarray:\n        if sol_candidate.shape != sol_ref.shape and sol_candidate.ndim == 2 and sol_candidate.T.shape == sol_ref.shape:\n            return sol_candidate.T\n        return sol_candidate\n\n\n    def _run_one_serial_with_retries(\n        self,\n        worker,\n        param,\n        i_local: int,\n        i_global: int,\n        *,\n        max_retries: int,\n        retry_delay: float,\n        fail_fast: bool,\n        label: str,\n        verbose: bool,\n    ):\n        last_exc = None\n        for attempt in range(max_retries + 1):\n            t0 = time.perf_counter()\n            try:\n                out = worker(param, i_local, i_global)\n                dt = time.perf_counter() - t0\n                if verbose:\n                    print(f\"[{label}] serial warm-up done (i={i_local}) in {dt:.3e}s\")\n                return out, dt\n            except Exception as e:\n                dt = time.perf_counter() - t0\n                last_exc = e\n                if self.logger is not None:\n                    self.logger.exception(\n                        f\"[{label}] serial warm-up failed (i={i_local}, attempt={attempt+1}/{max_retries+1})\"\n                    )\n                if verbose:\n                    print(f\"[{label}] serial warm-up failed (attempt {attempt+1}/{max_retries+1})\")\n                    traceback.print_exc()\n\n                if attempt &lt; max_retries:\n                    time.sleep(retry_delay)\n                    continue\n\n                if fail_fast:\n                    raise\n                return None, dt  # keep alignment; caller already handles outs[i] is None\n\n        if fail_fast and last_exc is not None:\n            raise last_exc\n        return None, 0.0\n\n    def _threaded_sweep_serial_first(\n        self,\n        params,\n        worker,\n        *,\n        global_indices,\n        parallel: bool,\n        serial_first: bool,\n        max_workers,\n        verbose: bool,\n        label: str,\n        max_retries: int,\n        retry_delay: float,\n        fail_fast: bool,\n    ):\n        n = len(params)\n        if n == 0:\n            return [], []\n\n        # default: your existing behavior\n        if (not parallel) or (not serial_first) or (n == 1):\n            return self._threaded_sweep(\n                params,\n                worker,\n                global_indices=global_indices,\n                parallel=parallel,\n                max_workers=max_workers,\n                verbose=verbose,\n                label=label,\n                max_retries=max_retries,\n                retry_delay=retry_delay,\n                fail_fast=fail_fast,\n            )\n\n        # allocate full outputs\n        outs = [None] * n\n        times = [0.0] * n\n\n        # 1) run first item serially in the main thread\n        outs[0], times[0] = self._run_one_serial_with_retries(\n            worker,\n            params[0],\n            0,\n            global_indices[0],\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n            label=label,\n            verbose=verbose,\n        )\n\n        # 2) run the remaining items with your threaded sweep\n        def worker_rest(param, i_local_rest, i_global_rest):\n            # IMPORTANT: shift local index by +1 to keep alignment with fos_test_data\n            return worker(param, i_local_rest + 1, i_global_rest)\n\n        outs_rest, times_rest = self._threaded_sweep(\n            params[1:],\n            worker_rest,\n            global_indices=global_indices[1:],\n            parallel=True,  # force parallel for the remainder\n            max_workers=max_workers,\n            verbose=verbose,\n            label=label,\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        outs[1:] = outs_rest\n        times[1:] = times_rest\n        return outs, times\n\n\n    def run_rom_simulation(\n        self,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n        serial_first: bool = False,   # &lt;-- add this\n    ):\n        self.speed_up      = []\n        self.rom_error     = []\n        self.rom_solutions = []\n\n        n = min(self.N_rom_snap, len(self.param_list_test))\n        params = self.param_list_test[:n]\n        global_idx = self._test_global_idx[:n]\n\n        def worker(param, i_local, i_global):\n            self.cur_itr = i_local\n            sol_red_ = self.rom_solver(cls=self, param=param)\n            sol_rom = reconstruct_solution(sol_red_, self.V_sel, self._ref_for(i_local, i_global))\n\n            sol_fos = self.fos_test_data[i_local]  # FIX\n            sol_rom = self._maybe_transpose_like(sol_rom, sol_fos)\n            if sol_rom.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, rom{sol_rom.shape}\")\n\n            err = 100.0 * np.linalg.norm(sol_fos - sol_rom) / np.linalg.norm(sol_fos)\n            return sol_rom.copy(), float(err)\n\n        outs, times = self._threaded_sweep_serial_first(\n            params,\n            worker,\n            global_indices=global_idx,\n            parallel=parallel,\n            serial_first=serial_first,     # &lt;-- use it\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"ROM\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        rom_solutions: List[np.ndarray] = [None] * n  # type: ignore\n        rom_error: List[float] = [np.nan] * n\n        speed_up: List[float] = [np.nan] * n\n\n        for i in range(n):\n            if outs[i] is None:\n                continue\n            sol_rom, err = outs[i]\n            rom_solutions[i] = sol_rom\n            rom_error[i] = err\n            speed_up[i] = float(self.fos_test_time[i] / times[i]) if times[i] &gt; 0 else np.nan\n\n        self.rom_solutions = rom_solutions\n        self.rom_error = rom_error\n        self.speed_up = speed_up\n        return self.rom_error, self.speed_up\n\n    def run_hyper_rom_simulation_ecsw(\n        self,\n        z,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n        serial_first: bool = False,   # &lt;-- add this\n    ):\n        self.hyper_speed_up      = []\n        self.hyper_rom_error     = []\n        self.hyper_rom_solutions = []\n        self.z = z\n\n        n = min(self.N_rom_snap, len(self.param_list_test))\n        params = self.param_list_test[:n]\n        global_idx = self._test_global_idx[:n]\n\n        def worker(param, i_local, i_global):\n            self.cur_itr = i_local\n            sol_red_ = self.hyper_rom_solver_ecsw(cls=self, param=param)\n            sol_hyp = reconstruct_solution(sol_red_, self.V_sel, self._ref_for(i_local, i_global))\n\n            sol_fos = self.fos_test_data[i_local]\n            sol_hyp = self._maybe_transpose_like(sol_hyp, sol_fos)\n            if sol_hyp.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyp.shape}\")\n\n            err = 100.0 * np.linalg.norm(sol_fos - sol_hyp) / np.linalg.norm(sol_fos)\n            return sol_hyp.copy(), float(err)\n\n        outs, times = self._threaded_sweep_serial_first(\n            params,\n            worker,\n            global_indices=global_idx,\n            parallel=parallel,\n            serial_first=serial_first,\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"ECSW\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        hyp_solutions: List[np.ndarray] = [None] * n  # type: ignore\n        hyp_error: List[float] = [np.nan] * n\n        hyp_speed: List[float] = [np.nan] * n\n\n        for i in range(n):\n            if outs[i] is None:\n                continue\n            sol_hyp, err = outs[i]\n            hyp_solutions[i] = sol_hyp\n            hyp_error[i] = err\n            hyp_speed[i] = float(self.fos_test_time[i] / times[i]) if times[i] &gt; 0 else np.nan\n\n        self.hyper_rom_solutions = hyp_solutions\n        self.hyper_rom_error = hyp_error\n        self.hyper_speed_up = hyp_speed\n        return self.hyper_rom_error, self.hyper_speed_up\n\n    def run_hyper_rom_simulation_deim(\n        self,\n        z,\n        deim_mat,\n        sampled_rows,\n        parallel: bool = True,\n        max_workers: Optional[int] = None,\n        verbose: bool = True,\n        max_retries: int = 1,\n        retry_delay: float = 0.5,\n        fail_fast: bool = True,\n        serial_first: bool = False,   # &lt;-- add this\n    ):\n        self.hyper_speed_up      = []\n        self.hyper_rom_error     = []\n        self.hyper_rom_solutions = []\n        self.z = z\n        self.deim_mat = deim_mat\n        self.sampled_rows = sampled_rows\n\n        n = min(self.N_rom_snap, len(self.param_list_test))\n        params = self.param_list_test[:n]\n        global_idx = self._test_global_idx[:n]\n\n        def worker(param, i_local, i_global):\n            self.cur_itr = i_local\n            sol_red_ = self.hyper_rom_solver_deim(cls=self, param=param)\n\n            # FIX: reconstruct once\n            sol_hyp = reconstruct_solution(sol_red_, self.V_sel, self._ref_for(i_local, i_global))\n\n            sol_fos = self.fos_test_data[i_local]\n            sol_hyp = self._maybe_transpose_like(sol_hyp, sol_fos)\n            if sol_hyp.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyp.shape}\")\n\n            err = 100.0 * np.linalg.norm(sol_fos - sol_hyp) / np.linalg.norm(sol_fos)\n            return sol_hyp.copy(), float(err)\n\n        outs, times = self._threaded_sweep_serial_first(\n            params,\n            worker,\n            global_indices=global_idx,\n            parallel=parallel,\n            serial_first=serial_first,\n            max_workers=max_workers,\n            verbose=verbose,\n            label=\"DEIM\",\n            max_retries=max_retries,\n            retry_delay=retry_delay,\n            fail_fast=fail_fast,\n        )\n\n        hyp_solutions: List[np.ndarray] = [None] * n  # type: ignore\n        hyp_error: List[float] = [np.nan] * n\n        hyp_speed: List[float] = [np.nan] * n\n\n        for i in range(n):\n            if outs[i] is None:\n                continue\n            sol_hyp, err = outs[i]\n            hyp_solutions[i] = sol_hyp\n            hyp_error[i] = err\n            hyp_speed[i] = float(self.fos_test_time[i] / times[i]) if times[i] &gt; 0 else np.nan\n\n        self.hyper_rom_solutions = hyp_solutions\n        self.hyper_rom_error = hyp_error\n        self.hyper_speed_up = hyp_speed\n        return self.hyper_rom_error, self.hyper_speed_up"
  },
  {
    "objectID": "src/skrom_problem_classes_static_master_class.html",
    "href": "src/skrom_problem_classes_static_master_class.html",
    "title": "Static reduced-order modeling (ROM) framework",
    "section": "",
    "text": "Runs an offline full-order FEM snapshot stage and an online reduced-order solve stage, with optional hyper-reduction (DEIM, ECSW) to lower cost while tracking error and speed.\nThe module defines: - a problem interface based on an abstract base class - a registry for problem classes and a factory to instantiate them - an offline workflow that runs full-order solves to generate snapshots - an online workflow that runs ROM and computes error and timing metrics - hooks for hyper-reduction workflows based on DEIM and ECSW"
  },
  {
    "objectID": "src/skrom_problem_classes_static_master_class.html#tldr",
    "href": "src/skrom_problem_classes_static_master_class.html#tldr",
    "title": "Static reduced-order modeling (ROM) framework",
    "section": "",
    "text": "Runs an offline full-order FEM snapshot stage and an online reduced-order solve stage, with optional hyper-reduction (DEIM, ECSW) to lower cost while tracking error and speed.\nThe module defines: - a problem interface based on an abstract base class - a registry for problem classes and a factory to instantiate them - an offline workflow that runs full-order solves to generate snapshots - an online workflow that runs ROM and computes error and timing metrics - hooks for hyper-reduction workflows based on DEIM and ECSW"
  },
  {
    "objectID": "src/skrom_problem_classes_static_master_class.html#notes",
    "href": "src/skrom_problem_classes_static_master_class.html#notes",
    "title": "Static reduced-order modeling (ROM) framework",
    "section": "Notes",
    "text": "Notes\nAuthors: Suparno Bhattacharyya; Ali Hamza Abidi Syed\nfrom pathlib import Path\nimport os,re,json,time,hashlib,tempfile\nimport numpy as np\nimport time\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, Dict, Type\nfrom skrom.fom.fem_utils import unwrap_attr\nfrom skrom.rom.rom_utils import rom_data_gen, load_rom_data, reconstruct_solution\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM DETECTION\n# ─────────────────────────────────────────────────────────────\ncwd = Path.cwd()\n# If running inside a folder named \"problem_X\", use that; else raise an error\nif cwd.name.startswith(\"problem_\"):\n    PROBLEM = cwd.name\nelse:\n    raise ValueError(\n        \"Current directory must be named 'problem_X' where X can be a number/string.\")\n\n\n# ─────────────────────────────────────────────────────────────\n# PROBLEM REGISTRY AND INTERFACE\n# ─────────────────────────────────────────────────────────────\nclass Problem(ABC):\n    \"\"\"\n    Interface for parameterized problems used by the ROM workflow.\n\n    The class defines the required methods for:\n    - mesh and basis setup\n    - affine components of bilinear and linear forms\n    - parameter-dependent coefficient evaluation\n    - sampling of the parameter space\n    - full-order and reduced-order solvers\n    - hyper-reduced solvers based on DEIM and ECSW\n    \"\"\"\n    @abstractmethod\n    def domain(self):\n        \"\"\"Return geometry and FEM bases.\"\"\"\n        pass\n\n    @abstractmethod\n    def bilinear_forms(self):\n        \"\"\"Return affine bilinear form components.\"\"\"\n        pass\n\n    @abstractmethod\n    def linear_forms(self):\n        \"\"\"Return affine linear form components.\"\"\"\n        pass\n\n    @abstractmethod\n    def properties(self):\n        \"\"\"Return function to compute parameter-dependent coefficients.\"\"\"\n        pass\n\n    @abstractmethod\n    def parameters(self):\n        \"\"\"Generate sampling of parameter space.\"\"\"\n        pass\n\n    @abstractmethod\n    def fom_solver(self):\n        \"\"\"Solve full-order FEM system for given parameters.\"\"\"\n        pass\n\n    @abstractmethod\n    def rom_solver(self):\n        \"\"\"Solve reduced-order model for given parameters.\"\"\"\n        pass\n\n    @abstractmethod\n    def hyper_rom_solver_deim(self):\n        \"\"\"Solve DEIM-based hyper-reduced system for given parameters.\"\"\"\n        pass\n\n    @abstractmethod\n    def hyper_rom_solver_ecsw(self):\n        \"\"\"Solve ECSW-based hyper-reduced system for given parameters.\"\"\"\n        pass\n\n\n# Decorator to register problem classes by name\nPROBLEM_REGISTRY: Dict[str, Type[Problem]] = {}\n\n\ndef register_problem(name: str):\n    \"\"\"\n    Register a problem class under a string key.\n\n    Parameters\n    ----------\n    name : str\n        Registry key for the problem class.\n\n    Returns\n    -------\n    deco : callable\n        Decorator that adds the class to ``PROBLEM_REGISTRY`` and returns it.\n\n    Notes\n    -----\n    The registry supports dynamic selection of a problem class based on the\n    working directory name.\n    \"\"\"\n    def deco(cls: Type[Problem]) -&gt; Type[Problem]:\n        PROBLEM_REGISTRY[name] = cls\n        return cls\n    return deco\n\n\ndef get_problem(name: str) -&gt; Problem:\n    \"\"\"\n    Instantiate a registered problem class.\n\n    Parameters\n    ----------\n    name : str\n        Registry key used in ``PROBLEM_REGISTRY``.\n\n    Returns\n    -------\n    problem_instance : Problem\n        Instance of the registered class.\n\n    Raises\n    ------\n    ValueError\n        If ``name`` is not present in the registry.\n    \"\"\"\n    try:\n        return PROBLEM_REGISTRY[name]()\n    except KeyError:\n        raise ValueError(f\"Unknown problem '{name}'. Available problems: {list(PROBLEM_REGISTRY.keys())}\")\n\n\ndef assign_properties(prob: Problem) -&gt; Tuple:\n    \"\"\"\n    Collect callable handles from a problem instance.\n\n    Parameters\n    ----------\n    prob : Problem\n        Problem instance.\n\n    Returns\n    -------\n    properties : tuple\n        Tuple with:\n        (parameters, bilinear_forms, linear_forms, domain, properties,\n        fom_solver, rom_solver, hyper_deim_solver, hyper_ecsw_solver).\n    \"\"\"\n    parameters        = prob.parameters\n    a                 = prob.bilinear_forms()\n    l                 = prob.linear_forms()\n    domain_           = prob.domain\n    properties        = prob.properties()\n    fom_solver        = prob.fom_solver\n    rom_solver        = prob.rom_solver\n    hyper_deim_solver = prob.hyper_rom_solver_deim\n    hyper_ecsw_solver = prob.hyper_rom_solver_ecsw\n\n    return (\n        parameters, a, l, domain_, properties,\n        fom_solver,\n        rom_solver,\n        hyper_deim_solver,\n        hyper_ecsw_solver,\n    )\n\n\n# ─────────────────────────────────────────────────────────────\n# OFFLINE SNAPSHOT GENERATION\n# ─────────────────────────────────────────────────────────────\nclass fom_simulation:\n    \"\"\"\n    Offline snapshot generation workflow.\n\n    The workflow:\n    - draws parameter samples\n    - runs full-order solves\n    - stores solutions and solve times\n    - computes a reference field for centering\n    - saves outputs to a ROM_data directory\n\n    Attributes\n    ----------\n    num_snapshots : int\n        Number of parameter samples.\n    param_list : array_like\n        Parameter samples.\n    fos_solutions : list of ndarray\n        Full-order solutions for each parameter sample.\n    fos_time : list of float\n        Solve time for each full-order solve.\n    train_ref : ndarray\n        Mean field computed from training snapshots.\n    \"\"\"\n\n    def __init__(self, num_snapshots: int = 32):\n        \"\"\"\n        Initialize the offline workflow.\n\n        Parameters\n        ----------\n        num_snapshots : int, optional\n            Number of snapshots used in the offline run. Default is 32.\n        \"\"\"\n        # Bind prob methods\n        prob = get_problem(PROBLEM)\n        (\n        self.parameters,\n        self.bilinear_forms,\n        self.linear_forms,\n        self.domain,\n        self.properties,\n        self.fom_solver,\n        *_\n        ) = assign_properties(prob)\n\n        # Track attributes introduced by this class\n        self._baseline_attrs = set(vars(self))\n\n        # Load domain and basis\n        data = self.domain()\n        self.mesh  = data[\"mesh\"]\n        self.basis = data[\"basis\"]\n\n        # Prepare parameter sampling\n        self.num_snapshots = num_snapshots\n        (\n            self.param_list,\n            self.param_range,\n            self.train_mask,\n            self.test_mask\n        ) = self.parameters(num_snapshots)\n\n        # Containers for solutions and timings\n        self.fos_solutions = []\n        self.fos_time      = []\n\n\n\n    def run_simulation(self) -&gt; None:\n        \"\"\"\n        Run full-order solves and save offline outputs.\n\n        Adds:\n        - per-sample checkpointing to .npz\n        - resume: if checkpoint exists, load it and skip the solve\n        - long-path-safe filenames (Windows): hash-first + fallback to hash-only\n        - crash-safe writes (atomic replace)\n        - corrupt checkpoint handling (recompute + overwrite)\n        \"\"\"\n\n        # reset in-memory containers (important when re-running in notebooks)\n        self.fos_solutions = []\n        self.fos_time = []\n\n        cur_dir = os.getcwd()\n\n        # keep directory name short to reduce Windows path length risk\n        ckpt_dir = Path(cur_dir) / \"ckpt\"\n        ckpt_dir.mkdir(parents=True, exist_ok=True)\n\n        # ---------- helpers ----------\n        def _safe_token(s: str, maxlen: int) -&gt; str:\n            s = re.sub(r\"\\s+\", \"\", s)\n            s = re.sub(r\"[^0-9A-Za-z,.\\-+eE_]\", \"_\", s)\n            return s[:maxlen]\n\n        def _problem_tag() -&gt; str:\n            return (\n                getattr(self, \"PROBLEM_NAME\", None)\n                or getattr(self, \"problem_name\", None)\n                or self.__class__.__name__\n            )\n\n        def _param_signature(param):\n            \"\"\"\n            Returns:\n            preview_token (short, human-readable),\n            hash10 (stable),\n            stored_param (array or string array for saving inside .npz)\n            \"\"\"\n            try:\n                arr = np.asarray(param, dtype=float).ravel()\n                b = arr.tobytes()\n                preview = \",\".join(f\"{x:.12g}\" for x in arr[:6])\n                if arr.size &gt; 6:\n                    preview += f\",...n{arr.size}\"\n                stored = arr\n            except Exception:\n                js = json.dumps(param, sort_keys=True, default=str)\n                b = js.encode(\"utf-8\")\n                preview = js\n                stored = np.array([js], dtype=\"U\")\n\n            h10 = hashlib.sha1(b).hexdigest()[:10]\n            return preview, h10, stored\n\n        def _ckpt_path(param) -&gt; Path:\n            preview, h10, _ = _param_signature(param)\n            prob = _safe_token(_problem_tag(), maxlen=20)\n\n            # Keep preview very short; uniqueness comes from hash\n            preview = _safe_token(preview, maxlen=30)\n\n            # Option 1: slightly descriptive\n            name1 = f\"fos_{prob}_p{preview}_h{h10}.npz\"\n            path1 = ckpt_dir / name1\n\n            # Option 2: hash-only (short path fallback)\n            name2 = f\"fos_{prob}_h{h10}.npz\"\n            path2 = ckpt_dir / name2\n\n            # Windows long path guard\n            if os.name == \"nt\":\n                # keep headroom below 260\n                if len(str(path1)) &gt;= 240:\n                    return path2\n\n            return path1\n\n        def _atomic_save_npz(path: Path, payload: dict):\n            # IMPORTANT: temp file must end with \".npz\" (np.savez appends otherwise)\n            path.parent.mkdir(parents=True, exist_ok=True)\n            with tempfile.NamedTemporaryFile(\n                dir=str(path.parent),\n                prefix=path.stem + \"_\",\n                suffix=\".npz\",\n                delete=False,\n            ) as tf:\n                tmp_name = tf.name\n\n            try:\n                np.savez_compressed(tmp_name, **payload)\n                os.replace(tmp_name, str(path))  # atomic on same filesystem\n            finally:\n                if os.path.exists(tmp_name):\n                    try:\n                        os.remove(tmp_name)\n                    except OSError:\n                        pass\n\n        def _save_solution(path: Path, sol, param, elapsed: float, snap_index: int):\n            _, _, param_store = _param_signature(param)\n\n            payload = {\n                \"snap_index\": np.array([snap_index], dtype=np.int64),\n                \"solve_time\": np.array([elapsed], dtype=float),\n                \"param\": param_store,\n            }\n\n            if isinstance(sol, tuple):\n                payload[\"nsol\"] = np.array([len(sol)], dtype=np.int32)\n                for j, x in enumerate(sol):\n                    payload[f\"sol{j}\"] = np.asarray(x)\n            else:\n                payload[\"nsol\"] = np.array([1], dtype=np.int32)\n                payload[\"sol0\"] = np.asarray(sol)\n\n            _atomic_save_npz(path, payload)\n\n        def _load_solution(path: Path):\n            with np.load(path, allow_pickle=False) as data:\n                nsol = int(data[\"nsol\"][0]) if \"nsol\" in data.files else 1\n                t = float(data[\"solve_time\"][0]) if \"solve_time\" in data.files else np.nan\n                if nsol == 1:\n                    sol = data[\"sol0\"]\n                else:\n                    sol = tuple(data[f\"sol{j}\"] for j in range(nsol))\n            return sol, t\n\n        # ---------- main loop ----------\n        for i, param in enumerate(self.param_list):\n            print(f\"Snap {i+1}/{len(self.param_list)} params={param}\")\n            self.cur_itr = i\n\n            path = _ckpt_path(param)\n\n            if path.exists():\n                try:\n                    sol, t_saved = _load_solution(path)\n                    self.fos_time.append(t_saved)\n                except Exception:\n                    # corrupt/partial file -&gt; delete and recompute\n                    try:\n                        path.unlink(missing_ok=True)\n                    except Exception:\n                        pass\n\n                    t0 = time.perf_counter()\n                    sol = self.fom_solver(cls=self, param=param)\n                    elapsed = time.perf_counter() - t0\n                    self.fos_time.append(elapsed)\n                    _save_solution(path, sol, param, elapsed, snap_index=i)\n            else:\n                t0 = time.perf_counter()\n                sol = self.fom_solver(cls=self, param=param)\n                elapsed = time.perf_counter() - t0\n                self.fos_time.append(elapsed)\n                _save_solution(path, sol, param, elapsed, snap_index=i)\n\n            # store solution copy (in-memory)\n            if isinstance(sol, tuple):\n                self.fos_solutions.append(tuple(np.copy(x) for x in sol))\n            else:\n                self.fos_solutions.append(np.copy(sol))\n\n        # ---------- convert + mean over training subset ----------\n        if len(self.fos_solutions) == 0:\n            return\n\n        first = self.fos_solutions[0]\n        if isinstance(first, tuple):\n            self.fos_solutions = np.array(self.fos_solutions, dtype=object)\n\n            train_ids = np.where(self.train_mask)[0]\n            ncomp = len(first)\n            train_ref = []\n            for j in range(ncomp):\n                stack_j = np.stack([self.fos_solutions[k][j] for k in train_ids], axis=0)\n                train_ref.append(np.mean(stack_j, axis=0))\n            self.train_ref = tuple(train_ref)\n        else:\n            self.fos_solutions = np.asarray(self.fos_solutions)\n            self.train_ref = np.mean(self.fos_solutions[self.train_mask], axis=0)\n\n        # ---------- Persist new attributes to disk ----------\n        new = set(vars(self)) - self._baseline_attrs\n        save_dict = {k: getattr(self, k) for k in new if not k.startswith(\"_\")}\n        rom_data_gen(save_dict, cur_dir)\n\n\n\n# ─────────────────────────────────────────────────────────────\n# ONLINE ROM EVALUATION\n# ─────────────────────────────────────────────────────────────\nclass rom_simulation:\n    \"\"\"\n    Online ROM evaluation workflow.\n\n    The workflow:\n    - loads ROM_data outputs from disk\n    - selects test parameters and reference full-order solutions\n    - runs ROM solvers and reconstructs full fields\n    - computes relative error and time ratio metrics\n    - supports hyper-reduced solvers based on DEIM and ECSW\n\n    Attributes\n    ----------\n    V_sel : ndarray\n        Basis matrix used for reconstruction.\n    n_sel : int\n        Mode count used by the ROM.\n    param_list_test : array_like\n        Test parameter samples.\n    rom_error : list of float\n        Relative error values in percent for each test case.\n    speed_up : list of float\n        Time ratios computed as (full-order time) / (ROM time).\n    \"\"\"\n\n    def __init__(\n        self, train_ref=None, test_ref=None, fos_solutions=None,\n        train_mask=None, test_mask=None,\n        V_sel=None, n_sel=None, N_rom_snap=None\n    ):\n        \"\"\"\n        Initialize the online workflow and load ROM_data outputs.\n\n        Parameters\n        ----------\n        train_ref : ndarray, optional\n            Reference field used for centering during training.\n        test_ref : ndarray, optional\n            Reference field used for reconstruction on the test set.\n        fos_solutions : ndarray, optional\n            Full-order snapshots. If None, data are loaded from disk.\n        train_mask : array_like of bool, optional\n            Training mask. If None, data are loaded from disk.\n        test_mask : array_like of bool, optional\n            Test mask. If None, data are loaded from disk.\n        V_sel : ndarray, optional\n            Basis matrix used in reconstruction.\n        n_sel : int, optional\n            Mode count used by the ROM.\n        N_rom_snap : int, optional\n            Test case count evaluated in the run. If None, uses all test cases.\n\n        Notes\n        -----\n        The initializer loads ``ROM_data`` from the current working directory.\n        \"\"\"\n        # Bind prob methods\n        prob = get_problem(PROBLEM)\n        (\n            self.parameters,\n            self.bilinear_forms,\n            self.linear_forms,\n            self.domain,\n            self.properties,\n            _,\n            self.rom_solver,\n            self.hyper_rom_solver_deim,\n            self.hyper_rom_solver_ecsw,\n        ) = assign_properties(prob)\n\n        # Load ROM data from disk\n        cur_dir = os.getcwd()\n        rom_dir = os.path.join(cur_dir, \"ROM_data\")\n        load_rom_data(self, rom_dir)\n\n        if train_ref is not None:\n            self.train_ref = train_ref\n\n        if test_ref is not None:\n            self.test_ref = test_ref\n        else:\n            self.test_ref = self.train_ref\n\n        if fos_solutions is not None:\n            self.fos_solutions = fos_solutions\n\n        if train_mask is not None:\n            self.train_mask = train_mask\n        \n        if test_mask is not None:\n            self.test_mask = test_mask\n\n        # Prepare test/training splits\n        self.param_list_test = self.param_list[self.test_mask]\n        self.fos_test_data   = self.fos_solutions[self.test_mask]\n        self.fos_test_time   = np.asarray(self.fos_time)[self.test_mask]\n        self.sol_train_ms    = self.fos_solutions[self.train_mask] - self.train_ref\n\n        # Store basis info\n        self.V_sel      = V_sel\n        self.n_sel      = n_sel\n        self.N_rom_snap = N_rom_snap or len(self.param_list_test)\n\n        # Ensure attributes are unwrapped if zero-dimensional\n        unwrap_attr(self, 'basis')\n        unwrap_attr(self, 'mesh')\n\n    def run_rom_simulation(self):\n        \"\"\"\n        Run ROM evaluation on the test set.\n\n        The method:\n        - runs the reduced solver for each test parameter\n        - reconstructs a full field from reduced coordinates\n        - computes relative error in percent\n        - computes time ratio (full-order time) / (ROM time)\n\n        Returns\n        -------\n        rom_error : list of float\n            Relative error values in percent.\n        speed_up : list of float\n            Time ratios for each test case.\n        \"\"\"\n        self.speed_up     = []\n        self.rom_error    = []\n        self.rom_solutions = []\n\n        for i, param in enumerate(self.param_list_test[:self.N_rom_snap]):\n            print(f\"Snap {i+1}/{len(self.param_list)} params={param}\")\n            self.cur_itr = i\n\n            # Time the ROM solve\n            t0 = time.perf_counter()\n            sol_red_ = self.rom_solver(cls=self, param=param)\n\n            if self.test_ref is not None:\n\n                if len(self.test_ref.shape)==3:\n                    sol_rom = reconstruct_solution(sol_red_, self.V_sel, self.test_ref[i])\n                else:\n                    sol_rom = reconstruct_solution(sol_red_, self.V_sel, self.test_ref)\n\n            dt = time.perf_counter() - t0\n            # Compute error & speed-up\n            sol_fos = self.fos_test_data[i]\n\n            if sol_rom.shape != sol_fos.shape and sol_rom.ndim == 2 and sol_rom.T.shape == sol_fos.shape:\n                sol_rom = sol_rom.T\n\n            if sol_rom.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_rom.shape}\")\n            \n            err   = 100 * np.linalg.norm(sol_fos - sol_rom) \\\n                    / np.linalg.norm(sol_fos)\n            speed = self.fos_test_time[i] / dt\n\n            self.rom_error.append(err)\n            self.speed_up.append(speed)\n            self.rom_solutions.append(sol_rom.copy())\n\n        return self.rom_error, self.speed_up\n    \n    def run_hyper_rom_simulation_ecsw(self, z):\n        \"\"\"\n        Run ECSW hyper-ROM evaluation on the test set.\n\n        Parameters\n        ----------\n        z : array_like\n            Element weight vector used by the ECSW solver.\n\n        Returns\n        -------\n        hyper_rom_error : list of float\n            Relative error values in percent.\n        hyper_speed_up : list of float\n            Time ratios for each test case.\n        \"\"\"\n        self.hyper_speed_up    = []\n        self.hyper_rom_error   = []\n        self.hyper_rom_solutions = []\n        # Store hyper-reduction parameters\n        self.z            = z\n\n        for i, param in enumerate(self.param_list_test[:self.N_rom_snap]):\n            print(f\"Snap {i+1}/{len(self.param_list_test)} params={param}\")\n            self.cur_itr = i\n\n            # Time the hyper-ROM solve + reconstruction\n            t0 = time.perf_counter()\n            sol_red_ = self.hyper_rom_solver_ecsw(cls=self, param=param)\n\n            if len(self.test_ref.shape)==3:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref[i])\n            else:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref)\n\n\n            dt = time.perf_counter() - t0\n\n            # record speed-up and solution\n            self.hyper_speed_up.append(self.fos_test_time[i] / dt)\n\n            # compute and record error\n            sol_fos = self.fos_test_data[i]\n\n            if sol_hyper.shape != sol_fos.shape and sol_hyper.ndim == 2 and sol_hyper.T.shape == sol_fos.shape:\n                sol_hyper = sol_hyper.T\n\n            if sol_hyper.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyper.shape}\")\n\n            self.hyper_rom_solutions.append(sol_hyper.copy())\n\n            err = 100 * np.linalg.norm(sol_fos - sol_hyper) / np.linalg.norm(sol_fos)\n            self.hyper_rom_error.append(err)\n\n        return self.hyper_rom_error, self.hyper_speed_up\n\n\n    def run_hyper_rom_simulation_deim(self, z, deim_mat, sampled_rows):\n        \"\"\"\n        Run DEIM hyper-ROM evaluation on the test set.\n\n        Parameters\n        ----------\n        z : array_like\n            Weight vector stored on the instance.\n        deim_mat : ndarray\n            Interpolation matrix used by the DEIM workflow.\n        sampled_rows : array_like of int\n            Indices of sampled degrees of freedom.\n\n        Returns\n        -------\n        hyper_rom_error : list of float\n            Relative error values in percent.\n        hyper_speed_up : list of float\n            Time ratios for each test case.\n        \"\"\"\n        self.hyper_speed_up    = []\n        self.hyper_rom_error   = []\n        self.hyper_rom_solutions = []\n        # Store hyper-reduction parameters\n        self.z            = z\n        self.deim_mat   = deim_mat\n        self.sampled_rows = sampled_rows\n\n        for i, param in enumerate(self.param_list_test[:self.N_rom_snap]):\n            print(f\"Snap {i+1}/{len(self.param_list)} params={param}\")\n            self.cur_itr = i\n\n            # Time the hyper-ROM solve + reconstruction\n            t0 = time.perf_counter()\n            sol_red_ = self.hyper_rom_solver_deim(cls=self, param=param)\n\n            if len(self.test_ref.shape)==3:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref[i])\n            else:\n                sol_hyper = reconstruct_solution(sol_red_, self.V_sel, self.test_ref)\n\n            dt = time.perf_counter() - t0\n\n            # record speed-up and solution\n            self.hyper_speed_up.append(self.fos_test_time[i] / dt)\n            self.hyper_rom_solutions.append(sol_hyper.copy())\n\n            # compute and record error\n            sol_fos = self.fos_test_data[i]\n\n            if sol_hyper.shape != sol_fos.shape and sol_hyper.ndim == 2 and sol_hyper.T.shape == sol_fos.shape:\n                sol_hyper = sol_hyper.T\n\n            if sol_hyper.shape != sol_fos.shape:\n                raise ValueError(f\"shape mismatch: fos{sol_fos.shape}, hyper{sol_hyper.shape}\")\n            \n            \n            err = 100 * np.linalg.norm(sol_fos - sol_hyper) / np.linalg.norm(sol_fos)\n            self.hyper_rom_error.append(err)\n\n        return self.hyper_rom_error, self.hyper_speed_up"
  },
  {
    "objectID": "src/skrom_rom_init.html",
    "href": "src/skrom_rom_init.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "The rom folder provides core reduced‐order modeling tools:\n– Projection & assembly classes (BilinearFormROM, LinearFormROM): • Project full‐order stiffness and load contributions onto reduced bases • Handle Dirichlet boundary conditions via free‐DOF mappings • Support chunked/clustered assembly for memory‐efficient reduced operators\n– Error evaluation & visualization (error_utils.py): • Compute time‐dependent and global error metrics (L2, RMSE, R², energy‐norm, etc.) • Generate scatter plots, spatial snapshots, raincloud plots, and tabular reports\n– ROM utilities (utils.py): • Snapshot splitting and sampling (random, Latin‐Hypercube, Sobol, Gaussian) • Basis enrichment via deflation and QR re‐orthonormalization • Solution reconstruction from reduced coefficients • Data I/O for ROM simulations (rom_data_gen, load_rom_data) • Newton solvers for (hyper‐)reduced systems"
  },
  {
    "objectID": "src/skrom_rom_bilinear_form_rom.html",
    "href": "src/skrom_rom_bilinear_form_rom.html",
    "title": "Implements reduced-order bilinear form assembly for full-order to reduced-order transformations",
    "section": "",
    "text": "This module provides: - BilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\nAuthor: Suparno Bhattacharyya\nimport gc\nfrom typing import Optional\nfrom threading import Thread\n\n\nimport numpy as np\nfrom numpy import ndarray\n\nfrom skfem.assembly.basis import Basis\nfrom skfem.assembly.form.coo_data import COOData\nfrom skfem.assembly.form import Form\nfrom skfem.assembly.form.form import FormExtraParams\nfrom skfem.assembly.basis import AbstractBasis\nfrom skfem.assembly.form.bilinear_form import BilinearForm  \n\n\nclass BilinearFormROM(BilinearForm):\n    \"\"\"\n    BilinearFormROM\n\n    Bilinear form that projects element stiffness matrices onto reduced bases\n    and assembles the global reduced stiffness matrix, handling Dirichlet boundary\n    conditions via mappings from full to free DOFs.\n\n    Attributes\n    ----------\n    lob : ndarray, shape (N_free, r) or (N, r)\n        Left (test) reduced basis.\n    rob : ndarray, shape (N_free, r) or (N, r)\n        Right (trial) reduced basis.\n    free_dofs : ndarray or None\n        Indices of global free (non-Dirichlet) DOFs.\n    mean : ndarray or None\n        Mean snapshot vector subtracted before basis computation.\n    nthreads : int\n        Number of threads for parallel computation.\n    dtype : data-type\n        Numeric type for computations.\n    ubasis : Basis\n        Full-order finite element basis for trial functions.\n    vbasis : Basis\n        Full-order finite element basis for test functions.\n    mapping : ndarray, shape (N_full,)\n        Maps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n    element_dofs : ndarray\n        Local-to-global DOF mapping for each element.\n    free_indices : ndarray\n        Reduced DOF indices for each element and basis function.\n    mask : ndarray of bool\n        Indicates free DOFs per element.\n    r : int\n        Dimension of the reduced basis.\n    groupA : ndarray\n        Indices of elements with all free DOFs.\n    groupB : ndarray\n        Indices of elements with some Dirichlet DOFs.\n    chunk_size : int\n        Number of elements per chunk in groupA.\n    n_full_chunks : int\n        Number of full-sized chunks in groupA.\n    remainder : int\n        Number of leftover elements in groupA.\n    \"\"\"\n\n    def __init__(\n        self,\n        form,\n        ubasis: Basis,\n        lob,\n        rob,\n        vbasis: Optional[Basis] = None,\n        free_dofs: Optional[ndarray] = None,\n        mean: Optional[ndarray] = None,\n        nthreads: int = 0,\n        dtype: np.dtype = np.float64,\n    ):\n        \"\"\"\n        Initialize the reduced-order bilinear form.\n\n        Parameters\n        ----------\n        form : callable\n            Function defining the bilinear form.\n        ubasis : Basis\n            Full-order finite element basis for trial functions.\n        lob : ndarray, shape (N_free, r) or (N, r)\n            Left (test) reduced basis.\n        rob : ndarray, shape (N_free, r) or (N, r)\n            Right (trial) reduced basis.\n        vbasis : Basis, optional\n            Finite element basis for test functions. If None, defaults to ubasis.\n        free_dofs : ndarray, optional\n            Global indices of free (non-Dirichlet) DOFs.\n        mean : ndarray, optional\n            Mean snapshot vector subtracted before basis computation.\n        nthreads : int, optional\n            Number of threads for parallel computation.\n        dtype : data-type, optional\n            Numeric type for computations.\n        \"\"\"\n        super().__init__(form)\n        self.lob = lob\n        self.rob = rob\n        self.free_dofs = free_dofs\n        self.mean = mean\n        self.nthreads = nthreads\n        self.dtype = dtype\n        self.ubasis = ubasis\n        \n        if vbasis is None:\n            self.vbasis = ubasis\n\n        # Mapping from full DOFs to indices in the reduced basis.\n        self.mapping = self._get_mapping(ubasis)\n        self.element_dofs = ubasis.element_dofs\n        self.free_indices = self.mapping[self.element_dofs]\n        self.mask = self.free_indices &gt;= 0\n\n        self.r = lob.shape[1]\n        nonzero_elements = range(ubasis.nelems)\n\n        all_free = np.all(self.mask, axis=0)\n        full_free = np.nonzero(all_free)[0]\n\n        self.groupA = np.intersect1d(nonzero_elements, full_free)\n        self.groupB = np.setdiff1d(nonzero_elements, self.groupA)\n\n        nA = self.groupA.size\n        self.chunk_size=int(nA/2)\n\n        if nA &lt; self.chunk_size:\n            self.n_full_chunks = 1\n            self.remainder = 0\n            self.chunk_size = nA\n\n        else:\n            self.n_full_chunks = nA // self.chunk_size\n            self.remainder = nA % self.chunk_size\n\n\n\n    def _get_mapping(self, ubasis: Basis) -&gt; ndarray:\n        \"\"\"\n        Create mapping from full DOFs to reduced DOF indices.\n\n        Parameters\n        ----------\n        ubasis : Basis\n            Full-order finite element basis.\n\n        Returns\n        -------\n        mapping : ndarray, shape (N_full,)\n            Array where mapping[i] gives the reduced index of global DOF i, or -1\n            for Dirichlet DOFs if free_dofs were provided; otherwise the identity mapping.\n        \"\"\"\n        N_full = ubasis.N\n        if self.free_dofs is None:\n            return np.arange(N_full)\n        else:\n            mapping = -np.ones(N_full, dtype=int)\n            mapping[self.free_dofs] = np.arange(len(self.free_dofs))\n            return mapping\n\n#### Ideally we do not want to use this assembly method, but it is kept for situations where the full-order stiffness matrix cannot assembled in one go due to memory constraints.\n\n    def assemble(self, vbasis: Optional[Basis] = None, **kwargs):\n\n        \"\"\"\n        Assemble the global reduced stiffness matrix.\n\n        Projects element stiffness matrices onto reduced bases and sums contributions\n        over free DOFs only.\n\n        Parameters\n        ----------\n        vbasis : Basis, optional\n            Finite element basis for test functions. Defaults to ubasis.\n        **kwargs\n            Additional parameters passed to the form during assembly.\n\n        Returns\n        -------\n        K_reduced : ndarray, shape (r, r)\n            Reduced stiffness matrix.\n        \"\"\"\n        ubasis = self.ubasis\n        vbasis = self.vbasis\n        \n        # Extract local element stiffness matrices.\n        element_matrices = self.extract_element_matrices(ubasis, vbasis, **kwargs)\n\n        # Reduced dimension.\n        r = self.r\n\n        # Global reduced stiffness matrix.\n        K_reduced = np.zeros((r, r), dtype=self.dtype)\n\n\n        def compute_reduced_matrix(lob, rob, element_matrices,  dtype=np.float64):\n\n            free_indices = self.free_indices\n            mask = self.mask\n\n            sum_A = np.zeros((r, r), dtype=dtype)\n\n\n            for i in range(self.n_full_chunks):\n\n                chunk_indices = self.groupA[i * self.chunk_size : (i + 1) * self.chunk_size]\n                active_dofs_chunk = self.element_dofs.T[chunk_indices]\n                R_test_chunk = lob[active_dofs_chunk]\n                R_trial_chunk = rob[active_dofs_chunk]\n                K_local_chunk = element_matrices[chunk_indices, :, :]\n\n                sum_A += np.einsum('eia,eij,ejb-&gt;ab', R_test_chunk, K_local_chunk, R_trial_chunk, optimize=True)\n\n\n            if self.remainder &gt; 0:\n\n                chunk_indices = self.groupA[self.n_full_chunks * self.chunk_size :]\n                active_dofs_chunk = self.element_dofs.T[chunk_indices]\n                R_test_chunk = lob[active_dofs_chunk]\n                R_trial_chunk = rob[active_dofs_chunk]\n                K_local_chunk = element_matrices[chunk_indices, :, :]\n\n                sum_A += np.einsum('eia,eij,ejb-&gt;ab', R_test_chunk, K_local_chunk, R_trial_chunk, optimize=True)\n\n\n            def compute_K_red_for_element(e):\n\n                idx = free_indices[:, e][mask[:, e]]\n\n                if idx.size == 0:\n\n                    return np.zeros((r, r), dtype=dtype)\n                \n                R_test = lob[idx, :]\n                R_trial = rob[idx, :]\n                K_loc = element_matrices[e, :, :]\n                K_loc_free = K_loc[np.ix_(mask[:, e], mask[:, e])]\n\n                return (R_test.T @ K_loc_free @ R_trial)\n\n\n            if self.groupB.size &gt; 0:\n\n                f = np.frompyfunc(compute_K_red_for_element, 1, 1)\n                K_red_B_obj = f(self.groupB)\n                K_red_B_list = [np.asarray(x).astype(np.float32, copy=False) for x in K_red_B_obj]\n                K_red_B = np.sum(np.stack(K_red_B_list), axis=0)\n\n\n            else:\n\n                K_red_B = np.zeros((r, r), dtype=dtype)\n\n\n            K_reduced = sum_A + K_red_B\n            \n            return K_reduced\n\n        K_reduced = compute_reduced_matrix(self.lob, self.rob, element_matrices)\n\n        \n        return K_reduced\n\n\n\n    def extract_element_matrices(self, ubasis: Basis, vbasis=None, **kwargs):\n        \"\"\"\n        Extract local element stiffness matrices for a given bilinear form.\n\n        Parameters\n        ----------\n        form : BilinearForm\n            A bilinear form instance (e.g., one decorated with @BilinearForm).\n        ubasis : Basis\n            The finite element basis associated with the trial function.\n        vbasis : Basis, optional\n            The finite element basis associated with the test function.\n            If None, vbasis is set equal to ubasis.\n        kwargs : dict, optional\n            Additional keyword arguments to be passed as extra parameters\n            during the assembly process.\n\n        Returns\n        -------\n        element_matrices : ndarray\n            A NumPy array of shape (n_elements, Nbfun, Nbfun) containing\n            the local stiffness matrices for each element, where Nbfun is the\n            number of local basis functions per element.\n        \"\"\"\n        if vbasis is None:\n            vbasis = ubasis\n        elif ubasis.X.shape[-1] != vbasis.X.shape[-1]:\n            raise ValueError(\"Quadrature mismatch: trial and test functions should have the same number of integration points.\")\n\n        nt = ubasis.nelems         # Number of elements\n        dx = ubasis.dx             # Quadrature weights per element\n\n\n        # Combine default parameters with any additional keyword arguments.\n        wdict = FormExtraParams({\n            **ubasis.default_parameters(),\n            **self._normalize_asm_kwargs(kwargs, ubasis),\n        })\n\n\n        # Allocate an array to hold the local contributions.\n        # Its shape is (Nbfun, Nbfun, n_elements)\n        local_data = np.zeros((ubasis.Nbfun, vbasis.Nbfun, nt), dtype=self.dtype)\n\n        # Loop over local basis indices (or use threading if requested)\n        if self.nthreads &lt;= 0:\n            for j in range(ubasis.Nbfun):\n                for i in range(vbasis.Nbfun):\n                    local_data[j, i, :] = self._kernel(\n                        ubasis.basis[j],\n                        vbasis.basis[i],\n                        wdict,\n                        dx,\n                    )\n        else:\n            # Prepare index pairs for threaded computation.\n            indices = np.array([[i, j]\n                                for j, i in product(range(ubasis.Nbfun), range(vbasis.Nbfun))])\n            threads = [\n                Thread(\n                    target=self._threaded_kernel,\n                    args=(local_data, ix, ubasis.basis, vbasis.basis, wdict, dx)\n                )\n                for ix in np.array_split(indices, self.nthreads, axis=0)\n            ]\n            for t in threads:\n                t.start()\n            for t in threads:\n                t.join()\n\n        # Rearrange data from (Nbfun, Nbfun, n_elements) to (n_elements, Nbfun, Nbfun)\n        element_matrices = local_data.transpose(2, 0, 1)\n        return element_matrices"
  },
  {
    "objectID": "src/skrom_rom_linear_form_rom.html",
    "href": "src/skrom_rom_linear_form_rom.html",
    "title": "Implements reduced-order linear form assembly for full-order to reduced-order transformations",
    "section": "",
    "text": "This module provides: - LinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\nAuthor: Suparno Bhattacharyya\nimport gc\nfrom typing import Optional\nfrom threading import Thread\nimport numpy as np\nfrom numpy import ndarray\nfrom skfem.assembly.basis import Basis\nfrom skfem.assembly.form import Form\nfrom skfem.assembly.form.form import FormExtraParams\nfrom skfem.assembly.form.linear_form import LinearForm  # Import the full-order linear form class\nfrom skfem.assembly.basis import AbstractBasis\n\nclass LinearFormROM(LinearForm):\n\n    \"\"\"\n    LinearFormROM\n\n    Linear form that projects element load vectors onto reduced bases\n    and assembles the global reduced load vector, handling Dirichlet boundary\n    conditions via mappings from full to free DOFs.\n\n    Attributes\n    ----------\n    r_basis : ndarray, shape (N_free, r) or (N, r)\n        Reduced basis for load vectors.\n    free_dofs : ndarray or None\n        Indices of global free (non-Dirichlet) DOFs.\n    mean : ndarray or None\n        Mean snapshot vector subtracted before basis computation.\n    nthreads : int\n        Number of threads for parallel computation.\n    dtype : data-type\n        Numeric type for computations.\n    ubasis : Basis\n        Full-order finite element basis for test functions.\n    mapping : ndarray, shape (N_full,)\n        Maps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n    element_dofs : ndarray\n        Local-to-global DOF mapping for each element.\n    free_indices : ndarray\n        Reduced DOF indices for each element and basis function.\n    mask : ndarray of bool\n        Indicates free DOFs per element.\n    r : int\n        Dimension of the reduced basis.\n    groupA : ndarray\n        Indices of elements with all free DOFs.\n    groupB : ndarray\n        Indices of elements with some Dirichlet DOFs.\n    chunk_size : int\n        Number of elements per chunk in groupA.\n    n_full_chunks : int\n        Number of full-sized chunks in groupA.\n    remainder : int\n        Number of leftover elements in groupA.\n    \"\"\"\n\n    def __init__(self, form, ubasis: Basis, lob, free_dofs: Optional[ndarray] = None,\n                 mean: Optional[ndarray] = None, nthreads=0, dtype=np.float64):\n        \"\"\"\n        Initialize the reduced-order linear form.\n\n        Parameters\n        ----------\n        form : callable\n            Function defining the linear form.\n        ubasis : Basis\n            Full-order finite element basis for test functions.\n        lob : ndarray, shape (N_free, r) or (N, r)\n            Reduced basis for load vectors.\n        free_dofs : ndarray, optional\n            Global indices of free (non-Dirichlet) DOFs.\n        mean : ndarray, optional\n            Mean snapshot vector subtracted before basis computation.\n        nthreads : int, optional\n            Number of threads for parallel computation.\n        dtype : data-type, optional\n            Numeric type for computations.\n        \"\"\"\n\n        super().__init__(form)\n\n\n        self.r_basis = lob\n        self.free_dofs = free_dofs\n        self.mean = mean\n        self.nthreads = nthreads\n        self.dtype = dtype\n        self.ubasis = ubasis\n\n\n        # Mapping from full DOFs to indices in the reduced basis.\n        self.mapping = self._get_mapping(ubasis)\n        self.element_dofs = ubasis.element_dofs\n        self.free_indices = self.mapping[self.element_dofs]\n        self.mask = self.free_indices &gt;= 0\n\n\n        self.r = lob.shape[1]\n        nonzero_elements = range(ubasis.nelems)\n\n\n        all_free = np.all(self.mask, axis=0)\n        full_free = np.nonzero(all_free)[0]\n\n\n        self.groupA = np.intersect1d(nonzero_elements, full_free)\n        self.groupB = np.setdiff1d(nonzero_elements, self.groupA)\n\n\n        nA = self.groupA.size\n        self.chunk_size=int(nA/2)\n\n\n        if nA &lt; self.chunk_size:\n            self.n_full_chunks = 1\n            self.remainder = 0\n            self.chunk_size = nA\n\n        else:\n            self.n_full_chunks = nA // self.chunk_size\n            self.remainder = nA % self.chunk_size\n\n\n    def _get_mapping(self, basis: Basis) -&gt; ndarray:\n        \"\"\"\n        Create mapping from full DOFs to reduced DOF indices.\n\n        Parameters\n        ----------\n        basis : Basis\n            Full-order finite element basis.\n\n        Returns\n        -------\n        mapping : ndarray, shape (N_full,)\n            Array where mapping[i] gives the reduced index of global DOF i, or -1\n            for Dirichlet DOFs if free_dofs were provided; otherwise the identity mapping.\n        \"\"\"\n        N_full = basis.N\n        if self.free_dofs is None:\n            return np.arange(N_full)\n        else:\n            mapping = -np.ones(N_full, dtype=int)\n            mapping[self.free_dofs] = np.arange(len(self.free_dofs))\n            return mapping\n        \n\n    def assemble(self, **kwargs) -&gt; ndarray:\n        \"\"\"\n        Assemble the global reduced load vector.\n\n        Projects element load vectors onto reduced bases and sums contributions\n        over free DOFs only.\n\n        Parameters\n        ----------\n        **kwargs\n            Additional parameters passed to the form during assembly.\n\n        Returns\n        -------\n        f_reduced : ndarray, shape (r,)\n            Reduced load vector.\n        \"\"\"\n\n        element_vectors = self.extract_element_vector(self.ubasis, **kwargs)\n\n        # Reduced dimension.\n        r = self.r\n\n        f_reduced = np.zeros((r,), dtype=self.dtype)\n\n\n        def compute_reduced_vector_in_chunks(element_vectors):\n\n\n            mask = self.mask        # shape (Nbfun, n_elements)\n\n            f_reduced_A = np.zeros((r,), dtype=self.dtype)\n\n            for i in range(self.n_full_chunks):\n\n                chunk_idx = self.groupA[i *  self.chunk_size : (i + 1) *  self.chunk_size]\n                active_dofs =  self.element_dofs[:, chunk_idx].T  # shape (chunk_size, Nbfun)\n                R_chunk = self.r_basis[active_dofs]\n                f_chunk = element_vectors[chunk_idx, :]\n\n\n                f_reduced_A += np.einsum('eia,ei-&gt;a', R_chunk, f_chunk, optimize=True)\n\n\n            if self.remainder &gt; 0:\n\n                chunk_idx = self.groupA[self.n_full_chunks * self.chunk_size :]\n                active_dofs = self.element_dofs[:, chunk_idx].T\n                R_chunk = self.r_basis[active_dofs] \n                f_chunk = element_vectors[chunk_idx, :]\n\n                f_reduced_A += np.einsum('eia,ei-&gt;a', R_chunk, f_chunk, optimize=True)\n\n            def compute_f_red(e):\n\n                local_mask = mask[:, e]\n\n                idx = self.mapping[self.element_dofs[:, e]][local_mask]\n\n                if idx.size == 0:\n                    return np.zeros((r,), dtype=self.dtype)\n                \n                R_free = self.r_basis[idx, :]\n                f_local = element_vectors[e, :]\n                f_local_free = f_local[local_mask]\n\n                return R_free.T @ (f_local_free)\n            \n            if self.groupB.size &gt; 0:\n\n                f_func = np.frompyfunc(compute_f_red, 1, 1)\n                f_red_B_obj = f_func(self.groupB)\n                f_red_B_list = [np.asarray(x, dtype=self.dtype) for x in f_red_B_obj]\n                f_reduced_B = np.sum(np.stack(f_red_B_list), axis=0)\n\n\n            else:\n\n                f_reduced_B = np.zeros((r,), dtype=self.dtype)\n\n            return f_reduced_A + f_reduced_B\n\n        f_reduced = compute_reduced_vector_in_chunks(element_vectors)\n\n\n        return f_reduced\n\n\n    def hyperreduction(self, **kwargs) -&gt; ndarray:\n        \"\"\"\n        Perform hyperreduction to assemble per-element reduced load contributions.\n\n        Parameters\n        ----------\n        **kwargs\n            Additional parameters passed to the form during hyperreduction.\n\n        Returns\n        -------\n        f_reduced : ndarray, shape (n_contribs, r)\n            Concatenated reduced load contributions for hyperreduction.\n        \"\"\"\n        # Extract local element load vectors.\n        # element_vectors has shape (n_elements, Nbfun)\n        \n\n        element_vectors = self.extract_element_vector(self.ubasis, **kwargs)\n\n        # Reduced dimension.\n        r = self.r\n\n\n        f_reduced = np.empty((0, r), dtype=self.r_basis.dtype)\n\n\n        for i in range(self.n_full_chunks):\n\n            chunk_idx = self.groupA[i * self.chunk_size : (i + 1) * self.chunk_size]\n            active_dofs = self.element_dofs[:, chunk_idx].T  # shape (chunk_size, Nbfun)\n            R_chunk = self.r_basis[active_dofs]\n            f_chunk = element_vectors[chunk_idx, :]      # shape (chunk_size, Nbfun)\n\n\n            # Perform a batch-wise operation\n\n            R_chunk_T = np.transpose(R_chunk, (0, 2, 1))             # shape: (chunk_size, r, Nbfun)\n            f_chunk_expanded = f_chunk[..., np.newaxis]              # shape: (chunk_size, Nbfun, 1)\n            reduced_chunk = np.matmul(R_chunk_T, f_chunk_expanded)     # shape: (chunk_size, r, 1)\n            reduced_chunk = reduced_chunk.squeeze(-1)                # shape: (chunk_size, r)\n            \n\n            # f_reduced = np.concatenate((f_reduced, np.matmul(R_chunk.T,f_chunk)), axis=0)\n            f_reduced = np.concatenate((f_reduced, reduced_chunk), axis=0)\n\n\n\n        if self.remainder &gt; 0:\n\n            chunk_idx = self.groupA[self.n_full_chunks * self.chunk_size :]\n            active_dofs = self.element_dofs[:, chunk_idx].T\n            R_chunk = self.r_basis[active_dofs]#.reshape(chunk_idx.size, element_dofs.shape[0], r)\n            f_chunk = element_vectors[chunk_idx, :]\n\n\n            # Perform a batch-wise operation\n\n            R_chunk_T = np.transpose(R_chunk, (0, 2, 1))             # shape: (chunk_size, r, Nbfun)\n            f_chunk_expanded = f_chunk[..., np.newaxis]              # shape: (chunk_size, Nbfun, 1)\n            reduced_chunk = np.matmul(R_chunk_T, f_chunk_expanded)     # shape: (chunk_size, r, 1)\n            reduced_chunk = reduced_chunk.squeeze(-1)                # shape: (chunk_size, r)\n\n\n            # f_reduced = np.concatenate((f_reduced, np.matmul(R_chunk.T,f_chunk)), axis=0)\n            f_reduced = np.concatenate((f_reduced, reduced_chunk), axis=0)\n\n\n\n        def compute_f_red(e):\n\n            local_mask = self.mask[:, e]\n            idx = self.mapping[self.element_dofs[:, e]][local_mask]\n\n            if idx.size == 0:\n                return np.zeros((r,), dtype=self.dtype)\n            \n            R_free = self.r_basis[idx, :]\n            f_local = element_vectors[e, :]\n            f_local_free = f_local[local_mask]\n            return R_free.T @ (f_local_free)\n        \n        if self.groupB.size &gt; 0:\n\n            f_func = np.frompyfunc(compute_f_red, 1, 1)\n            f_red_B_obj = f_func(self.groupB)\n            f_red_B_list = [np.asarray(x, dtype=self.dtype) for x in f_red_B_obj]\n            f_reduced_B = np.stack(f_red_B_list,axis=0)\n\n            f_reduced = np.concatenate((f_reduced, f_reduced_B), axis=0)\n\n        else:\n\n            zero_row = np.zeros((1, r), dtype=self.dtype)\n            f_reduced = np.concatenate((f_reduced, zero_row), axis=0)\n\n\n        del R_chunk, f_chunk, R_chunk_T, f_chunk_expanded, reduced_chunk, f_reduced_B     \n        gc.collect()\n\n        return f_reduced\n    \n\n    def extract_element_vector(self, basis: AbstractBasis, **kwargs):\n        \"\"\"\n        Extract local element load vectors for a linear form.\n\n        Computes per-element load contributions for each local basis function.\n\n        Parameters\n        ----------\n        basis : AbstractBasis\n            Finite element basis associated with the test function.\n        **kwargs\n            Additional keyword arguments passed to the form.\n\n        Returns\n        -------\n        element_vectors : ndarray, shape (n_elements, Nbfun)\n            Local load vectors for each element, where Nbfun is the number of local basis functions.\n        \"\"\"\n        nt = basis.nelems       # Number of elements\n        dx = basis.dx           # Quadrature weights per element\n\n        wdict = FormExtraParams({\n            **basis.default_parameters(),\n            **self._normalize_asm_kwargs(kwargs, basis),\n        })\n\n        # Allocate an array to hold the local contributions.\n        # Shape is (Nbfun, n_elements)\n        local_data = np.zeros((basis.Nbfun, nt), dtype=self.dtype)\n\n        if self.nthreads &lt;= 0:\n            for i in range(basis.Nbfun):\n                local_data[i, :] = self._kernel(basis.basis[i], wdict, dx)\n        else:\n            # Threaded computation for the linear form.\n            def threaded_kernel_vector(data, indices, basis_list, wdict, dx):\n                for i in indices:\n                    data[i, :] = self._kernel(basis_list[i], wdict, dx)\n\n            indices = np.arange(basis.Nbfun)\n            indices_chunks = np.array_split(indices, self.nthreads)\n            threads = [\n                Thread(\n                    target=threaded_kernel_vector,\n                    args=(local_data, chunk, basis.basis, wdict, dx)\n                )\n                for chunk in indices_chunks\n            ]\n            for t in threads:\n                t.start()\n            for t in threads:\n                t.join()\n\n        # Rearranging data from shape (Nbfun, n_elements) to (n_elements, Nbfun)\n        element_vectors = local_data.transpose(1, 0)\n        return element_vectors"
  },
  {
    "objectID": "src/skrom_rom_rom_error_est.html",
    "href": "src/skrom_rom_rom_error_est.html",
    "title": "Compute and visualize ROM error metrics for flat data reconstructions",
    "section": "",
    "text": "This module provides: - compute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm). - plot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up. - generate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console.\nThe rom folder contains core tools for reduced-order modeling, including: - Assembly abstractions for reduced bilinear and linear forms - Error evaluation and reporting utilities (this module) - Hyper-reduction and cubature integration tools\nAuthor: Suparno Bhattacharyya\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ptitprince as pt\nimport pandas as pd\n\ndef compute_rom_error_metrics_flat(u, u_rom, K=None):\n    \"\"\"\n    compute_rom_error_metrics_flat\n\n    Compute various error metrics between full-order and ROM reconstructions for flat data.\n\n    Parameters\n    ----------\n    u : array_like, shape (n_snapshots, n_space)\n        Full-order field, with each row representing a snapshot.\n    u_rom : array_like, shape (n_snapshots, n_space)\n        ROM reconstruction matching the shape of `u`.\n    K : array_like, shape (n_space, n_space), optional\n        Stiffness matrix for computing the energy-norm error.\n\n    Returns\n    -------\n    metrics : dict\n        Dictionary containing error metrics:\n        \n        time-dependent\n        ---------------\n        L2_error_time : ndarray, shape (n_snapshots,)\n            L2 norm of error per snapshot.\n        relative_L2_error_time : ndarray, shape (n_snapshots,)\n            Relative L2 error per snapshot.\n        RMSE_time : ndarray, shape (n_snapshots,)\n            Root mean square error per snapshot.\n        MAE_time : ndarray, shape (n_snapshots,)\n            Mean absolute error per snapshot.\n        time_avg_rel_L2_error : float\n            Average relative L2 error over all snapshots.\n\n        global\n        ------\n        L2_error : float\n            Global L2 norm of the error.\n        relative_L2_error : float\n            Global relative L2 error.\n        Linf_error : float\n            Maximum absolute error.\n        relative_Linf_error : float\n            Maximum relative error.\n        RMSE : float\n            Global root mean square error.\n        MAE : float\n            Global mean absolute error.\n        R2 : float\n            Coefficient of determination.\n        explained_variance : float\n            Variance explained by the ROM.\n        quantiles : dict\n            median_error : float\n                Median absolute error.\n            p95_error : float\n                95th percentile of absolute errors.\n\n        optional\n        --------\n        energy_norm_error : float\n            Energy-norm error computed if `K` is provided.\n    \"\"\"\n    N_sample = len(u)\n    u   = np.array(u)\n    u_r = np.array(u_rom)\n    if u.shape != u_r.shape:\n        raise ValueError(\"u and u_rom must have the same shape\")\n    # n_snap, n_space = u.shape\n    err = u - u_r\n    metrics = {}\n\n    # --- time‐dependent ---\n    # L2, rel L2, RMSE, MAE per snapshot\n    L2_t    = np.linalg.norm(err, axis=1)/N_sample\n    relL2_t = L2_t / np.linalg.norm(u, axis=1)\n    RMSE_t  = np.sqrt(np.mean(err**2, axis=1))\n    MAE_t   = np.mean(np.abs(err), axis=1)\n\n    metrics.update({\n      'L2_error_time':           L2_t,\n      'relative_L2_error_time':  relL2_t,\n      'RMSE_time':               RMSE_t,\n      'MAE_time':                MAE_t,\n      'time_avg_rel_L2_error':   np.mean(relL2_t),\n    })\n\n    # --- global ---\n    flat_u   = u.ravel()\n    flat_err = err.ravel()\n\n    L2   = np.linalg.norm(flat_err)/N_sample\n    relL2= L2 / (np.linalg.norm(flat_u)/N_sample)\n    Linf = np.max(np.abs(flat_err))\n    relLinf = Linf/np.max(np.abs(flat_u))\n    RMSE = np.sqrt(np.mean(flat_err**2))\n    MAE  = np.mean(np.abs(flat_err))\n\n    ss_res = np.sum(flat_err**2)\n    ss_tot = np.sum((flat_u - flat_u.mean())**2)\n    R2     = 1 - ss_res/ss_tot\n    expvar = np.var(u_r.ravel()) / np.var(flat_u)\n\n    metrics.update({\n      'L2_error':           L2,\n      'relative_L2_error':  relL2,\n      'Linf_error':         Linf,\n      'relative_Linf_error':  relLinf,\n      'RMSE':               RMSE,\n      'MAE':                MAE,\n      'R2':                 R2,\n      'explained_variance': expvar,\n      'quantiles': {\n         'median_error': np.percentile(flat_err, 50),\n         'p95_error':   np.percentile(np.abs(flat_err), 95)\n      }\n    })\n\n    if K is not None:\n        d = flat_err\n        metrics['energy_norm_error'] = np.sqrt(d @ (K @ d))\n\n    return metrics\n\n\ndef plot_rom_error_diagnostics_flat(u, u_rom, rom_relative_error, rom_speed_up, sim_axis, metrics, spatial_shape=None):\n    \"\"\"\n    plot_rom_error_diagnostics_flat\n\n    Visualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n    Parameters\n    ----------\n    u : array_like, shape (n_snapshots, n_space)\n        Full-order field for diagnostics.\n    u_rom : array_like, shape (n_snapshots, n_space)\n        ROM reconstruction matching shape of `u`.\n    rom_relative_error : array_like, shape (n_snapshots,)\n        Relative error per snapshot.\n    rom_speed_up : array_like, shape (n_snapshots,)\n        Speed-up factors per snapshot.\n    sim_axis : tuple of str\n        Axis labels for true vs ROM scatter (xlabel, ylabel).\n    metrics : dict\n        Dictionary of error metrics from compute_rom_error_metrics_flat.\n    spatial_shape : tuple of int, optional\n        Shape (nx, ny) to reshape spatial data for pcolormesh plots.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    u   = np.array(u)\n    u_r = np.array(u_rom)\n\n    n_snap, *_ = u.shape\n\n    # 1) scatter true vs. ROM\n    fig, ax = plt.subplots()\n    ax.scatter(u.ravel(), u_r.ravel(), s=1)\n    ax.set_xlabel(sim_axis[0])\n    ax.set_ylabel(sim_axis[1])\n    ax.set_title( sim_axis[0] + ' vs. ' + sim_axis[1])\n    ax.axis('equal')\n    plt.show()\n    \n   \n    # 2) spatial snapshots if shape provided\n    if spatial_shape is not None:\n        for idx in (0, n_snap//2, n_snap-1):\n            for name, field in [('True', u), ('ROM', u_r), ('Error', u - u_r)]:\n                snap = field[idx].reshape(spatial_shape)\n                fig, ax = plt.subplots()\n                pcm = ax.pcolormesh(snap, shading='auto')\n                fig.colorbar(pcm, ax=ax)\n                ax.set_title(f\"{name} @ snapshot {idx}\")\n                ax.set_xlabel('x-index')\n                ax.set_ylabel('y-index')\n                plt.show()\n    else:\n        print(\"spatial_shape not given → skipping spatial snapshots.\")\n\n    df_B = pd.DataFrame({'':'','Relative error (log)%':np.log10(rom_relative_error)})\n    # \n    fig, ax = plt.subplots(figsize=(8.7, 3))\n    pt.RainCloud(x = '', y = 'Relative error (log)%', data = df_B, palette = \"viridis\", bw = 0.2,\n        width_viol = 1., ax = ax, orient = \"h\",pointplot = False, dodge=False, alpha=1.0, width_box = 0.35, linewidth=1, point_size =6.0, move=0.2)\n    \n    # ===\n    \n    df_D = pd.DataFrame({'':'','Speed-up':rom_speed_up})\n\n    fig, ax = plt.subplots(figsize=(8.6, 2))\n    pt.RainCloud(x = '', y = 'Speed-up', data = df_D, palette = \"plasma\",\n        width_viol = 1.0, ax = ax, orient = \"h\",pointplot = False, dodge=True, alpha=1.0, width_box = 0.25, linewidth=1, point_size =6.0)\n    print(\"-\" * 500)   # simple hyphens\n\ndef generate_rom_error_report(metrics, name=\"ROM Accuracy Report\"):\n    \"\"\"\n    generate_rom_error_report\n\n    Print a structured summary of ROM error metrics.\n\n    Parameters\n    ----------\n    metrics : dict\n        Error metrics dictionary from compute_rom_error_metrics_flat.\n    name : str, optional\n        Title of the report. Defaults to \"ROM Accuracy Report\".\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\"=\"*len(name))\n    print(name)\n    print(\"=\"*len(name))\n\n    # --- Global Metrics ---\n    print(\"\\nGlobal Errors:\")\n    print(f\"{'L2 Error:':&lt;25} {metrics['L2_error']:.4e}\")\n    print(f\"{'Relative L2 Error:':&lt;25} {metrics['relative_L2_error']:.4e}\")\n    print(f\"{'L∞ Error:':&lt;25} {metrics['Linf_error']:.4e}\")\n    print(f\"{'Relative L∞ Error:':&lt;25} {metrics['relative_Linf_error']:.4e}\")\n\n    print(f\"{'RMSE:':&lt;25} {metrics['RMSE']:.4e}\")\n    print(f\"{'MAE:':&lt;25} {metrics['MAE']:.4e}\")\n\n    if 'energy_norm_error' in metrics:\n        print(f\"{'Energy Norm Error:':&lt;25} {metrics['energy_norm_error']:.4e}\")\n\n    # --- Statistical Fit Metrics ---\n    print(\"\\nStatistical Fit:\")\n    print(f\"{'R² Score:':&lt;25} {metrics['R2']:.4f}\")\n    print(f\"{'Explained Variance:':&lt;25} {metrics['explained_variance']:.4f}\")\n\n    # --- Error Distribution ---\n    q = metrics['quantiles']\n    print(\"\\nError Distribution:\")\n    print(f\"{'Median Error:':&lt;25} {q['median_error']:.4e}\")\n    print(f\"{'95th Percentile Error:':&lt;25} {q['p95_error']:.4e}\")\n\n    # --- Time-Dependent Errors ---\n    print(\"\\nTime/Parameter-Dependent Errors:\")\n    print(f\"{'Average Rel L2 Error over time/parameter:':&lt;35} {metrics['time_avg_rel_L2_error']:.4e}\")\n    print(f\"{'Max Rel L2 Error over time/parameter:':&lt;35} {np.max(metrics['relative_L2_error_time']):.4e}\")\n    print(f\"{'Min Rel L2 Error over time/parameter:':&lt;35} {np.min(metrics['relative_L2_error_time']):.4e}\")\n    print(\"―\" * 500)   # — EM DASH × 40, or…"
  },
  {
    "objectID": "src/skrom_rom_rom_error_est_t.html",
    "href": "src/skrom_rom_rom_error_est_t.html",
    "title": "Compute and visualize ROM error metrics for flat (vectorized) data reconstructions",
    "section": "",
    "text": "This module provides: - compute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm). - plot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up. - generate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console."
  },
  {
    "objectID": "src/skrom_rom_rom_error_est_t.html#notes-on-shapes",
    "href": "src/skrom_rom_rom_error_est_t.html#notes-on-shapes",
    "title": "Compute and visualize ROM error metrics for flat (vectorized) data reconstructions",
    "section": "Notes on shapes",
    "text": "Notes on shapes\nSupported shapes for u and u_rom: - (n_snapshots, n_space) - (n_snapshots, n_time, n_space)\nIf your data uses a different axis order, pass snapshot_axis/time_axis/space_axis.\nfrom __future__ import annotations\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\ndef _move_axes_to_sts(a: np.ndarray,\n                      snapshot_axis: int,\n                      time_axis: int | None,\n                      space_axis: int) -&gt; np.ndarray:\n    \"\"\"\n    Return a view of `a` with axes ordered as (snapshot, time?, space).\n\n    - If a.ndim == 2, output is (n_snap, n_space)\n    - If a.ndim == 3, output is (n_snap, n_time, n_space)\n    \"\"\"\n    a = np.asarray(a)\n\n    if a.ndim == 2:\n        # order as (snap, space)\n        if time_axis is not None:\n            raise ValueError(\"time_axis must be None for 2D arrays.\")\n        return np.moveaxis(a, (snapshot_axis, space_axis), (0, 1))\n\n    if a.ndim == 3:\n        if time_axis is None:\n            raise ValueError(\"time_axis must be provided for 3D arrays.\")\n        return np.moveaxis(a, (snapshot_axis, time_axis, space_axis), (0, 1, 2))\n\n    raise ValueError(f\"Expected 2D or 3D array, got ndim={a.ndim}.\")\n\n\ndef compute_rom_error_metrics_flat(u,\n                                  u_rom,\n                                  K: np.ndarray | None = None,\n                                  *,\n                                  snapshot_axis: int = 0,\n                                  time_axis: int | None = None,\n                                  space_axis: int = -1,\n                                  eps: float = 1e-30) -&gt; dict:\n    \"\"\"\n    Compute various error metrics between full-order and ROM reconstructions.\n\n    Parameters\n    ----------\n    u, u_rom\n        Full-order and ROM fields. Supported shapes:\n          - (n_snapshots, n_space)\n          - (n_snapshots, n_time, n_space)\n    K : array_like, optional\n        Stiffness matrix for energy-norm metrics. Must be (n_space, n_space).\n        If provided and u is 3D, the energy terms are accumulated over (snapshot, time).\n    snapshot_axis, time_axis, space_axis\n        Axis indices used if u has a different ordering.\n        For 2D arrays, keep time_axis=None.\n    eps\n        Small number to avoid division-by-zero.\n\n    Returns\n    -------\n    metrics : dict\n        Contains time-dependent and global metrics. For 3D inputs, time-dependent\n        arrays have shape (n_snapshots, n_time).\n    \"\"\"\n    u = np.asarray(u)\n    u_r = np.asarray(u_rom)\n    if u.shape != u_r.shape:\n        raise ValueError(f\"u and u_rom must have the same shape. Got {u.shape} vs {u_r.shape}\")\n\n    # canonicalize to (snap, time?, space)\n    if u.ndim == 2:\n        U = _move_axes_to_sts(u, snapshot_axis=snapshot_axis, time_axis=None, space_axis=space_axis)\n        Ur = _move_axes_to_sts(u_r, snapshot_axis=snapshot_axis, time_axis=None, space_axis=space_axis)\n        has_time = False\n    else:\n        if time_axis is None:\n            # common default for 3D: (snap, time, space)\n            time_axis = 1\n        U = _move_axes_to_sts(u, snapshot_axis=snapshot_axis, time_axis=time_axis, space_axis=space_axis)\n        Ur = _move_axes_to_sts(u_r, snapshot_axis=snapshot_axis, time_axis=time_axis, space_axis=space_axis)\n        has_time = True\n\n    err = U - Ur\n    metrics: dict = {}\n\n    # ---------- time-dependent (per snapshot, and per time if present) ----------\n    # L2 per sample in the \"space\" direction\n    if not has_time:\n        # (n_snap,)\n        L2_t = np.linalg.norm(err, axis=-1)\n        U_norm_t = np.linalg.norm(U, axis=-1)\n        relL2_t = L2_t / np.maximum(U_norm_t, eps)\n        RMSE_t = np.sqrt(np.mean(err**2, axis=-1))\n        MAE_t = np.mean(np.abs(err), axis=-1)\n\n        metrics.update({\n            \"L2_error_time\": L2_t,\n            \"relative_L2_error_time\": relL2_t,\n            \"RMSE_time\": RMSE_t,\n            \"MAE_time\": MAE_t,\n            \"time_avg_rel_L2_error\": float(np.mean(relL2_t)),\n        })\n    else:\n        # (n_snap, n_time)\n        L2_st = np.linalg.norm(err, axis=-1)\n        U_norm_st = np.linalg.norm(U, axis=-1)\n        relL2_st = L2_st / np.maximum(U_norm_st, eps)\n        RMSE_st = np.sqrt(np.mean(err**2, axis=-1))\n        MAE_st = np.mean(np.abs(err), axis=-1)\n\n        # convenient aggregations per snapshot (mean over time)\n        relL2_snap = np.mean(relL2_st, axis=1)\n\n        metrics.update({\n            \"L2_error_time\": L2_st,\n            \"relative_L2_error_time\": relL2_st,\n            \"RMSE_time\": RMSE_st,\n            \"MAE_time\": MAE_st,\n            \"relative_L2_error_snapshot_mean\": relL2_snap,\n            \"time_avg_rel_L2_error\": float(np.mean(relL2_st)),\n        })\n\n    # ---------- global metrics (flatten over snapshot/time/space) ----------\n    flat_u = U.reshape(-1)\n    flat_err = err.reshape(-1)\n    flat_abs_err = np.abs(flat_err)\n\n    L2 = float(np.linalg.norm(flat_err))\n    relL2 = float(L2 / np.maximum(np.linalg.norm(flat_u), eps))\n    Linf = float(np.max(flat_abs_err))\n    relLinf = float(Linf / np.maximum(np.max(np.abs(flat_u)), eps))\n    RMSE = float(np.sqrt(np.mean(flat_err**2)))\n    MAE = float(np.mean(flat_abs_err))\n\n    # R²\n    ss_res = float(np.sum(flat_err**2))\n    ss_tot = float(np.sum((flat_u - flat_u.mean())**2))\n    R2 = float(1.0 - ss_res / ss_tot) if ss_tot &gt; eps else float(\"nan\")\n\n    # explained variance: 1 - Var(err)/Var(u)\n    var_u = float(np.var(flat_u))\n    var_e = float(np.var(flat_err))\n    expvar = float(1.0 - var_e / var_u) if var_u &gt; eps else float(\"nan\")\n\n    metrics.update({\n        \"L2_error\": L2,\n        \"relative_L2_error\": relL2,\n        \"Linf_error\": Linf,\n        \"relative_Linf_error\": relLinf,\n        \"RMSE\": RMSE,\n        \"MAE\": MAE,\n        \"R2\": R2,\n        \"explained_variance\": expvar,\n        \"quantiles\": {\n            \"median_abs_error\": float(np.percentile(flat_abs_err, 50)),\n            \"p95_abs_error\": float(np.percentile(flat_abs_err, 95)),\n        },\n    })\n\n    # ---------- optional energy norm ----------\n    if K is not None:\n        K = np.asarray(K)\n        n_space = U.shape[-1]\n        if K.shape != (n_space, n_space):\n            raise ValueError(f\"K must be shape (n_space, n_space)=({n_space},{n_space}). Got {K.shape}\")\n\n        # accumulate energy over samples (snapshot, time if present)\n        # energy(err) = sum_i e_i^T K e_i ; energy(u) = sum_i u_i^T K u_i\n        E_err = 0.0\n        E_u = 0.0\n\n        if not has_time:\n            # iterate snapshots\n            for i in range(U.shape[0]):\n                e = err[i]\n                uu = U[i]\n                E_err += float(e @ (K @ e))\n                E_u += float(uu @ (K @ uu))\n        else:\n            # iterate snapshot & time\n            for i in range(U.shape[0]):\n                for t in range(U.shape[1]):\n                    e = err[i, t]\n                    uu = U[i, t]\n                    E_err += float(e @ (K @ e))\n                    E_u += float(uu @ (K @ uu))\n\n        metrics[\"energy_norm_error\"] = float(np.sqrt(max(E_err, 0.0)))\n        metrics[\"relative_energy_norm_error\"] = float(\n            metrics[\"energy_norm_error\"] / np.maximum(np.sqrt(max(E_u, 0.0)), eps)\n        )\n\n    return metrics\n\n\ndef generate_rom_error_report(metrics, name=\"ROM Accuracy Report\"):\n    \"\"\"\n    Print a structured summary of ROM error metrics.\n\n    Parameters\n    ----------\n    metrics : dict\n        Error metrics dictionary from compute_rom_error_metrics_flat.\n    name : str, optional\n        Title of the report.\n    \"\"\"\n    print(\"=\" * len(name))\n    print(name)\n    print(\"=\" * len(name))\n\n    # --- Global Metrics ---\n    print(\"\\nGlobal Errors:\")\n    print(f\"{'L2 Error:':&lt;32} {metrics['L2_error']:.4e}\")\n    print(f\"{'Relative L2 Error:':&lt;32} {metrics['relative_L2_error']:.4e}\")\n    print(f\"{'L∞ Error:':&lt;32} {metrics['Linf_error']:.4e}\")\n    print(f\"{'Relative L∞ Error:':&lt;32} {metrics['relative_Linf_error']:.4e}\")\n    print(f\"{'RMSE:':&lt;32} {metrics['RMSE']:.4e}\")\n    print(f\"{'MAE:':&lt;32} {metrics['MAE']:.4e}\")\n\n    if \"energy_norm_error\" in metrics:\n        print(f\"{'Energy Norm Error:':&lt;32} {metrics['energy_norm_error']:.4e}\")\n    if \"relative_energy_norm_error\" in metrics:\n        print(f\"{'Relative Energy Norm Error:':&lt;32} {metrics['relative_energy_norm_error']:.4e}\")\n\n    # --- Statistical Fit Metrics ---\n    print(\"\\nStatistical Fit:\")\n    print(f\"{'R² Score:':&lt;32} {metrics['R2']:.4f}\")\n    print(f\"{'Explained Variance:':&lt;32} {metrics['explained_variance']:.4f}\")\n\n    # --- Error Distribution ---\n    q = metrics[\"quantiles\"]\n    print(\"\\nError Distribution (absolute):\")\n    print(f\"{'Median Abs Error:':&lt;32} {q['median_abs_error']:.4e}\")\n    print(f\"{'95th Percentile Abs Error:':&lt;32} {q['p95_abs_error']:.4e}\")\n\n    # --- Time-Dependent Errors ---\n    print(\"\\nTime/Parameter-Dependent Errors:\")\n    print(f\"{'Average Relative L2 over samples:':&lt;40} {metrics['time_avg_rel_L2_error']:.4e}\")\n\n    rel_t = metrics.get(\"relative_L2_error_time\", None)\n    if rel_t is not None:\n        rel_flat = np.asarray(rel_t).reshape(-1)\n        print(f\"{'Max Relative L2 over samples:':&lt;40} {np.max(rel_flat):.4e}\")\n        print(f\"{'Min Relative L2 over samples:':&lt;40} {np.min(rel_flat):.4e}\")\n\n    print(\"—\" * 120)\n\n\ndef plot_rom_param_diagnostics_t(\n    u, u_rom,\n    *,\n    l2_per_param=None,          # (p,) optional\n    speedup_per_param=None,     # (p,) optional\n    param_labels=None,          # length p optional\n    eps=1e-16,\n    log_error=True,\n    use_raincloud=True,         # needs pandas + ptitprince\n):\n    \"\"\"\n    u, u_rom: (p, t, dof)\n\n    Plots:\n      1) per-parameter aggregated relative error (bar)\n      2) per-parameter per-timestep error (boxplot)\n      3) error vs speed-up (scatter) if speedup given\n      4) L2 norms (bar) if l2 given\n      5) raincloud: rel_err_p distribution (across parameters)\n      6) raincloud: rel_err_pt grouped by parameter (across timesteps)\n      7) raincloud: speedup distribution (across parameters) if speedup given\n    \"\"\"\n    u = np.asarray(u)\n    u_rom = np.asarray(u_rom)\n\n    if u.shape != u_rom.shape or u.ndim != 3:\n        raise ValueError(f\"Expected u and u_rom as (p,t,dof) with same shape; got {u.shape} vs {u_rom.shape}\")\n\n    p, t, dof = u.shape\n\n    if param_labels is None:\n        param_labels = [f\"p{i}\" for i in range(p)]\n    if len(param_labels) != p:\n        raise ValueError(f\"param_labels must have length p={p}; got {len(param_labels)}\")\n\n    if l2_per_param is not None:\n        l2_per_param = np.asarray(l2_per_param).reshape(-1)\n        if l2_per_param.size != p:\n            raise ValueError(f\"l2_per_param must have length p={p}; got {l2_per_param.size}\")\n\n    if speedup_per_param is not None:\n        speedup_per_param = np.asarray(speedup_per_param).reshape(-1)\n        if speedup_per_param.size != p:\n            raise ValueError(f\"speedup_per_param must have length p={p}; got {speedup_per_param.size}\")\n\n    diff = u - u_rom\n\n    # per (p,t) relative error (L2 over dof)\n    num_pt = np.linalg.norm(diff, axis=2)                 # (p,t)\n    den_pt = np.linalg.norm(u, axis=2)                    # (p,t)\n    rel_err_pt = num_pt / np.maximum(den_pt, eps)         # (p,t)\n\n    # per p relative error (L2 over time+dof)\n    num_p = np.linalg.norm(diff.reshape(p, -1), axis=1)   # (p,)\n    den_p = np.linalg.norm(u.reshape(p, -1), axis=1)      # (p,)\n    rel_err_p = num_p / np.maximum(den_p, eps)            # (p,)\n\n    # ------------- helpers -------------\n    def _maybe_log(v):\n        v = np.asarray(v)\n        return np.log10(np.maximum(v, eps)) if log_error else v\n\n    def _raincloud_1d(values, xlabel, figsize=(8.7, 2.4)):\n        import pandas as pd\n        import ptitprince as pt\n\n        values = np.asarray(values).reshape(-1)\n        df = pd.DataFrame({\"group\": [\"\"] * values.size, \"val\": values})\n\n        fig, ax = plt.subplots(figsize=figsize)\n        pt.RainCloud(\n            x=\"group\", y=\"val\", data=df,\n            bw=0.2,\n            width_viol=1.0,\n            orient=\"h\",\n            pointplot=False,\n            dodge=False,\n            alpha=1.0,\n            width_box=0.30,\n            linewidth=1,\n            point_size=4.5,\n            move=0.2,\n            ax=ax,\n        )\n        ax.set_xlabel(xlabel)\n        ax.set_ylabel(\"\")\n        fig.tight_layout()\n        plt.show()\n\n    # def _raincloud_grouped(groups, values, xlabel, figsize=(9.5, 4.0)):\n    #     import pandas as pd\n    #     import ptitprince as pt\n\n    #     df = pd.DataFrame({\"group\": groups, \"val\": values})\n\n    #     fig, ax = plt.subplots(figsize=figsize)\n    #     pt.RainCloud(\n    #         x=\"group\", y=\"val\", data=df,\n    #         bw=0.2,\n    #         width_viol=1.0,\n    #         orient=\"v\",\n    #         pointplot=False,\n    #         dodge=True,\n    #         alpha=1.0,\n    #         width_box=0.25,\n    #         linewidth=1,\n    #         point_size=2.5,\n    #         move=0.15,\n    #         ax=ax,\n    #     )\n    #     ax.set_xlabel(\"parameter\")\n    #     ax.set_ylabel(xlabel)\n    #     ax.set_title(\"Raincloud grouped by parameter\")\n    #     fig.tight_layout()\n    #     plt.show()\n\n    # -------- 2) per-parameter distribution over time (boxplot) --------\n    data = [rel_err_pt[i, :] for i in range(p)]\n    data = [_maybe_log(d) for d in data]\n    fig, ax = plt.subplots(figsize=(9.5, 3.6))\n    ax.boxplot(data, showfliers=False)\n    ax.set_xticks(np.arange(1, p + 1))\n    ax.set_xticklabels(param_labels)\n    ax.set_xlabel(\"parameter\")\n    ax.set_ylabel(\"log10(relative error per timestep)\" if log_error else \"relative error per timestep\")\n    ax.set_title(\"Error distribution over timesteps (by parameter)\")\n    fig.tight_layout()\n    plt.show()\n\n    # -------- 4) L2 norms (bar) --------\n    if l2_per_param is not None:\n        fig, ax = plt.subplots(figsize=(9.5, 3.2))\n        ax.bar(np.arange(p), l2_per_param)\n        ax.set_xticks(np.arange(p))\n        ax.set_xticklabels(param_labels)\n        ax.set_xlabel(\"parameter\")\n        ax.set_ylabel(\"% L2 norm\")\n        ax.set_title(\"% L2 error by parameter\")\n        fig.tight_layout()\n        plt.show()\n\n    # -------- 5-7) raincloud plots --------\n    if use_raincloud:\n        try:\n            # 5) aggregated error across parameters\n            _raincloud_1d(\n                _maybe_log(rel_err_p),\n                \"log10(relative error) across parameters\" if log_error else \"relative error across parameters\",\n                figsize=(8.7, 2.4),\n            )\n\n            # 7) speed-up across parameters\n            if speedup_per_param is not None:\n                _raincloud_1d(speedup_per_param, \"speed-up across parameters\", figsize=(8.7, 2.2))\n\n        except Exception as e:\n            print(f\"Raincloud unavailable ({type(e).__name__}: {e}). Fallback plots will be shown.\")\n            use_raincloud = False\n\n    if not use_raincloud:\n        # fallback for aggregated error\n        fig, ax = plt.subplots(figsize=(8.7, 2.4))\n        ax.hist(_maybe_log(rel_err_p), bins=30)\n        ax.set_xlabel(\"log10(relative error) across parameters\" if log_error else \"relative error across parameters\")\n        ax.set_ylabel(\"count\")\n        fig.tight_layout()\n        plt.show()\n\n        # fallback for speed-up\n        if speedup_per_param is not None:\n            fig, ax = plt.subplots(figsize=(8.7, 2.2))\n            ax.boxplot(speedup_per_param, vert=False)\n            ax.set_xlabel(\"speed-up across parameters\")\n            ax.set_yticks([])\n            fig.tight_layout()\n            plt.show()\n\n    return {\n        \"rel_err_p\": rel_err_p,       # (p,)\n        \"rel_err_pt\": rel_err_pt,     # (p,t)\n        \"l2_per_param\": l2_per_param,\n        \"speedup_per_param\": speedup_per_param,\n    }"
  },
  {
    "objectID": "src/skrom_rom_utils.html",
    "href": "src/skrom_rom_utils.html",
    "title": "Utilities for ROM workflows",
    "section": "",
    "text": "The module includes functions for: - snapshot index splitting for training and testing - parameter sampling (Sobol, Latin hypercube, Gaussian) - basis updates by deflation and augmentation - reconstruction from reduced to full coordinates - ROM data save/load helpers - Newton solvers for reduced and hyper-reduced systems - residual collection routines used in hyperreduction"
  },
  {
    "objectID": "src/skrom_rom_utils.html#notes",
    "href": "src/skrom_rom_utils.html#notes",
    "title": "Utilities for ROM workflows",
    "section": "Notes",
    "text": "Notes\nAuthors: Suparno Bhattacharyya; Ali Hamza Abidi Syed ““” ““” Utilities used in ROM workflows."
  },
  {
    "objectID": "src/skrom_rom_utils.html#contents",
    "href": "src/skrom_rom_utils.html#contents",
    "title": "Utilities for ROM workflows",
    "section": "Contents",
    "text": "Contents\n\nSnapshot index splitting for training and testing\nSample generation (Sobol, LHS, Gaussian)\nBasis update by deflation and augmentation\nReconstruction from reduced coordinates to full coordinates\nROM data save/load helpers\nNewton solvers used in ROM and hyper-ROM steps\nResidual collection helpers for hyperreduction\n\nfrom skrom.utils.imports import *\nfrom scipy.linalg.blas import dgemm, sgemm\n\n\ndef train_test_split(N_snap, N_sel=None, train_percentage=0.8):\n    \"\"\"\n    Create boolean masks that split snapshot indices into train and test sets.\n\n    Parameters\n    ----------\n    N_snap : int\n        Count of snapshots.\n    N_sel : int or None\n        Count of indices to select before the split. If None, use all indices.\n    train_percentage : float\n        Fraction assigned to the train set.\n\n    Returns\n    -------\n    train_mask : ndarray[bool], shape (N_snap,)\n        Mask for train indices.\n    test_mask : ndarray[bool], shape (N_snap,)\n        Mask for test indices.\n    \"\"\"\n    indices = np.random.permutation(N_snap)\n\n    if N_sel is not None:\n        indices = np.random.choice(indices, N_sel, replace=False)\n\n    train_set_size = int(N_snap * train_percentage)\n\n    train_mask = np.zeros(N_snap, dtype=bool)\n    test_mask = np.zeros(N_snap, dtype=bool)\n\n    train_mask[indices[:train_set_size]] = True\n    test_mask[indices[train_set_size:]] = True\n\n    return train_mask, test_mask\n\n\ndef latin_hypercube_train_test_split(N_snap, train_percentage=0.8):\n    \"\"\"\n    Create train/test masks by ordering indices from a Latin hypercube draw.\n\n    Parameters\n    ----------\n    N_snap : int\n        Count of snapshots.\n    train_percentage : float\n        Fraction assigned to the train set.\n\n    Returns\n    -------\n    train_mask : ndarray[bool], shape (N_snap,)\n        Mask for train indices.\n    test_mask : ndarray[bool], shape (N_snap,)\n        Mask for test indices.\n    \"\"\"\n    LHS_indices = lhs(N_snap, samples=N_snap, criterion=\"maximin\")\n    LHS_indices = np.argsort(LHS_indices[:, 0])\n\n    train_set_size = int(N_snap * train_percentage)\n\n    train_mask = np.zeros(N_snap, dtype=bool)\n    test_mask = np.zeros(N_snap, dtype=bool)\n\n    train_mask[LHS_indices[:train_set_size]] = True\n    test_mask[LHS_indices[train_set_size:]] = True\n\n    return train_mask, test_mask\n\n\ndef sobol_train_test_split(N_snap, train_percentage=0.8):\n    \"\"\"\n    Create train/test masks by ordering indices from a Sobol draw.\n\n    Parameters\n    ----------\n    N_snap : int\n        Count of snapshots.\n    train_percentage : float\n        Fraction assigned to the train set.\n\n    Returns\n    -------\n    train_mask : ndarray[bool], shape (N_snap,)\n        Mask for train indices.\n    test_mask : ndarray[bool], shape (N_snap,)\n        Mask for test indices.\n    \"\"\"\n    m = int(np.ceil(np.log2(N_snap)))\n    sobol_gen = Sobol(d=1)\n\n    sobol_indices = sobol_gen.random_base2(m=m)\n    sobol_indices = sobol_indices.flatten()[:N_snap]\n    sobol_indices = np.argsort(sobol_indices)\n\n    train_set_size = int(N_snap * train_percentage)\n\n    train_mask = np.zeros(N_snap, dtype=bool)\n    test_mask = np.zeros(N_snap, dtype=bool)\n\n    train_mask[sobol_indices[:train_set_size]] = True\n    test_mask[sobol_indices[train_set_size:]] = True\n\n    return train_mask, test_mask\n\n\ndef generate_sobol(dimensions, num_points, bounds):\n    \"\"\"\n    Generate Sobol samples and scale them to bounds.\n\n    Parameters\n    ----------\n    dimensions : int\n        Count of parameters.\n    num_points : int\n        Count of samples. Input is used as 2**m with m = log2(num_points).\n    bounds : list[tuple[float, float]]\n        (lower, upper) for each parameter.\n\n    Returns\n    -------\n    scaled_samples : ndarray, shape (num_points, dimensions)\n        Samples in parameter space.\n    \"\"\"\n    sobol = Sobol(d=dimensions)\n    samples = sobol.random_base2(m=int(np.log2(num_points)))\n    scaled_samples = np.empty_like(samples)\n\n    for i in range(dimensions):\n        lower, upper = bounds[i]\n        scaled_samples[:, i] = samples[:, i] * (upper - lower) + lower\n\n    return scaled_samples\n\n\ndef generate_lhs(dimensions, num_points, bounds):\n    \"\"\"\n    Generate Latin hypercube samples and scale them to bounds.\n\n    Parameters\n    ----------\n    dimensions : int\n        Count of parameters.\n    num_points : int\n        Count of samples.\n    bounds : list[tuple[float, float]]\n        (lower, upper) for each parameter.\n\n    Returns\n    -------\n    scaled_samples : ndarray, shape (num_points, dimensions)\n        Samples in parameter space.\n    \"\"\"\n    lhs_dist = LatinHypercube(d=dimensions)\n    samples = lhs_dist.random(n=num_points)\n    scaled_samples = np.empty_like(samples)\n\n    for i in range(dimensions):\n        lower, upper = bounds[i]\n        scaled_samples[:, i] = samples[:, i] * (upper - lower) + lower\n\n    return scaled_samples\n\n\ndef generate_gaussian_samples(dimensions, num_points, bounds):\n    \"\"\"\n    Generate samples from normal draws based on bounds.\n\n    Mean is (lower+upper)/2.\n    Std is (upper-lower)/5.\n\n    Parameters\n    ----------\n    dimensions : int\n        Count of parameters.\n    num_points : int\n        Count of samples.\n    bounds : list[tuple[float, float]]\n        (lower, upper) for each parameter.\n\n    Returns\n    -------\n    samples : ndarray, shape (num_points, dimensions)\n        Samples from normal draws. No clipping is applied.\n    \"\"\"\n    samples = np.zeros((num_points, dimensions))\n    means = []\n    std_devs = []\n\n    for lower, upper in bounds:\n        mean = (upper + lower) / 2\n        std_dev = (upper - lower) / 5\n        means.append(mean)\n        std_devs.append(std_dev)\n\n    for i in range(dimensions):\n        samples[:, i] = np.random.normal(loc=means[i], scale=std_devs[i], size=num_points)\n\n    return samples\n\n\ndef update_basis(V, W_mu, max_modes=5):\n    \"\"\"\n    Update a basis by deflating snapshots and appending modes from an SVD.\n\n    Steps\n    -----\n    1) Deflate snapshots: W_deflated = W_mu - V(V^T W_mu)\n    2) Compute SVD of W_deflated\n    3) Append up to max_modes left singular vectors\n    4) Re-orthonormalize by QR\n\n    Parameters\n    ----------\n    V : ndarray, shape (N_h, r_old)\n        Basis matrix.\n    W_mu : ndarray, shape (N_h, N_t)\n        Snapshot matrix for one parameter value.\n    max_modes : int\n        Cap on appended modes.\n\n    Returns\n    -------\n    V_new : ndarray, shape (N_h, r_old + k)\n        Updated basis matrix.\n    \"\"\"\n    W_deflated = W_mu - V @ (V.T @ W_mu)\n\n    U_new, _, _ = np.linalg.svd(W_deflated, full_matrices=False)\n\n    V_combined = np.hstack([V, U_new[:, :max_modes]])\n\n    V_new, _ = qr(V_combined, mode=\"economic\")\n\n    projection_error = np.linalg.norm(W_mu - V_new @ (V_new.T @ W_mu))\n    print(\"Projection error after update (relative):\", projection_error / np.linalg.norm(W_mu))\n\n    return V_new\n\n\ndef reconstruct_solution(u_reduced, V_sel, mean):\n    \"\"\"\n    Map reduced coordinates to full coordinates and add the mean.\n\n    Parameters\n    ----------\n    u_reduced : ndarray\n        Reduced coordinates. Shape can be (r,) or (n, r) depending on usage.\n    V_sel : ndarray, shape (N_h, r)\n        Basis matrix used for reconstruction.\n    mean : ndarray, shape (N_h,)\n        Mean field used in centering.\n\n    Returns\n    -------\n    u_complete : ndarray\n        Reconstructed field with mean added.\n    \"\"\"\n    u_full = V_sel @ u_reduced if V_sel.shape[1] == u_reduced.shape[0] else V_sel @ u_reduced.T\n\n    m = mean[None, :] if u_full.ndim == 2 and mean.ndim != u_full.ndim else mean\n\n    u_complete = u_full.T + m\n\n    return u_complete\n\n\ndef rom_data_gen(save_kw, problem_path):\n    \"\"\"\n    Save ROM outputs to a ROM_data folder.\n\n    This function stores:\n    - fos_solutions.npy\n    - ROM_simulation_data.npz (all other items from save_kw)\n\n    Parameters\n    ----------\n    save_kw : dict\n        Data to save. Must contain key \"fos_solutions\".\n    problem_path : str or Path\n        Path to the problem folder.\n\n    Raises\n    ------\n    KeyError\n        If \"fos_solutions\" is not present in save_kw.\n    \"\"\"\n    rom_dir = Path(problem_path) / \"ROM_data\"\n    rom_dir.mkdir(parents=True, exist_ok=True)\n\n    try:\n        sol = save_kw.pop(\"fos_solutions\")\n    except KeyError:\n        raise KeyError(\"rom_data_gen requires 'fos_solutions' in save_kw\")\n\n    fos_path = rom_dir / \"fos_solutions.npy\"\n    np.save(fos_path, np.array(sol, copy=False))\n    print(f\"Saved full-order solution → {fos_path.name}\")\n\n    npz_path = rom_dir / \"ROM_simulation_data.npz\"\n    np.savez_compressed(npz_path, **save_kw)\n    print(f\"Saved ROM data             → {npz_path.name}\")\n\n\ndef load_rom_data(self, rom_data_dir: str | Path | None = None):\n    \"\"\"\n    Load ROM data from a ROM_data folder.\n\n    Behavior\n    --------\n    - If self is None, return (fos_solutions, sim_data_dict).\n    - If self is not None, set attributes on self and return None.\n\n    Parameters\n    ----------\n    self : object or None\n        Target instance that holds problem_name, or None for return mode.\n    rom_data_dir : str | Path | None\n        Path to ROM_data, or a module path string, or None for auto path.\n\n    Returns\n    -------\n    (fos_solutions, sim_data) : tuple\n        Returned only when self is None.\n    \"\"\"\n    if self is None:\n        if rom_data_dir is None:\n            base = Path(__file__).resolve().parent\n            rom_dir = base / self.problem_name / \"ROM_data\"\n        else:\n            rom_dir = (\n                Path(rom_data_dir)\n                if not isinstance(rom_data_dir, str) or Path(rom_data_dir).exists()\n                else Path(importlib.import_module(str(rom_data_dir)).__file__).parent\n            )\n\n        fos_solutions = np.load(rom_dir / \"fos_solutions.npy\", allow_pickle=True)\n        data = np.load(rom_dir / \"ROM_simulation_data.npz\", allow_pickle=True)\n        sim_data = {name: val for name, val in data.items()}\n        print(f\"[load_rom_data] loaded from {rom_dir}\")\n        return fos_solutions, sim_data\n    else:\n        if rom_data_dir is None:\n            base = Path(__file__).resolve().parent\n            rom_dir = base / self.problem_name / \"ROM_data\"\n        else:\n            rom_dir = (\n                Path(rom_data_dir)\n                if not isinstance(rom_data_dir, str) or Path(rom_data_dir).exists()\n                else Path(importlib.import_module(str(rom_data_dir)).__file__).parent\n            )\n\n        self.fos_solutions = np.load(rom_dir / \"fos_solutions.npy\", allow_pickle=True)\n        data = np.load(rom_dir / \"ROM_simulation_data.npz\", allow_pickle=True)\n        for name, val in data.items():\n            setattr(self, name, val)\n        print(f\"[load_rom_data] loaded from {rom_dir}\")\n\n\ndef _ensure_csr(mat):\n    \"\"\"\n    Convert matrix input to CSR sparse matrix.\n\n    Parameters\n    ----------\n    mat : array_like or sparse matrix or 0-d object array\n        Matrix input.\n\n    Returns\n    -------\n    csr : scipy.sparse.csr_matrix\n        CSR matrix view or copy.\n    \"\"\"\n    if isinstance(mat, np.ndarray) and mat.dtype == object and mat.shape == ():\n        mat = mat.item()\n    return mat.tocsr() if issparse(mat) else csr_matrix(np.asarray(mat, float))\n\n\ndef newton_hyper_rom_solver(assemble_func, u, tol=3e-2, maxit=200, param=None):\n    \"\"\"\n    Newton solve for a reduced system defined by assemble_func.\n\n    assemble_func(u, param) must return (A, y) such that:\n        A * delta = -y\n\n    Parameters\n    ----------\n    assemble_func : callable\n        Function with signature (A, y) = assemble_func(u, param).\n    u : ndarray\n        Initial iterate. Updated in place.\n    tol : float\n        Stop threshold on ||delta||.\n    maxit : int\n        Iteration cap.\n    param : any\n        Input passed to assemble_func.\n\n    Returns\n    -------\n    u : ndarray\n        Final iterate.\n    \"\"\"\n    alpha = 1.0\n    damp_freq = 40\n\n    for itr in range(maxit):\n        A, y = assemble_func(u, param)\n\n        if (itr &gt; 0 and itr % damp_freq == 0) or (itr &gt; 3 and step_norm &gt; 1e4):\n            alpha *= 0.5\n            print(f\"[ROM Newton] iter {itr}: reducing α → {alpha:.2e}\")\n\n        delta = np.linalg.solve(A, -y)\n\n        step_norm = np.linalg.norm(delta)\n\n        u += alpha * delta\n\n        print(f\"[Newton] Iter {itr:2d}, step norm = {step_norm:.3e}\")\n\n        if step_norm &lt; tol:\n            return u\n        elif itr == maxit - 1:\n            print(f\"[Newton] Iter {itr:2d}, step norm = {step_norm:.3e} (not converged)\")\n            return u\n\n\n# def newton_hyper_rom_solver2(\n#     J_rom_fn,\n#     rhs_rom_fn,\n#     u0: np.ndarray,\n#     *assemble_args,\n#     tol: float = 1e-2,\n#     maxit: int = 50,\n#     alpha: float = 1.0,\n#     rhs_args: tuple = (),\n# ):\n#     \"\"\"\n#     Newton solve for a reduced system given separate Jacobian and residual calls.\n\n#     The iteration solves:\n#         J(u) * delta = -R(u)\n\n#     Parameters\n#     ----------\n#     J_rom_fn : callable\n#         Function that returns J(u).\n#     rhs_rom_fn : callable\n#         Function that returns R(u).\n#     u0 : ndarray\n#         Initial iterate.\n#     *assemble_args : tuple\n#         Positional inputs forwarded to J_rom_fn.\n#     tol : float\n#         Stop threshold on ||u - u_prev||.\n#     maxit : int\n#         Iteration cap.\n#     alpha : float\n#         Step scaling.\n#     rhs_args : tuple\n#         Positional inputs forwarded to rhs_rom_fn.\n\n#     Returns\n#     -------\n#     u : ndarray\n#         Final iterate.\n#     \"\"\"\n#     u = u0.copy()\n#     damp_int = 40\n\n#     for itr in range(maxit):\n#         J_rom = J_rom_fn(u, *assemble_args)\n#         RHS_rom = rhs_rom_fn(u, *rhs_args)\n#         u_prev = u.copy()\n\n#         if itr &gt; 0 and itr % damp_int == 0:\n#             alpha *= 0.5\n#             print(f\"[ROM Newton] iter {itr}: reducing α → {alpha:.2e}\")\n\n#         delta = np.linalg.solve(J_rom, -RHS_rom)\n#         u += alpha * delta\n\n#         if np.linalg.norm(u - u_prev) &lt; tol:\n#             return u\n#         elif itr == maxit - 1:\n#             print(f\"[Newton] Iter {itr:2d} (not converged)\")\n#             return u\n\n\n# def newton_solver_rom(\n#     assemble_func,\n#     u_rom,\n#     *args,\n#     alpha: float = 1.0,\n#     tol: float = 1e-3,\n#     maxit: int = 100,\n#     use_lu: bool = False,\n#     jac_tol: float = 1e-1,\n#     **kwargs,\n# ):\n#     \"\"\"\n#     Newton solve for a reduced system with two modes.\n\n#     Mode A (use_lu=True)\n#     --------------------\n#     - Assemble J and R in reduced coordinates\n#     - Reuse LU factors until ||J - J_prev||/||J_prev|| exceeds jac_tol\n#     - Stop when ||delta|| &lt; tol\n#     - Raise RuntimeError on non-convergence\n\n#     Mode B (use_lu=False)\n#     ---------------------\n#     - Assemble (A, y) and solve A * delta = -y each step\n#     - Apply step scaling alpha, with alpha halving every 40 steps\n#     - Return on ||delta|| &lt; tol, else return last iterate at maxit\n\n#     Parameters\n#     ----------\n#     assemble_func : callable\n#         If use_lu=True: (J_rom, RHS_rom) = assemble_func(u_rom, *args, **kwargs)\n#         If use_lu=False: (A, y) = assemble_func(u_rom, *args, **kwargs)\n#     u_rom : array_like\n#         Initial iterate in reduced coordinates.\n#     *args : tuple\n#         Inputs forwarded to assemble_func.\n#     alpha : float\n#         Step scaling for mode B.\n#     tol : float\n#         Stop threshold on ||delta|| (mode A) or ||delta|| (mode B via step_norm).\n#     maxit : int\n#         Iteration cap.\n#     use_lu : bool\n#         Select mode A when True, else mode B.\n#     jac_tol : float\n#         Threshold for Jacobian refactor in mode A.\n#     **kwargs : dict\n#         Keyword inputs forwarded to assemble_func.\n\n#     Returns\n#     -------\n#     u_rom : array_like\n#         Final iterate.\n#     \"\"\"\n#     if use_lu:\n#         prev_J = None\n#         lu_factors = None\n\n#         for itr in range(maxit):\n#             J_rom, RHS_rom = assemble_func(u_rom, *args, **kwargs)\n\n#             if prev_J is None:\n#                 lu_factors = lu_factor(J_rom)\n#                 prev_J = J_rom.copy()\n#             else:\n#                 rel_change = (\n#                     np.linalg.norm(J_rom - prev_J, ord=\"fro\")\n#                     / np.linalg.norm(prev_J, ord=\"fro\")\n#                 )\n#                 if rel_change &gt; jac_tol:\n#                     lu_factors = lu_factor(J_rom)\n#                     prev_J = J_rom.copy()\n\n#             delta = lu_solve(lu_factors, -RHS_rom)\n#             u_rom += delta\n\n#             if np.linalg.norm(delta) &lt; tol:\n#                 return u_rom\n\n#         raise RuntimeError(f\"Newton (LU) did not converge in {maxit} iterations\")\n\n#     else:\n#         damp_freq = 40\n\n#         for itr in range(maxit):\n#             A, y = assemble_func(u_rom, *args, **kwargs)\n\n#             if itr &gt; 0 and itr % damp_freq == 0:\n#                 alpha *= 0.5\n#                 print(f\"[ROM Newton] iter {itr}: reducing α → {alpha:.2e}\")\n\n#             delta = np.linalg.solve(A, -y)\n#             step_norm = np.linalg.norm(delta)\n\n#             u_rom += alpha * delta\n\n#             print(f\"[Newton] Iter {itr:2d}, step norm = {step_norm:.3e}\")\n\n#             if step_norm &lt; tol:\n#                 return u_rom\n#             elif itr == maxit - 1:\n#                 print(f\"[Newton] Iter {itr:2d}, step norm = {step_norm:.3e} (not converged)\")\n#                 return u_rom\n\n\n\n\ndef _petsc_available() -&gt; bool:\n    try:\n        from petsc4py import PETSc  # noqa: F401\n        return True\n    except Exception:\n        return False\n\n\ndef _iter_solve_scipy(\n    A: np.ndarray,\n    b: np.ndarray,\n    *,\n    method: str = \"cg\",          # \"cg\" | \"gmres\" | \"minres\"\n    rtol: float = 1e-8,\n    atol: float = 0.0,\n    maxit: int = 500,\n    M=None,                      # optional preconditioner (scipy LinearOperator)\n):\n    from scipy.sparse.linalg import cg, gmres, minres\n\n    method = method.lower()\n    if method == \"cg\":\n        x, info = cg(A, b, rtol=rtol, atol=atol, maxiter=maxit, M=M)\n    elif method == \"gmres\":\n        x, info = gmres(A, b, rtol=rtol, atol=atol, maxiter=maxit, M=M)\n    elif method == \"minres\":\n        x, info = minres(A, b, rtol=rtol, maxiter=maxit, M=M)\n    else:\n        raise ValueError('method must be \"cg\", \"gmres\", or \"minres\"')\n\n    if info != 0:\n        raise RuntimeError(f\"SciPy {method} did not converge (info={info})\")\n    return np.asarray(x, dtype=np.float64)\n\n\ndef _iter_solve_petsc(\n    A: np.ndarray,\n    b: np.ndarray,\n    *,\n    ksp_type: str = \"cg\",\n    pc_type: str = \"jacobi\",\n    rtol: float = 1e-8,\n    atol: float = 0.0,\n    maxit: int = 500,\n    petsc_options: dict | None = None,\n):\n    if not _petsc_available():\n        raise RuntimeError(\"PETSc not available\")\n\n    from petsc4py import PETSc\n\n    A = np.asarray(A)\n    b = np.asarray(b)\n\n    n, m = A.shape\n    if n != m:\n        raise ValueError(f\"A must be square, got {A.shape}\")\n    if b.shape != (n,):\n        raise ValueError(f\"b must have shape ({n},), got {b.shape}\")\n\n    # Dense PETSc Mat (ROM is typically dense)\n    mat = PETSc.Mat().createDense([n, n], array=A, comm=PETSc.COMM_SELF)\n    mat.assemble()\n\n    rhs = PETSc.Vec().createSeq(n, comm=PETSc.COMM_SELF)\n    sol = PETSc.Vec().createSeq(n, comm=PETSc.COMM_SELF)\n    rhs.setArray(b)\n\n    ksp = PETSc.KSP().create(comm=PETSc.COMM_SELF)\n    ksp.setOperators(mat)\n    ksp.setType(ksp_type)\n    pc = ksp.getPC()\n    pc.setType(pc_type)\n\n    ksp.setTolerances(rtol=rtol, atol=atol, max_it=maxit)\n\n    if petsc_options:\n        opts = PETSc.Options()\n        for k, v in petsc_options.items():\n            if v is None:\n                opts.setValue(k, None)\n            else:\n                opts.setValue(k, str(v))\n\n    ksp.setFromOptions()\n    ksp.solve(rhs, sol)\n\n    reason = ksp.getConvergedReason()\n    if reason &lt; 0:\n        raise RuntimeError(f\"PETSc KSP diverged (reason={reason}, its={ksp.getIterationNumber()})\")\n\n    return sol.getArray().copy()\n\n\ndef solve_linear(\n    A,\n    b,\n    *,\n    backend: str = \"numpy\",      # \"numpy\" | \"scipy_iter\" | \"petsc\"\n    method: str = \"cg\",          # for iterative backends\n    rtol: float = 1e-8,\n    atol: float = 0.0,\n    maxit: int = 500,\n    petsc_pc: str = \"jacobi\",\n    petsc_options: dict | None = None,\n):\n    \"\"\"\n    Solve A x = b with a chosen backend.\n\n    Notes:\n      - CG requires SPD.\n      - MINRES requires symmetric (can be indefinite).\n      - GMRES works for general matrices.\n    \"\"\"\n    A = np.asarray(A, dtype=np.float64)\n    b = np.asarray(b, dtype=np.float64)\n\n    backend = backend.lower()\n    if backend == \"numpy\":\n        return np.linalg.solve(A, b)\n\n    if backend == \"scipy_iter\":\n        return _iter_solve_scipy(A, b, method=method, rtol=rtol, atol=atol, maxit=maxit)\n\n    if backend == \"petsc\":\n        return _iter_solve_petsc(\n            A, b,\n            ksp_type=method,\n            pc_type=petsc_pc,\n            rtol=rtol, atol=atol, maxit=maxit,\n            petsc_options=petsc_options,\n        )\n\n    raise ValueError('backend must be \"numpy\", \"scipy_iter\", or \"petsc\"')\n\n\ndef newton_solver_rom(\n    assemble_func,\n    u0,\n    *args,\n    tol: float = 1e-2,\n    maxit: int = 100,\n    alpha: float = 1.0,\n    damp_freq: int = 40,\n    linear_backend: str = \"numpy\",    # \"numpy\" | \"scipy_iter\" | \"petsc\"\n    linear_method: str = \"cg\",        # cg/gmres/minres (SciPy) or cg/gmres/minres (PETSc)\n    linear_rtol: float = 1e-8,\n    linear_atol: float = 0.0,\n    linear_maxit: int = 500,\n    petsc_pc: str = \"jacobi\",\n    petsc_options: dict | None = None,\n    verbose: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Single-mode ROM Newton: always solve (A * delta = -y) each iteration\n    using the selected linear backend (dense direct or iterative).\n    \"\"\"\n    u = np.array(u0, dtype=np.float64, copy=True)\n    cur_alpha = float(alpha)\n\n    for itr in range(maxit):\n        A, y = assemble_func(u, *args, **kwargs)\n        A = np.asarray(A)\n        y = np.asarray(y)\n\n        if itr &gt; 0 and damp_freq and (itr % damp_freq == 0):\n            cur_alpha *= 0.5\n            if verbose:\n                print(f\"[ROM Newton] iter {itr}: reducing α → {cur_alpha:.2e}\")\n\n        delta = solve_linear(\n            A, -y,\n            backend=linear_backend,\n            method=linear_method,\n            rtol=linear_rtol,\n            atol=linear_atol,\n            maxit=linear_maxit,\n            petsc_pc=petsc_pc,\n            petsc_options=petsc_options,\n        )\n\n        step = np.linalg.norm(delta)\n        u += cur_alpha * delta\n\n        if verbose and (itr % 10 == 0 or step &lt; tol):\n            print(f\"[ROM Newton] Iter {itr:2d}, step norm = {step:.3e}\")\n\n        if step &lt; tol:\n            return u\n\n    if verbose:\n        print(f\"[ROM Newton] reached maxit={maxit} (not converged)\")\n    return u\n\n\n################\n# Hyperreduction\n################\n\nimport numpy as np\n\n\ndef newton_hyper_rom_solver2(\n    J_rom_fn,\n    rhs_rom_fn,\n    u0: np.ndarray,\n    *J_args,\n    tol: float = 1e-2,\n    maxit: int = 50,\n    alpha: float = 1.0,\n    damp_freq: int = 40,\n    rhs_args: tuple = (),\n    # linear solve controls (same as newton_solver_rom)\n    linear_backend: str = \"numpy\",   # \"numpy\" | \"scipy_iter\" | \"petsc\"\n    linear_method: str = \"cg\",       # \"cg\" (SPD) | \"gmres\" | \"minres\"\n    linear_rtol: float = 1e-8,\n    linear_atol: float = 0.0,\n    linear_maxit: int = 500,\n    petsc_pc: str = \"ilu\",\n    petsc_options: dict | None = None,\n    verbose: bool = True,\n):\n    \"\"\"\n    Hyper-ROM Newton wrapper:\n      J_rom_fn(u, *J_args) -&gt; J(u)   (dense reduced Jacobian)\n      rhs_rom_fn(u, *rhs_args) -&gt; R(u) (reduced residual)\n    Solves: J(u) * delta = -R(u)\n    \"\"\"\n\n    def assemble_func(u, *_, **__):\n        J = J_rom_fn(u, *J_args)\n        R = rhs_rom_fn(u, *rhs_args)\n        return J, R\n\n    return newton_solver_rom(\n        assemble_func,\n        u0,\n        tol=tol,\n        maxit=maxit,\n        alpha=alpha,\n        damp_freq=damp_freq,\n        linear_backend=linear_backend,\n        linear_method=linear_method,\n        linear_rtol=linear_rtol,\n        linear_atol=linear_atol,\n        linear_maxit=linear_maxit,\n        petsc_pc=petsc_pc,\n        petsc_options=petsc_options,\n        verbose=verbose,\n    )\n\n\ndef collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n    hyper_basis=None,\n):\n    \"\"\"\n    Evaluate and store residual samples used in hyperreduction training.\n\n    For each snapshot:\n    - project snapshot to reduced coordinates\n    - reconstruct a field\n    - build keyword arguments by assemble_kwargs\n    - call Residual.hyperreduction(**kw)\n    - stack results along axis 0\n\n    Parameters\n    ----------\n    NLS_train_ms : ndarray\n        Mean-shifted snapshots.\n    NLS_train_mean : ndarray\n        Mean field.\n    V_sel : ndarray\n        Basis used for projection and reconstruction.\n    reconstruct_solution : callable\n        Function that maps reduced coordinates to full coordinates.\n    Residual : object\n        Object with method hyperreduction(**kw) that returns an array.\n    training_params : sequence\n        Parameter list aligned with NLS_train_ms.\n    assemble_kwargs : callable\n        Function that maps (u_recon, param) to a dict for Residual.hyperreduction.\n    extra_kwargs : dict or None\n        Dict merged into kw.\n    hyper_basis : object or None\n        If given, call hyper_basis.interpolate(u_recon) before assemble_kwargs.\n\n    Returns\n    -------\n    q_mus : ndarray\n        Stacked residual samples.\n    \"\"\"\n    q_mus = None\n    step = 1\n\n    for i, u_arr_ms in enumerate(NLS_train_ms):\n        u_red = V_sel.T @ u_arr_ms\n        u_recon = reconstruct_solution(u_red, V_sel, NLS_train_mean)\n\n        if hyper_basis is not None:\n            u_rec = hyper_basis.interpolate(u_recon.flatten())\n        else:\n            u_rec = u_recon.flatten()\n\n        kw = assemble_kwargs(u_rec, training_params[i])\n        kw.update(extra_kwargs or {})\n\n        q = Residual.hyperreduction(**kw).T.copy()\n\n        if q_mus is None:\n            q_mus = q\n        else:\n            q_mus = np.concatenate((q_mus, q), axis=0)\n\n    return q_mus\n\n\ndef collect_residuals_t(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    snapshot_downsampling=1,\n    extra_kwargs=None,\n    hyper_basis=None,\n):\n    \"\"\"\n    Evaluate residual samples for a set of snapshot groups.\n\n    This variant loops over an outer list/array of snapshot groups and\n    applies downsampling by index.\n\n    Parameters\n    ----------\n    NLS_train_ms : sequence\n        Collection of snapshot groups.\n    NLS_train_mean : sequence\n        Collection of mean fields aligned with snapshot groups.\n    V_sel : ndarray\n        Basis used for projection and reconstruction.\n    reconstruct_solution : callable\n        Function that maps reduced coordinates to full coordinates.\n    Residual : object\n        Object with method hyperreduction(**kw) that returns an array.\n    training_params : sequence\n        Parameter list. Kept for interface consistency.\n    assemble_kwargs : callable\n        Function that maps a reconstructed field to a dict for Residual.hyperreduction.\n    snapshot_downsampling : int\n        Keep one snapshot per this interval.\n    extra_kwargs : dict or None\n        Dict merged into kw.\n    hyper_basis : object or None\n        If given, call hyper_basis.interpolate(u_recon) before assemble_kwargs.\n\n    Returns\n    -------\n    q_mus : ndarray\n        Stacked residual samples.\n    \"\"\"\n    q_mus = None\n\n    for k, NLS_train_ms_p in enumerate(NLS_train_ms):\n        for i, u_arr_ms in enumerate(NLS_train_ms_p):\n            np.random.shuffle(NLS_train_ms_p)\n\n            if i % snapshot_downsampling == 0:\n                u_red = V_sel.T @ u_arr_ms\n                u_recon = reconstruct_solution(u_red, V_sel, NLS_train_mean[k])\n\n                if hyper_basis is not None:\n                    u_rec = hyper_basis.interpolate(u_recon.flatten())\n                else:\n                    u_rec = u_recon.flatten()\n\n                kw = assemble_kwargs(u_rec)\n                kw.update(extra_kwargs or {})\n\n                q = Residual.hyperreduction(**kw).T.copy()\n\n                if q_mus is None:\n                    q_mus = q\n                else:\n                    q_mus = np.concatenate((q_mus, q), axis=0)\n\n    return q_mus\n\n\ndef select_elements_and_gauss_weights(n_gauss_points, element_indices, weights):\n    \"\"\"\n    Build a mapping from element index to a weight list per Gauss point.\n\n    Input indices are Gauss-point indices. The mapping includes one entry per\n    element that appears in element_indices. For each mapped element, the list\n    length equals n_gauss_points. Unselected Gauss points keep weight 0.0.\n\n    Parameters\n    ----------\n    n_gauss_points : int\n        Gauss point count per element.\n    element_indices : sequence[int]\n        Gauss-point indices selected by a sampling step.\n    weights : sequence[float]\n        Weights aligned with element_indices.\n\n    Returns\n    -------\n    element_to_gauss_weights : dict[int, list[float]]\n        Map element_id -&gt; list of weights with length n_gauss_points.\n    \"\"\"\n    element_to_gauss_weights = {}\n\n    for idx, weight in zip(element_indices, weights):\n        element_idx = idx // n_gauss_points\n        gauss_point_idx = idx % n_gauss_points\n\n        if element_idx not in element_to_gauss_weights:\n            element_to_gauss_weights[element_idx] = [0.0] * n_gauss_points\n\n        element_to_gauss_weights[element_idx][gauss_point_idx] = weight\n\n    return element_to_gauss_weights\n\n\ndef compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n) -&gt; np.ndarray:\n    \"\"\"\n    Evaluate a function on each (solution, parameter) pair and stack results.\n\n    Parameters\n    ----------\n    non_linear_func : callable\n        Function with signature non_linear_func(u=&lt;solution&gt;, param=&lt;param&gt;).\n    fos_solutions : sequence\n        Sequence of full-order solutions.\n    param_list : sequence\n        Sequence of parameters aligned with fos_solutions.\n\n    Returns\n    -------\n    F_nl : ndarray\n        Stacked outputs of non_linear_func.\n    \"\"\"\n    F_nl = []\n    for u, param in zip(fos_solutions, param_list):\n        rhs_snapshot = non_linear_func(u=u, param=param)\n        F_nl.append(np.copy(rhs_snapshot))\n    return np.asarray(F_nl)"
>>>>>>> Stashed changes
  }
]