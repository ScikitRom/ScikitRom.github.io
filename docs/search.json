[
  {
    "objectID": "twisting.html#problem-setup",
    "href": "twisting.html#problem-setup",
    "title": "P.2 Twisting of a Neo-Hookean Block",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.2 Twisting of a Neo-Hookean Block"
    ]
  },
  {
    "objectID": "Resources/intro/rom_intro.html",
    "href": "Resources/intro/rom_intro.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "scikit-rom\nscikit-rom is a lightweight, Python-based platform designed for projection-based model reduction of finite element models with moderate to large problem sizes (up to approximately 600,000 degrees of freedom). Built on top of scikit-fem, an easy-to-use finite element assembly library, this repository demonstrates reduced-order modeling (ROM) techniques for a range of linear and nonlinear problems, including time-dependent ones. Current examples primarily focus on thermal and mechanical systems, with extensions to fluid dynamics planned for future releases.\nBeyond its application to real-world finite element problems, the library also serves as a valuable testing ground for new model reduction algorithms and as a tutorial resource for those new to the field.\n\n\n\nWhat is Reduced-Order Modeling?\nReduced-order modeling (ROM) is a computational strategy for approximating high-fidelity numerical models with significantly reduced computational cost. Instead of solving large-scale systems—often with millions of unknowns—ROM techniques construct low-dimensional surrogates that retain the dominant physics of the system, enabling efficient and repeated evaluations.\nThe underlying principle is that many physical systems exhibit behavior that can be captured by a small number of dominant modes, despite their discretization on fine spatial meshes. Techniques such as Proper Orthogonal Decomposition (POD) extract these modes from full-order simulations, enabling the construction of reduced models that are both accurate and computationally efficient.\n\n\n\nOffline–Online Decomposition\nscikit-rom implements the classical offline–online decomposition paradigm:\n\nOffline Phase (computationally intensive, performed once):\n\nSampling of the parameter space\nGeneration of full-order solution snapshots\nComputation of the reduced basis via singular value decomposition (SVD)\nAssembly of parameter-independent reduced operators\n\nOnline Phase (efficient, performed repeatedly):\n\nEvaluation of the system response for new parameter values using preassembled reduced operators\nSpeedups on the order of 10–500× relative to full-order models are typical"
  },
  {
    "objectID": "reference/utils.visualization.html",
    "href": "reference/utils.visualization.html",
    "title": "utils.visualization",
    "section": "",
    "text": "utils.visualization"
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html",
    "href": "reference/utils.visualization.generate_vtu.html",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "utils.visualization.generate_vtu\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html#functions",
    "href": "reference/utils.visualization.generate_vtu.html#functions",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html",
    "href": "reference/utils.visualization.color_palette.html",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "utils.visualization.color_palette\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html#functions",
    "href": "reference/utils.visualization.color_palette.html#functions",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.rom_error_est.html",
    "href": "reference/utils.rom_error_est.html",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "utils.rom_error_est\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.rom_error_est.html#functions",
    "href": "reference/utils.rom_error_est.html#functions",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.reduced_basis.html",
    "href": "reference/utils.reduced_basis.html",
    "title": "utils.reduced_basis",
    "section": "",
    "text": "utils.reduced_basis"
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html",
    "href": "reference/utils.newton_solver_rom.html",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "utils.newton_solver_rom\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html#functions",
    "href": "reference/utils.newton_solver_rom.html#functions",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.imports.html",
    "href": "reference/utils.imports.html",
    "title": "utils.imports",
    "section": "",
    "text": "utils.imports\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the scikit-rom framework.",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.imports"
    ]
  },
  {
    "objectID": "reference/utils.errors.html",
    "href": "reference/utils.errors.html",
    "title": "utils.errors",
    "section": "",
    "text": "utils.errors\nutils.errors"
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html",
    "href": "reference/utils.dynamics.integrators.html",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "utils.dynamics.integrators\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html#functions",
    "href": "reference/utils.dynamics.integrators.html#functions",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.basis.pod.html",
    "href": "reference/utils.basis.pod.html",
    "title": "utils.basis.pod",
    "section": "",
    "text": "utils.basis.pod\nutils.basis.pod"
  },
  {
    "objectID": "reference/templates.problem_template.properties.html",
    "href": "reference/templates.problem_template.properties.html",
    "title": "templates.problem_template.properties",
    "section": "",
    "text": "templates.problem_template.properties\n\n\n\n\n\nName\nDescription\n\n\n\n\nproperty_fn\nTemplate for a material or source property function.\n\n\n\n\n\ntemplates.problem_template.properties.property_fn(param)\nTemplate for a material or source property function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparam\nfloat\nUser-defined parameter controlling the property.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nComputed property value.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.properties"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.properties.html#functions",
    "href": "reference/templates.problem_template.properties.html#functions",
    "title": "templates.problem_template.properties",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nproperty_fn\nTemplate for a material or source property function.\n\n\n\n\n\ntemplates.problem_template.properties.property_fn(param)\nTemplate for a material or source property function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparam\nfloat\nUser-defined parameter controlling the property.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nComputed property value.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.properties"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.params.html",
    "href": "reference/templates.problem_template.params.html",
    "title": "templates.problem_template.params",
    "section": "",
    "text": "templates.problem_template.params\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameters\nTemplate for generating training/testing parameter samples.\n\n\n\n\n\ntemplates.problem_template.params.parameters(N_snap)\nTemplate for generating training/testing parameter samples.\nUses generate_sobol from skrom.rom.rom_utils to sample uniformly over each interval in param_ranges.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of samples per set.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nparams\n(ndarray, shape(2 * N_snap, D))\nStacked [training; testing] samples.\n\n\nparam_ranges\nlist of tuple\n[(p1_min, p1_max), …, (pD_min, pD_max)] for each parameter.\n\n\ntrain_mask\nndarray of bool\nTrue for the first N_snap entries of params.\n\n\ntest_mask\nndarray of bool\nTrue for the remaining entries.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.params"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.params.html#functions",
    "href": "reference/templates.problem_template.params.html#functions",
    "title": "templates.problem_template.params",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nparameters\nTemplate for generating training/testing parameter samples.\n\n\n\n\n\ntemplates.problem_template.params.parameters(N_snap)\nTemplate for generating training/testing parameter samples.\nUses generate_sobol from skrom.rom.rom_utils to sample uniformly over each interval in param_ranges.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of samples per set.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nparams\n(ndarray, shape(2 * N_snap, D))\nStacked [training; testing] samples.\n\n\nparam_ranges\nlist of tuple\n[(p1_min, p1_max), …, (pD_min, pD_max)] for each parameter.\n\n\ntrain_mask\nndarray of bool\nTrue for the first N_snap entries of params.\n\n\ntest_mask\nndarray of bool\nTrue for the remaining entries.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.params"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.domain.html",
    "href": "reference/templates.problem_template.domain.html",
    "title": "templates.problem_template.domain",
    "section": "",
    "text": "templates.problem_template.domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain_\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\ntemplates.problem_template.domain.domain_(**kwargs)\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\nAny problem-specific parameters needed for mesh generation, basis construction, and boundary identification.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{ ‘mesh’: , ‘basis’: , ‘free_dofs’: , ‘dirichlet_dofs’: , ‘dirichlet_value’: , # add other entries as needed }",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.domain"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.domain.html#functions",
    "href": "reference/templates.problem_template.domain.html#functions",
    "title": "templates.problem_template.domain",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndomain_\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\ntemplates.problem_template.domain.domain_(**kwargs)\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\nAny problem-specific parameters needed for mesh generation, basis construction, and boundary identification.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{ ‘mesh’: , ‘basis’: , ‘free_dofs’: , ‘dirichlet_dofs’: , ‘dirichlet_value’: , # add other entries as needed }",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.domain"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html",
    "href": "reference/rom.rom_utils.html",
    "title": "rom.rom_utils",
    "section": "",
    "text": "rom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O, and Newton solvers in reduced‐order modeling (ROM) workflows.\nThis module provides:\n\nSnapshot train/test splitting routines:\n\ntrain_test_split, latin_hypercube_train_test_split, sobol_train_test_split\n\nSample generators:\n\ngenerate_sobol, generate_lhs, generate_gaussian_samples\n\nBasis management:\n\nupdate_basis – deflation and augmentation of reduced bases\n\nSolution reconstruction:\n\nreconstruct_solution – expand reduced vectors back to full order\n\nROM data persistence:\n\nrom_data_gen, load_rom_data\n\nNewton solvers for ROM systems:\n\nnewton_hyper_rom_solver, newton_solver_rom\n\n\nTogether, these functions support data preparation, sampling design, basis enrichment, I/O, and nonlinear solves in full‐to‐reduced‐order pipelines.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_residuals\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\n\n\ncompute_nonlinear_snapshots\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve nonlinear reduced-order system using Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nselect_elements_and_gauss_weights\nSelect elements and corresponding weights from Gauss points, ensuring consistency\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n)\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\nThis function processes training snapshots to collect residual evaluations that will be used for hyperreduction (reducing computational cost of nonlinear ROM terms).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfos_solutions\nndarray\nFull order solutions (not directly used but maintained for interface consistency)\nrequired\n\n\nNLS_train_ms\n(ndarray, shape(n_snapshots, n_dofs))\nMean-subtracted training snapshots (temperature fluctuations from mean)\nrequired\n\n\nNLS_train_mean\n(ndarray, shape(n_dofs))\nMean temperature field across all training snapshots\nrequired\n\n\nV_sel\n(ndarray, shape(n_dofs, n_modes))\nSelected POD basis matrix (reduced basis vectors)\nrequired\n\n\nreconstruct_solution\ncallable\nFunction to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean)\nrequired\n\n\nResidual\nLinearFormROM object\nROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nq_mus\n(ndarray, shape(n_snapshots, n_residual_components))\nCollected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter\n\n\n\n\n\n\n\nrom.rom_utils.compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n)\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnon_linear_func\n\nA function with signature non_linear_func(u=, param=) → array.\nrequired\n\n\nfos_solutions\n\nSequence of full-order solutions (each an ndarray).\nrequired\n\n\nparam_list\n\nSequence of parameter values, same length as fos_solutions.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_nl\nndarray\nArray of shape (n_snapshots, …) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]).\n\n\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.03,\n    maxit=200,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.03\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n200\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    alpha=1.0,\n    tol=0.001,\n    maxit=100,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve nonlinear reduced-order system using Newton’s method.\nProvides two solution strategies: efficient LU refactorization for ROM systems or direct solving with adaptive step damping.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction that assembles Jacobian and residual: (J, R) = func(u_rom, …)\nrequired\n\n\nu_rom\narray - like\nInitial guess for reduced-order state vector\nrequired\n\n\n*args\ntuple\nAdditional positional arguments passed to assemble_func\n()\n\n\nalpha\nfloat\nStep size damping factor (only used when use_lu=False)\n1.0\n\n\ntol\nfloat\nConvergence tolerance on Newton step norm\n1e-3\n\n\nmaxit\nint\nMaximum number of Newton iterations\n100\n\n\nuse_lu\nbool\nIf True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction.\nFalse\n\n\njac_tol\nfloat\nRelative tolerance for Jacobian reuse (only used when use_lu=True)\n1e-1\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to assemble_func\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\narray - like\nConverged reduced-order state vector u_rom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf Newton iteration fails to converge within maxit iterations (only when use_lu=True)\n\n\n\n\n\n\n\nLU mode: Reuses Jacobian factorization until relative change exceeds jac_tol\nDirect mode: Applies adaptive damping every 40 iterations, includes logging\nPart of ROM workflow for efficient nonlinear system solving\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.select_elements_and_gauss_weights(\n    n_gauss_points,\n    element_indices,\n    weights,\n)\nSelect elements and corresponding weights from Gauss points, ensuring consistency by including all Gauss points for each selected element with zero weights for unselected points.\nParameters: n_gauss_points (int): Number of Gauss points per element. element_indices (list or array): Selected Gauss point indices from ECM. weights (list or array): Corresponding weights for selected indices.\nReturns: dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points. For each selected element, the list will have exactly n_gauss_points entries.\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html#functions",
    "href": "reference/rom.rom_utils.html#functions",
    "title": "rom.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncollect_residuals\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\n\n\ncompute_nonlinear_snapshots\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve nonlinear reduced-order system using Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nselect_elements_and_gauss_weights\nSelect elements and corresponding weights from Gauss points, ensuring consistency\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n)\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\nThis function processes training snapshots to collect residual evaluations that will be used for hyperreduction (reducing computational cost of nonlinear ROM terms).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfos_solutions\nndarray\nFull order solutions (not directly used but maintained for interface consistency)\nrequired\n\n\nNLS_train_ms\n(ndarray, shape(n_snapshots, n_dofs))\nMean-subtracted training snapshots (temperature fluctuations from mean)\nrequired\n\n\nNLS_train_mean\n(ndarray, shape(n_dofs))\nMean temperature field across all training snapshots\nrequired\n\n\nV_sel\n(ndarray, shape(n_dofs, n_modes))\nSelected POD basis matrix (reduced basis vectors)\nrequired\n\n\nreconstruct_solution\ncallable\nFunction to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean)\nrequired\n\n\nResidual\nLinearFormROM object\nROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nq_mus\n(ndarray, shape(n_snapshots, n_residual_components))\nCollected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter\n\n\n\n\n\n\n\nrom.rom_utils.compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n)\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnon_linear_func\n\nA function with signature non_linear_func(u=, param=) → array.\nrequired\n\n\nfos_solutions\n\nSequence of full-order solutions (each an ndarray).\nrequired\n\n\nparam_list\n\nSequence of parameter values, same length as fos_solutions.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_nl\nndarray\nArray of shape (n_snapshots, …) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]).\n\n\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.03,\n    maxit=200,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.03\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n200\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    alpha=1.0,\n    tol=0.001,\n    maxit=100,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve nonlinear reduced-order system using Newton’s method.\nProvides two solution strategies: efficient LU refactorization for ROM systems or direct solving with adaptive step damping.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction that assembles Jacobian and residual: (J, R) = func(u_rom, …)\nrequired\n\n\nu_rom\narray - like\nInitial guess for reduced-order state vector\nrequired\n\n\n*args\ntuple\nAdditional positional arguments passed to assemble_func\n()\n\n\nalpha\nfloat\nStep size damping factor (only used when use_lu=False)\n1.0\n\n\ntol\nfloat\nConvergence tolerance on Newton step norm\n1e-3\n\n\nmaxit\nint\nMaximum number of Newton iterations\n100\n\n\nuse_lu\nbool\nIf True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction.\nFalse\n\n\njac_tol\nfloat\nRelative tolerance for Jacobian reuse (only used when use_lu=True)\n1e-1\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to assemble_func\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\narray - like\nConverged reduced-order state vector u_rom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf Newton iteration fails to converge within maxit iterations (only when use_lu=True)\n\n\n\n\n\n\n\nLU mode: Reuses Jacobian factorization until relative change exceeds jac_tol\nDirect mode: Applies adaptive damping every 40 iterations, includes logging\nPart of ROM workflow for efficient nonlinear system solving\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.select_elements_and_gauss_weights(\n    n_gauss_points,\n    element_indices,\n    weights,\n)\nSelect elements and corresponding weights from Gauss points, ensuring consistency by including all Gauss points for each selected element with zero weights for unselected points.\nParameters: n_gauss_points (int): Number of Gauss points per element. element_indices (list or array): Selected Gauss point indices from ECM. weights (list or array): Corresponding weights for selected indices.\nReturns: dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points. For each selected element, the list will have exactly n_gauss_points entries.\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.html",
    "href": "reference/rom.html",
    "title": "rom",
    "section": "",
    "text": "rom\nThe rom folder provides core reduced‐order modeling tools:\n– Projection & assembly classes (BilinearFormROM, LinearFormROM): • Project full‐order stiffness and load contributions onto reduced bases • Handle Dirichlet boundary conditions via free‐DOF mappings • Support chunked/clustered assembly for memory‐efficient reduced operators\n– Error evaluation & visualization (error_utils.py): • Compute time‐dependent and global error metrics (L2, RMSE, R², energy‐norm, etc.) • Generate scatter plots, spatial snapshots, raincloud plots, and tabular reports\n– ROM utilities (utils.py): • Snapshot splitting and sampling (random, Latin‐Hypercube, Sobol, Gaussian) • Basis enrichment via deflation and QR re‐orthonormalization • Solution reconstruction from reduced coefficients • Data I/O for ROM simulations (rom_data_gen, load_rom_data) • Newton solvers for (hyper‐)reduced systems"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html",
    "href": "reference/rom.linear_form_hyperrom.html",
    "title": "rom.linear_form_hyperrom",
    "section": "",
    "text": "rom.linear_form_hyperrom"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.linear_form_hyperrom",
    "section": "hyperreduce/linear_form_hyperrom.py",
    "text": "hyperreduce/linear_form_hyperrom.py\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#classes",
    "href": "reference/rom.linear_form_hyperrom.html#classes",
    "title": "rom.linear_form_hyperrom",
    "section": "Classes",
    "text": "Classes\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\nLinearFormHYPERROM\nrom.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\nassemble_weighted\nrom.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(**kwargs)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\nextract_element_vector\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\nextract_element_vector_rom\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.linear_form_hyperrom_ecsw\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides:\n\nLinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\n\nThe hyperreduce folder contains all tools to perform hyper-reduction, including:\n\nReduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM)\nRoutines for extracting element stiffness matrices and load vectors in a reduced basis\nUtilities for efficient handling of Dirichlet conditions and element clustering\nSupport for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_ecsw\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides:\n\nLinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\n\nThe hyperreduce folder contains all tools to perform hyper-reduction, including:\n\nReduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM)\nRoutines for extracting element stiffness matrices and load vectors in a reduced basis\nUtilities for efficient handling of Dirichlet conditions and element clustering\nSupport for weights, parallelization, and reconstruction of full-order data",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_ecsw\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html",
    "href": "reference/rom.ecsw.custom_nnls.html",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "rom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides:\n\nNNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS.\n_verify: internal helper to assert solver invariants.\nNNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\n\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including:\n\nAlgorithms to compute cubature weights using bounded NNLS.\nSelection and pruning of integration points via active-set methods.\nSupport functions for convergence criteria and solver configuration.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html#classes",
    "href": "reference/rom.ecsw.custom_nnls.html#classes",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.linear_form_hyperrom_deim\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nHyperreduction of a linear form via DEIM and mesh sampling.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nHyperreduction of a linear form via DEIM and mesh sampling.\nImplements a Discrete Empirical Interpolation Method (DEIM)–based hyperreduction for finite‐element linear forms. Builds a reduced‐order load vector by assembling only a weighted subset of elements and reconstructing the full operator via DEIM interpolation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyper-reduced load vector via DEIM.\n\n\ndeim_elem_assembly\nAssemble the sampled full-order load vector.\n\n\nextract_element_vector_rom\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyper-reduced load vector via DEIM.\nThis method first builds the sampled full-order load vector on the selected elements, then applies the DEIM interpolation matrix to project it onto the reduced basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to deim_elem_assembly / element extraction.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nReduced-order load vector of shape (r,).\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble the sampled full-order load vector.\nExtracts element-level load contributions only on the sampled elements, then scatters them into the global load vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to extract_element_vector_rom.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nFull-order load vector of length n_dofs.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nBasis for test functions.\nrequired\n\n\nelem_indices\narray_like of int\nIndices of elements to include in extraction.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments for evaluating the bilinear form over each element.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nArray of shape (n_elems, n_loc) containing the element vectors.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nHyperreduction of a linear form via DEIM and mesh sampling.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nHyperreduction of a linear form via DEIM and mesh sampling.\nImplements a Discrete Empirical Interpolation Method (DEIM)–based hyperreduction for finite‐element linear forms. Builds a reduced‐order load vector by assembling only a weighted subset of elements and reconstructing the full operator via DEIM interpolation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyper-reduced load vector via DEIM.\n\n\ndeim_elem_assembly\nAssemble the sampled full-order load vector.\n\n\nextract_element_vector_rom\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyper-reduced load vector via DEIM.\nThis method first builds the sampled full-order load vector on the selected elements, then applies the DEIM interpolation matrix to project it onto the reduced basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to deim_elem_assembly / element extraction.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nReduced-order load vector of shape (r,).\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble the sampled full-order load vector.\nExtracts element-level load contributions only on the sampled elements, then scatters them into the global load vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to extract_element_vector_rom.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nFull-order load vector of length n_dofs.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element vectors for assembling over sampled mesh.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nBasis for test functions.\nrequired\n\n\nelem_indices\narray_like of int\nIndices of elements to include in extraction.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments for evaluating the bilinear form over each element.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nArray of shape (n_elems, n_loc) containing the element vectors.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.bilinear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.bilinear_form_hyperrom_deim.html",
    "title": "rom.deim.bilinear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.bilinear_form_hyperrom_deim\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_deim\nHyperreduction of a bilinear form via DEIM and mesh sampling.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    sampled_rows,\n    deim_mat,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nHyperreduction of a bilinear form via DEIM and mesh sampling.\nImplements a Discrete Empirical Interpolation Method (DEIM)–based hyperreduction for finite‐element bilinear forms. Builds a reduced‐order operator by assembling only a subset of elements and reconstructing the full operator via DEIM interpolation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyper-reduced stiffness matrix via DEIM.\n\n\ndeim_elem_assembly\nAssemble the sampled full-order stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract element matrices for assembling over sampled mesh.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyper-reduced stiffness matrix via DEIM.\nThis first builds the sampled full-order matrix, then projects it onto the reduced basis using the DEIM interpolation matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to deim_elem_assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nReduced-order stiffness matrix of shape (r, r).\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble the sampled full-order stiffness matrix.\nExtracts element-level contributions only on sampled elements, flattens and filters out zeros, and builds a sparse CSR matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to extract_element_matrices_rom.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncsr_matrix\nSparse full-order stiffness matrix of shape (n_dofs, n_dofs), assembled over sampled elements.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element matrices for assembling over sampled mesh.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nBasis for trial functions.\nrequired\n\n\nvbasis\nBasis\nBasis for test functions. If None, ubasis is used.\nNone\n\n\nelem_indices\narray_like of int\nIndices of elements to include in extraction.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments for evaluating the bilinear form over each element.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nArray of shape (n_elems, n_loc, n_loc) containing the element stiffness matrices.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.bilinear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.bilinear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.bilinear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.bilinear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_deim\nHyperreduction of a bilinear form via DEIM and mesh sampling.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    sampled_rows,\n    deim_mat,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nHyperreduction of a bilinear form via DEIM and mesh sampling.\nImplements a Discrete Empirical Interpolation Method (DEIM)–based hyperreduction for finite‐element bilinear forms. Builds a reduced‐order operator by assembling only a subset of elements and reconstructing the full operator via DEIM interpolation.\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyper-reduced stiffness matrix via DEIM.\n\n\ndeim_elem_assembly\nAssemble the sampled full-order stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract element matrices for assembling over sampled mesh.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyper-reduced stiffness matrix via DEIM.\nThis first builds the sampled full-order matrix, then projects it onto the reduced basis using the DEIM interpolation matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to deim_elem_assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nReduced-order stiffness matrix of shape (r, r).\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble the sampled full-order stiffness matrix.\nExtracts element-level contributions only on sampled elements, flattens and filters out zeros, and builds a sparse CSR matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed to extract_element_matrices_rom.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ncsr_matrix\nSparse full-order stiffness matrix of shape (n_dofs, n_dofs), assembled over sampled elements.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element matrices for assembling over sampled mesh.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nBasis for trial functions.\nrequired\n\n\nvbasis\nBasis\nBasis for test functions. If None, ubasis is used.\nNone\n\n\nelem_indices\narray_like of int\nIndices of elements to include in extraction.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments for evaluating the bilinear form over each element.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nndarray\nArray of shape (n_elems, n_loc, n_loc) containing the element stiffness matrices.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.bilinear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/problem_structure.html",
    "href": "reference/problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Linear Elasticity\n\n\n\nGoal. This comprehensive hands-on tutorial walks you through every file in problem_1 and shows how to assemble an affine reduced-order model (ROM) for a 3-D linear-elastic block using scikit-rom. We’ll explain the theory behind each step and demonstrate how reduced-order modeling can dramatically accelerate computational mechanics simulations.\n\n\n\n\nReduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples\n\n\n\n\n\nFirst, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible.\n\n\n\n\nThe domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable.\n\n\n\n\nThis module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement\n\n\n\n\nThis is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase.\n\n\n\n\nThis module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads\n\n\n\n\nFor ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.\nfrom src.skrom.rom.rom_utils import generate_sobol\n\ndef parameters(N_snap=32):\n    # Sobol over (E, nu) in [100, 200] × [0.25, 0.35]\n    return generate_sobol([[100.,200.],[0.25,0.35]], 2*N_snap)\nDetailed Explanation:\n\nSobol Sequences: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.\nParameter Ranges:\n\nYoung’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)\nPoisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)\n\nSample Size: 2*N_snap samples are generated so they can be split into training and testing sets.\n\nUsage Pattern:\nE_nu_train, E_nu_test = np.split(parameters(32), 2)\nThis gives you 32 training samples and 32 testing samples for validation.\nWhy Good Sampling Matters: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others.\n\n\n\n\nThis is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\n\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations.\n\n\n\n\n\nThe offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.\nfrom src.skrom.problem_classes import new_problem\n\nprob = new_problem(\"problem_1\")\n\n# 1) draw parameter samples\ntheta_train = prob.parameters(n_samples=64)\n\n# 2) build snapshots\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\n\n# 3) compute POD basis\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\n\n# 4) assemble reduced operators\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nDetailed Step-by-Step Explanation:\n\n\ntheta_train = prob.parameters(n_samples=64)\nThis generates 64 parameter combinations \\((E_i, \\nu_i)\\) using the Sobol sequence. These parameters should span the expected range of operating conditions.\n\n\n\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\nFor each parameter combination, the full finite element problem is solved: \\[K(\\theta_i) u_i = f\\]\nThe resulting displacement vectors \\(u_i\\) are called “snapshots” and are stored as columns in matrix \\(U\\). If you have \\(N\\) degrees of freedom and \\(n_{snap}\\) parameter samples, then \\(U \\in \\mathbb{R}^{N \\times n_{snap}}\\).\n\n\n\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\nPOD performs Singular Value Decomposition on the snapshot matrix: \\[U = V \\Sigma W^T\\]\nThe columns of \\(V\\) are the POD modes, ordered by importance (largest singular values first). We keep only the first \\(r=50\\) modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.\nKey Insight: The POD basis \\(V\\) captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.\n\n\n\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nThe full-order operators are projected onto the reduced space: \\[A_r^q = V^T A^q V, \\quad f_r = V^T f\\]\nFor our affine case: - \\(A_r^1 = V^T K_\\lambda V\\) (reduced volumetric stiffness) - \\(A_r^2 = V^T K_\\mu V\\) (reduced deviatoric stiffness) - \\(f_r = V^T f\\) (reduced load vector)\nThese are small \\(r \\times r\\) matrices instead of \\(N \\times N\\) matrices, enabling rapid online assembly.\n\n\n\n\n\nOnce the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods\n\n\n\n\nIt’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction\n\n\n\n\n\n\nThe choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used."
  },
  {
    "objectID": "reference/problem_structure.html#what-is-reduced-order-modeling",
    "href": "reference/problem_structure.html#what-is-reduced-order-modeling",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples"
  },
  {
    "objectID": "reference/problem_structure.html#prerequisites",
    "href": "reference/problem_structure.html#prerequisites",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "First, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible."
  },
  {
    "objectID": "reference/problem_structure.html#geometry-finite-element-setup-domain.py",
    "href": "reference/problem_structure.html#geometry-finite-element-setup-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable."
  },
  {
    "objectID": "reference/problem_structure.html#constitutive-law-material-properties-properties.py",
    "href": "reference/problem_structure.html#constitutive-law-material-properties-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement"
  },
  {
    "objectID": "reference/problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "href": "reference/problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase."
  },
  {
    "objectID": "reference/problem_structure.html#right-hand-side-linear_forms.py",
    "href": "reference/problem_structure.html#right-hand-side-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads"
  },
  {
    "objectID": "reference/problem_structure.html#parameter-sampling-params.py",
    "href": "reference/problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "For ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.\nfrom src.skrom.rom.rom_utils import generate_sobol\n\ndef parameters(N_snap=32):\n    # Sobol over (E, nu) in [100, 200] × [0.25, 0.35]\n    return generate_sobol([[100.,200.],[0.25,0.35]], 2*N_snap)\nDetailed Explanation:\n\nSobol Sequences: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.\nParameter Ranges:\n\nYoung’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)\nPoisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)\n\nSample Size: 2*N_snap samples are generated so they can be split into training and testing sets.\n\nUsage Pattern:\nE_nu_train, E_nu_test = np.split(parameters(32), 2)\nThis gives you 32 training samples and 32 testing samples for validation.\nWhy Good Sampling Matters: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others."
  },
  {
    "objectID": "reference/problem_structure.html#orchestrating-everything-problem_def.py",
    "href": "reference/problem_structure.html#orchestrating-everything-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\n\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations."
  },
  {
    "objectID": "reference/problem_structure.html#offline-workflow-building-the-rom",
    "href": "reference/problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.\nfrom src.skrom.problem_classes import new_problem\n\nprob = new_problem(\"problem_1\")\n\n# 1) draw parameter samples\ntheta_train = prob.parameters(n_samples=64)\n\n# 2) build snapshots\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\n\n# 3) compute POD basis\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\n\n# 4) assemble reduced operators\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nDetailed Step-by-Step Explanation:\n\n\ntheta_train = prob.parameters(n_samples=64)\nThis generates 64 parameter combinations \\((E_i, \\nu_i)\\) using the Sobol sequence. These parameters should span the expected range of operating conditions.\n\n\n\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\nFor each parameter combination, the full finite element problem is solved: \\[K(\\theta_i) u_i = f\\]\nThe resulting displacement vectors \\(u_i\\) are called “snapshots” and are stored as columns in matrix \\(U\\). If you have \\(N\\) degrees of freedom and \\(n_{snap}\\) parameter samples, then \\(U \\in \\mathbb{R}^{N \\times n_{snap}}\\).\n\n\n\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\nPOD performs Singular Value Decomposition on the snapshot matrix: \\[U = V \\Sigma W^T\\]\nThe columns of \\(V\\) are the POD modes, ordered by importance (largest singular values first). We keep only the first \\(r=50\\) modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.\nKey Insight: The POD basis \\(V\\) captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.\n\n\n\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nThe full-order operators are projected onto the reduced space: \\[A_r^q = V^T A^q V, \\quad f_r = V^T f\\]\nFor our affine case: - \\(A_r^1 = V^T K_\\lambda V\\) (reduced volumetric stiffness) - \\(A_r^2 = V^T K_\\mu V\\) (reduced deviatoric stiffness) - \\(f_r = V^T f\\) (reduced load vector)\nThese are small \\(r \\times r\\) matrices instead of \\(N \\times N\\) matrices, enabling rapid online assembly."
  },
  {
    "objectID": "reference/problem_structure.html#online-solve-real-time-evaluation",
    "href": "reference/problem_structure.html#online-solve-real-time-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Once the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods"
  },
  {
    "objectID": "reference/problem_structure.html#validation-ensuring-rom-quality",
    "href": "reference/problem_structure.html#validation-ensuring-rom-quality",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "It’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction"
  },
  {
    "objectID": "reference/problem_structure.html#advanced-topics",
    "href": "reference/problem_structure.html#advanced-topics",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used."
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html",
    "href": "reference/problem_classes.master_class_static.html",
    "title": "problem_classes.master_class_static",
    "section": "",
    "text": "problem_classes.master_class_static\nModule for static reduced-order modeling (ROM):"
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#classes",
    "href": "reference/problem_classes.master_class_static.html#classes",
    "title": "problem_classes.master_class_static",
    "section": "Classes",
    "text": "Classes\n\n\n\nName\nDescription\n\n\n\n\nProblem\nAbstract base for conductivity problems under affine decomposition.\n\n\nfom_simulation\nOffline snapshot generator using full-order FEM.\n\n\nrom_simulation\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\nProblem\nproblem_classes.master_class_static.Problem()\nAbstract base for conductivity problems under affine decomposition.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn affine bilinear form components.\n\n\ndomain\nReturn geometry and FEM bases.\n\n\nfom_solver\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn affine linear form components.\n\n\nparameters\nGenerate sampling of parameter space.\n\n\nproperties\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nSolve reduced-order model for given parameters.\n\n\n\n\nbilinear_forms\nproblem_classes.master_class_static.Problem.bilinear_forms()\nReturn affine bilinear form components.\n\n\ndomain\nproblem_classes.master_class_static.Problem.domain()\nReturn geometry and FEM bases.\n\n\nfom_solver\nproblem_classes.master_class_static.Problem.fom_solver()\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nproblem_classes.master_class_static.Problem.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nproblem_classes.master_class_static.Problem.linear_forms()\nReturn affine linear form components.\n\n\nparameters\nproblem_classes.master_class_static.Problem.parameters()\nGenerate sampling of parameter space.\n\n\nproperties\nproblem_classes.master_class_static.Problem.properties()\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nproblem_classes.master_class_static.Problem.rom_solver()\nSolve reduced-order model for given parameters.\n\n\n\n\nfom_simulation\nproblem_classes.master_class_static.fom_simulation(num_snapshots=32)\nOffline snapshot generator using full-order FEM.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nrun_simulation\nGenerate snapshots and record timings.\n\n\n\n\nrun_simulation\nproblem_classes.master_class_static.fom_simulation.run_simulation()\nGenerate snapshots and record timings.\n\n\n\n\nrom_simulation\nproblem_classes.master_class_static.rom_simulation(\n    mean=None,\n    fos_solutions=None,\n    train_mask=None,\n    test_mask=None,\n    V_sel=None,\n    n_sel=None,\n    N_rom_snap=None,\n)\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nrun_hyper_rom_simulation\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\nrun_rom_simulation\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\nrun_hyper_rom_simulation\nproblem_classes.master_class_static.rom_simulation.run_hyper_rom_simulation(z)\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\narray_like\nWeight vector for hyper-reduction (stored for reference).\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nhyper_rom_error\nlist of float\nPercent error per snapshot.\n\n\nhyper_speed_up\nlist of float\nFull/FOM time ratio per snapshot.\n\n\n\n\n\n\nrun_rom_simulation\nproblem_classes.master_class_static.rom_simulation.run_rom_simulation()\nExecute ROM solves, compute error percentages and speed-ups.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nrom_error\nlist of float\nPercent error per snapshot.\n\n\nspeed_up\nlist of float\nFull/ROM time ratio per snapshot."
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#functions",
    "href": "reference/problem_classes.master_class_static.html#functions",
    "title": "problem_classes.master_class_static",
    "section": "Functions",
    "text": "Functions\n\n\n\nName\nDescription\n\n\n\n\nget_problem\nInstantiate a registered problem by name.\n\n\nregister_problem\nDecorator to register a problem class under a given name.\n\n\n\n\nget_problem\nproblem_classes.master_class_static.get_problem(name)\nInstantiate a registered problem by name.\n\n\nregister_problem\nproblem_classes.master_class_static.register_problem(name)\nDecorator to register a problem class under a given name."
  },
  {
    "objectID": "reference/hyperreduction.html",
    "href": "reference/hyperreduction.html",
    "title": "hyperreduction",
    "section": "",
    "text": "hyperreduction\nhyperreduction\nThe hyperreduce package provides tools to perform hyper‐reduction on full‐order models.\nContents: - bilinear_form_hyperrom.py & linear_form_hyperrom.py: Classes that cluster elements by free‐DOF counts, project local stiffness/load contributions onto reduced bases, and assemble global reduced matrices/vectors. - hyperreduce.py: End‐to‐end pipeline combining randomized SVD preprocessing with bounded NNLS solves for weight selection, plus plotting diagnostics. - custom_nnls.py: Wrapped NNLS solver specialized for hyper‐reduction constraints.\nThese modules streamline the construction of sparse, hyper‐reduced operators and right‐hand sides for fast, accurate reduced‐order simulations."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.html",
    "href": "reference/hyperreduction.ecsw.html",
    "title": "hyperreduction.ecsw",
    "section": "",
    "text": "hyperreduction.ecsw\nhyperreduction.ecsw"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "hyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/fom.html",
    "href": "reference/fom.html",
    "title": "fom",
    "section": "",
    "text": "fom"
  },
  {
    "objectID": "reference/fom.html#fem_utils.py",
    "href": "reference/fom.html#fem_utils.py",
    "title": "fom",
    "section": "fem_utils.py",
    "text": "fem_utils.py\nFinite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "problem_structure.html",
    "href": "problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Video\nLinear Elasticity\nThis comprehensive tutorial demonstrates the complete process of developing a reduced-order model (ROM) for a three-dimensional linear elastic structure using scikit-rom. You’ll learn how each component operates, understand the interconnections between files, and discover how to build an affine ROM that enables real-time or near-real-time simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-description",
    "href": "problem_structure.html#problem-description",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Problem Description",
    "text": "Problem Description\nWe analyze a 3D block governed by linear elasticity principles. The structure features two distinct material regions with different stiffness properties, enabling demonstration of spatially varying material handling through affine decomposition. Core characteristics include:\nLinear Affine Elasticity: The stiffness matrix is constructed as a linear combination of blocks that are affine in the Lamé parameters \\((\\lambda, \\mu)\\).\nDomain Partitioning: The block is divided into two regions with distinct elastic properties.\nParameter Space: Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) are sampled for both offline and online ROM phases.\nBoundary Conditions: Dirichlet constraints (fixed displacement) on one face; Neumann conditions (applied traction) on the opposing face.\nLink",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#project-architecture",
    "href": "problem_structure.html#project-architecture",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Project Architecture",
    "text": "Project Architecture\nThe simulation workflow is organized through the following directory structure and files:\nproblem_1/\n├─ domain.py           # Mesh generation, basis setup, boundary and region partitioning\n├─ bilinear_forms.py   # Affine weak form (stiffness) assembly\n├─ linear_forms.py     # Load (traction) right-hand side term\n├─ properties.py       # Lamé parameter computation per region\n├─ params.py           # Sampling (E, ν) for training and testing\n└─ problem_def.py      # Main orchestration: assembles all components for scikit-rom\n└─ problem_1.ipynb     # Executes the complete workflow starting from data generation to model reduction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "href": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "1. Geometry & Finite Element Framework — domain.py",
    "text": "1. Geometry & Finite Element Framework — domain.py\nMesh Construction: The domain represents a 3D block discretized with hexahedral elements, parameterized by dimensions \\((l_x, l_y, l_z)\\) and mesh refinement factor for resolution control.\nBasis Functions: Employs vector-valued trilinear hexahedral elements to represent 3D displacement fields.\nBoundary Identification:\n\n'left': Dirichlet (fixed displacement)\n'right': Neumann (applied load)\n\nRegion Partitioning: The mesh is divided along the \\(x\\)-axis at the midpoint into:\n\nregion_1: \\(x \\leq 0.5 \\cdot l_x\\) (stiffer region)\nregion_2: \\(x &gt; 0.5 \\cdot l_x\\) (softer region)\n\nThe module returns a comprehensive dictionary containing the mesh, bases, boundary DOFs, and a per-region basis dictionary for subsequent operator assembly.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "href": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "2. Material Properties & Affine Coefficient Functions — properties.py",
    "text": "2. Material Properties & Affine Coefficient Functions — properties.py\nLamé Parameters: Transforms Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) into Lamé parameters \\((\\lambda, \\mu)\\) using skfem utilities.\nRegion Handling:\n\nFor region_1, both \\(\\lambda\\) and \\(\\mu\\) are scaled by \\(50\\times\\) (stiffer inclusion)\nFor region_2, properties remain unchanged (baseline material)",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "href": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py",
    "text": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py\nAffine Bilinear Forms:\n\nstiffness_lam: Weak form for the \\(\\lambda\\) (volumetric) component\nstiffness_mu: Weak form for the \\(\\mu\\) (shear) component\n\nMathematics: Each block is computed per-region (using basis restriction). The global stiffness matrix is expressed as:\n\\(K(E,\\nu) = \\sum_{\\text{regions}} \\lambda \\cdot K_{\\lambda,\\text{region}} + \\mu \\cdot K_{\\mu,\\text{region}}\\)\nParameter-Dependent Evaluation: Lamé parameters are computed as needed for each region via the region-aware property function.\nThis approach ensures the assembly aligns with the affine decomposition essential for efficient ROM evaluation.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "href": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "4. Right-Hand Side (Loads) — linear_forms.py",
    "text": "4. Right-Hand Side (Loads) — linear_forms.py\nNeumann Traction: Implements a constant traction (-1e-2) in the global \\(y\\)-direction applied to the ‘right’ face.\nAffine in Parameters: The load vector is parameter-independent and only needs to be assembled once for the entire ROM process.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#parameter-sampling-params.py",
    "href": "problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "5. Parameter Sampling — params.py",
    "text": "5. Parameter Sampling — params.py\nParameter Ranges:\n\n\\(E\\): [2.0, 10.0]\n\\(\\nu\\): [0.2, 0.4]\n\nSampling Strategy: Uses Sobol sequences to create quasi-random sets of \\((E,\\nu)\\) pairs for:\n\nTraining snapshots (for ROM basis construction)\nTesting snapshots (for validation)\n\nMasks Provided: Returns boolean arrays to cleanly separate training vs testing data.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-orchestration-problem_def.py",
    "href": "problem_structure.html#problem-orchestration-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "6. Problem Orchestration — problem_def.py",
    "text": "6. Problem Orchestration — problem_def.py\nMaster Problem Class: Inherits from the scikit-rom base and registers essential routines:\n\ndomain(): Loads mesh and DOFs from domain.py\nbilinear_forms(): Returns affine weak forms for \\(\\lambda\\) and \\(\\mu\\)\nlinear_forms(): Returns the Neumann loading routine\nproperties(): Returns the regionwise Lamé parameter mapper\nparameters(n_samples): Returns parameter sets and train/test split\n\nAffine Operator Assembly: On the first solve, stiffness and load “blocks” are assembled separately for each region/material.\nFull-Order Solve: Assembles and solves the condensed system with Dirichlet BCs for each parameter instance.\nROM Projection: Projects global blocks onto the reduced basis, incorporating an offline mean-shift to keep the ROM centered.\nThis design ensures a clear separation between model definition (problem file) and algorithmic ROM machinery (provided by scikit-rom).",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#offline-workflow-building-the-rom",
    "href": "problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "7. Offline Workflow: Building the ROM",
    "text": "7. Offline Workflow: Building the ROM\nStep-by-step process:\n\nParameter Sampling: Generate \\(n\\) training samples \\((E_i, \\nu_i)\\) using the routine from params.py.\nFull-Order Simulations: For each parameter, solve the full high-fidelity FEM system and store the solution as a snapshot.\nData Processing:\n\nMean Subtraction: Subtract the mean from all snapshots to center the dataset\nSVD/POD: Perform singular value decomposition on the mean-subtracted snapshots to find the dominant modes (energy-ranked spatial patterns)\nMode Truncation: Retain only the leading \\(r\\) modes (user- or error-determined) for reduced basis\n\nReduced Operator Assembly: Project per-region blocks \\((K_{\\lambda,\\text{region}}, K_{\\mu,\\text{region}})\\) into the reduced space, yielding ultra-compact operators.\n\nThe reduced model is now ready for very rapid online predictions.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#online-workflow-fast-evaluation",
    "href": "problem_structure.html#online-workflow-fast-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "8. Online Workflow: Fast Evaluation",
    "text": "8. Online Workflow: Fast Evaluation\nFor a new parameter set \\((E, \\nu)\\):\n\nCompute Per-Region Lamé Parameters: Map input parameters to \\((\\lambda, \\mu)\\) values for each region.\nAssemble Reduced Stiffness: Combine precomputed regionwise blocks using affine expressions.\nSolve Reduced System: The resulting linear system has size equal to the number of modes \\((r \\ll N)\\), making it extremely fast.\nMean Recovery: Add back the mean field to produce the full-field displacement solution, ready for visualization or further analysis.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#validation-error-assessment",
    "href": "problem_structure.html#validation-error-assessment",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "9. Validation & Error Assessment",
    "text": "9. Validation & Error Assessment\nTest Set: Evaluate the ROM on held-out (never-seen) parameter pairs.\nError Metrics:\n\nRelative error (L2 or energy norm) between ROM and high-fidelity FOM solutions\nStatistical fit metrics (e.g., R² score)\n\nSpeed-up Factor: The ROM typically achieves significant speed-up (often orders of magnitude) versus direct FEM.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#summary-table-of-key-methods",
    "href": "problem_structure.html#summary-table-of-key-methods",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "10. Summary Table of Key Methods",
    "text": "10. Summary Table of Key Methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nTypical Location in Pipeline\n\n\n\n\ndomain()\nSetup mesh, BCs, DOFs, and per-region bases\nFirst, before assembly\n\n\nbilinear_forms()\nReturn affine form handles for λ, μ\nOperator initialization\n\n\nlinear_forms()\nSpecify right-hand-side (load)\nOperator assembly\n\n\nproperties()\nMap (E, ν, region) → (λ, μ)\nParameter unpacking\n\n\nparameters()\nProduce sampled (E, ν) + train/test masks\nOffline/online split\n\n\nfom_solver()\nRun and store full-order solutions\nSnapshot generation (offline)\n\n\nrom_solver()\nAssemble and solve projected ROM system\nRapid online prediction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#best-practices",
    "href": "problem_structure.html#best-practices",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "11. Best Practices",
    "text": "11. Best Practices\n\nAlways center your snapshot data before SVD to ensure best POD convergence\nUse enough training samples (and parameter space coverage) to avoid overfitting or “holes” in ROM accuracy\nCheck ROM error on multiple, unseen test samples\nVisualize spatial error fields—not just scalar error metrics—for insight into local ROM limitations\nLeverage the modular file structure for extending to other domains, BCs, and PDEs\n\nThis workflow and modular codebase provide a flexible, scalable foundation for reduced-order modeling of parametrized PDEs in computational mechanics, accelerating simulation, optimization, and interactive design.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "nonlinear_power_law.html#problem-setup",
    "href": "nonlinear_power_law.html#problem-setup",
    "title": "P.1 Nonlinear power-law (strain-hardening) bar under gravity and line load",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.1 Nonlinear power-law (strain-hardening) bar under gravity and line load"
    ]
  },
  {
    "objectID": "linear bending.html#problem-setup",
    "href": "linear bending.html#problem-setup",
    "title": "P.3 Heterogeneous linear elasticity in a two-material 3D block",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink\nSee detailed tutorial for this problem",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.3 Heterogeneous linear elasticity in a two-material 3D block"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to skrom",
    "section": "",
    "text": "scikit-rom is a lightweight, Python-based platform designed for projection-based model reduction of finite element models with moderate to large problem sizes (up to approximately 600,000 degrees of freedom). Built on top of scikit-fem, an easy-to-use finite element assembly library, this repository demonstrates reduced-order modeling (ROM) techniques for a range of linear and nonlinear problems, including time-dependent ones. Current examples primarily focus on thermal and mechanical systems, with extensions to fluid dynamics planned for future releases.\nBeyond its application to real-world finite element problems, the library also serves as a valuable testing ground for new model reduction algorithms and as a tutorial resource for those new to the field."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Welcome to skrom",
    "section": "Installation",
    "text": "Installation\n\n\nThis tutorial explains how to install SKROM (scikit-ROM):\nInstallation Steps:\n\nClone the repository:\n\ngit clone https://github.com/suparnob100/scikit-rom\ncd scikit-rom\n\nInstall with pip:\n\n\nFor developers (editable install):\n\npip install -e .\n\nFor regular users:\n\npip install .\n(Use pip3 instead of pip on Mac)\nNotes:\n\nUse -e for development; it lets you edit the code without reinstalling.\nRegular users should use standard installation.\nReinstallation automatically removes the old version.\nThe installation completes in seconds and shows “successfully built SKROM.”\nAll instructions are available on the GitHub page."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Welcome to skrom",
    "section": "Getting Started",
    "text": "Getting Started"
  },
  {
    "objectID": "index.html#recommended-reading",
    "href": "index.html#recommended-reading",
    "title": "Welcome to skrom",
    "section": "Recommended Reading",
    "text": "Recommended Reading\nTo dive deeper, check out:\n\nHyper-reduction Techniques for Efficient Simulation"
  },
  {
    "objectID": "linear star.html#problem-setup",
    "href": "linear star.html#problem-setup",
    "title": "P.4 Linear heat conduction with non-affine parametric source on a star-shaped plate",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Heat Transfer",
      "P.4 Linear heat conduction with non-affine parametric source on a star-shaped plate"
    ]
  },
  {
    "objectID": "non_linear.html#problem-setup",
    "href": "non_linear.html#problem-setup",
    "title": "P.5 Nonlinear heat conduction in a two-material 1-D rod",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Heat Transfer",
      "P.5 Nonlinear heat conduction in a two-material 1-D rod"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html",
    "href": "reference/fom.fem_utils.html",
    "title": "fom.fem_utils",
    "section": "",
    "text": "fom.fem_utils\nThis module includes:\n\nbuild_pc_amgsa: construct AMG smoothed aggregation preconditioner.\nelement2location: generate element-to-coordinate mappings from mesh data.\nnewton_solver and its helpers: perform Newton–Raphson solves with or without Dirichlet BC.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nGiven a dict mapping region names to boolean element‐masks,\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_mesh_and_basis\nCall domain() and assign just mesh and basis onto self.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\nunwrap_attr\nIf self. is a 0-d object ndarray, replace it with its .item().\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nGiven a dict mapping region names to boolean element‐masks, returns a dict of reduced bases for each region.\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nCall domain() and assign just mesh and basis onto self.\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.\n\n\n\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nIf self. is a 0-d object ndarray, replace it with its .item().",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html#functions",
    "href": "reference/fom.fem_utils.html#functions",
    "title": "fom.fem_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nGiven a dict mapping region names to boolean element‐masks,\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_mesh_and_basis\nCall domain() and assign just mesh and basis onto self.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\nunwrap_attr\nIf self. is a 0-d object ndarray, replace it with its .item().\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nGiven a dict mapping region names to boolean element‐masks, returns a dict of reduced bases for each region.\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nCall domain() and assign just mesh and basis onto self.\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.\n\n\n\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nIf self. is a 0-d object ndarray, replace it with its .item().",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.bilinear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly"
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "hyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html",
    "href": "reference/hyperreduction.linear_form_hyperrom.html",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.linear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "fom.fem_utils\nThis module includes:",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#full-order-model-fom",
    "href": "reference/index.html#full-order-model-fom",
    "title": "Function reference",
    "section": "",
    "text": "fom.fem_utils\nThis module includes:",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reduced-order-model-rom",
    "href": "reference/index.html#reduced-order-model-rom",
    "title": "Function reference",
    "section": "Reduced-Order Model (ROM)",
    "text": "Reduced-Order Model (ROM)\n\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#deim-hyper-reduction",
    "href": "reference/index.html#deim-hyper-reduction",
    "title": "Function reference",
    "section": "DEIM Hyper-Reduction",
    "text": "DEIM Hyper-Reduction\n\n\n\nrom.deim.bilinear_form_hyperrom_deim\n\n\n\nrom.deim.linear_form_hyperrom_deim\n\n\n\nrom.deim.deim",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ecsw-hyper-reduction",
    "href": "reference/index.html#ecsw-hyper-reduction",
    "title": "Function reference",
    "section": "ECSW Hyper-Reduction",
    "text": "ECSW Hyper-Reduction\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw\n\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Function reference",
    "section": "Utilities",
    "text": "Utilities\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.reduced_basis.svd",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#dynamics",
    "href": "reference/index.html#dynamics",
    "title": "Function reference",
    "section": "Dynamics",
    "text": "Dynamics\n\n\n\nutils.dynamics.integrators\n\n\n\nutils.dynamics.newmark_beta",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#visualization",
    "href": "reference/index.html#visualization",
    "title": "Function reference",
    "section": "Visualization",
    "text": "Visualization\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette\n\n\n\nutils.visualization.plot_utils",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#templates",
    "href": "reference/index.html#templates",
    "title": "Function reference",
    "section": "Templates",
    "text": "Templates\n\n\n\ntemplates.problem_template.bilinear_forms\n\n\n\ntemplates.problem_template.linear_forms\n\n\n\ntemplates.problem_template.params\n\n\n\ntemplates.problem_template.domain\n\n\n\ntemplates.problem_template.problem_def\n\n\n\ntemplates.problem_template.properties",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/problem_classes.html",
    "href": "reference/problem_classes.html",
    "title": "problem_classes",
    "section": "",
    "text": "problem_classes"
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html",
    "href": "reference/rom.bilinear_form_rom.html",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\nThis module provides:\n\nBilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\n\nThe rom folder contains core tools for reduced-order modeling (ROM), including:\n\nClasses for projecting and assembling reduced-order bilinear and linear forms\nUtilities for handling Dirichlet boundary conditions in reduced spaces\nChunked and clustered assembly routines to manage large-scale stiffness/load data\nMapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html#classes",
    "href": "reference/rom.bilinear_form_rom.html#classes",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.deim.deim.html",
    "href": "reference/rom.deim.deim.html",
    "title": "rom.deim.deim",
    "section": "",
    "text": "rom.deim.deim\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim\nClass to perform the Discrete Empirical Interpolation Method (DEIM) for\n\n\n\n\n\nrom.deim.deim.deim(mesh, F_nl, V_sel, tol_f=0.01, extra_modes=0)\nClass to perform the Discrete Empirical Interpolation Method (DEIM) for reducing the dimension of nonlinear force terms in a reduced order model (ROM) within a finite element framework.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim_dof_to_elem\nMap the selected degrees-of-freedom (DOFs) to an element indicator vector.\n\n\ndeim_red\nPerform the standard Discrete Empirical Interpolation Method (DEIM) to select rows\n\n\nselect_elems\nSelect the elements (or rows) for DEIM reduction based on the computed snapshot basis.\n\n\n\n\n\nrom.deim.deim.deim.deim_dof_to_elem(deim_dof)\nMap the selected degrees-of-freedom (DOFs) to an element indicator vector. Each element (or cell) is flagged if any of its nonzero node equation IDs appear in the DEIM-selected DOFs.\n\n\ndeim_dof : list List of DOF indices selected by the DEIM or S-optimal procedure.\n\n\n\nx : ndarray A binary vector indicating for each element whether it contains any of the selected DOFs (1 if yes, 0 if no).\n\n\n\n\nrom.deim.deim.deim.deim_red(f_basis, num_f_basis_vectors_used)\nPerform the standard Discrete Empirical Interpolation Method (DEIM) to select rows that capture the dominant features of the nonlinear basis.\n\n\nf_basis : ndarray Basis matrix derived from the nonlinear force snapshots. num_f_basis_vectors_used : int Number of basis vectors (modes) to use for the reduction.\n\n\n\nf_basis_sampled : ndarray Matrix of the selected rows from the original basis. sampled_rows : list List of row indices that were selected. is_sampled : ndarray Boolean array indicating which rows of the original basis are selected.\n\n\n\n\nrom.deim.deim.deim.select_elems()\nSelect the elements (or rows) for DEIM reduction based on the computed snapshot basis. This method: 1. Performs SVD on the nonlinear force snapshots to determine dominant modes. 2. Uses an S-optimal sampling strategy (or DEIM, if uncommented) to select rows. 3. Maps the selected DOFs back to element indicators. 4. Constructs the DEIM projection matrix.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.deim.html#classes",
    "href": "reference/rom.deim.deim.html#classes",
    "title": "rom.deim.deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndeim\nClass to perform the Discrete Empirical Interpolation Method (DEIM) for\n\n\n\n\n\nrom.deim.deim.deim(mesh, F_nl, V_sel, tol_f=0.01, extra_modes=0)\nClass to perform the Discrete Empirical Interpolation Method (DEIM) for reducing the dimension of nonlinear force terms in a reduced order model (ROM) within a finite element framework.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim_dof_to_elem\nMap the selected degrees-of-freedom (DOFs) to an element indicator vector.\n\n\ndeim_red\nPerform the standard Discrete Empirical Interpolation Method (DEIM) to select rows\n\n\nselect_elems\nSelect the elements (or rows) for DEIM reduction based on the computed snapshot basis.\n\n\n\n\n\nrom.deim.deim.deim.deim_dof_to_elem(deim_dof)\nMap the selected degrees-of-freedom (DOFs) to an element indicator vector. Each element (or cell) is flagged if any of its nonzero node equation IDs appear in the DEIM-selected DOFs.\n\n\ndeim_dof : list List of DOF indices selected by the DEIM or S-optimal procedure.\n\n\n\nx : ndarray A binary vector indicating for each element whether it contains any of the selected DOFs (1 if yes, 0 if no).\n\n\n\n\nrom.deim.deim.deim.deim_red(f_basis, num_f_basis_vectors_used)\nPerform the standard Discrete Empirical Interpolation Method (DEIM) to select rows that capture the dominant features of the nonlinear basis.\n\n\nf_basis : ndarray Basis matrix derived from the nonlinear force snapshots. num_f_basis_vectors_used : int Number of basis vectors (modes) to use for the reduction.\n\n\n\nf_basis_sampled : ndarray Matrix of the selected rows from the original basis. sampled_rows : list List of row indices that were selected. is_sampled : ndarray Boolean array indicating which rows of the original basis are selected.\n\n\n\n\nrom.deim.deim.deim.select_elems()\nSelect the elements (or rows) for DEIM reduction based on the computed snapshot basis. This method: 1. Performs SVD on the nonlinear force snapshots to determine dominant modes. 2. Uses an S-optimal sampling strategy (or DEIM, if uncommented) to select rows. 3. Maps the selected DOFs back to element indicators. 4. Constructs the DEIM projection matrix.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.deim"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.bilinear_form_hyperrom_ecsw\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including:\n\nClasses for reduced‐order bilinear and linear forms with element clustering\nRoutines to extract local element matrices/vectors in the ROM basis\nUtilities for efficient handling of Dirichlet conditions in reduced spaces\nSupport for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#hyperreducebilinear_form_hyperrom.py",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including:\n\nClasses for reduced‐order bilinear and linear forms with element clustering\nRoutines to extract local element matrices/vectors in the ROM basis\nUtilities for efficient handling of Dirichlet conditions in reduced spaces\nSupport for element‐wise parallelization and weighted assembly",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html",
    "href": "reference/rom.ecsw.hyperreduce.html",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "rom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides:\n\nhyperreduce: function to perform hyper-reduction on a QoI matrix by:\n\nOptionally applying randomized SVD for dimensionality reduction\nConstructing bounded constraints for NNLS from projected data\nSolving a bounded NNLS problem via NNLSSolver\nOptionally visualizing singular value decay and NNLS coefficients\n\n\nThe hyperreduce folder contains utilities to reduce full-order models, including:\n\nRandomized SVD preprocessing routines\nBounded NNLS solve integrations (custom_nnls)\nPlotting helpers for diagnostic visualization of reduction errors\n\nDependencies:\n\nNumPy for array operations\nscikit-learn’s randomized_svd for fast SVD\nMatplotlib for plotting diagnostics\nCustom NNLSSolver implementation in custom_nnls\n\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html#functions",
    "href": "reference/rom.ecsw.hyperreduce.html#functions",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.html",
    "href": "reference/rom.ecsw.html",
    "title": "rom.ecsw",
    "section": "",
    "text": "rom.ecsw\nThe ecsw folder implements Empirical Cubature Subset Weighting (ECSW) methods.\nContents: - nnls_solver.py: Active‐set bounded NNLS solver (NNLSSolver) with L₂/L∞ criteria for computing nonnegative cubature weights under per-entry bounds. - Utilities for convergence testing (NNLS_termination), argument verification, and solver configuration.\nTogether, these tools select and weight integration points to approximate high‐dimensional integrals with a sparse subset, enabling efficient reduced‐order model assembly."
  },
  {
    "objectID": "reference/rom.linear_form_rom.html",
    "href": "reference/rom.linear_form_rom.html",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "rom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\nThis module provides:\n\nLinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\n\nThe rom folder contains core tools for reduced-order modeling (ROM), including:\n\nClasses for projecting and assembling reduced-order bilinear and linear forms\nUtilities for handling Dirichlet boundary conditions in reduced spaces\nChunked and clustered assembly routines to manage large-scale stiffness/load data\nMapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html#classes",
    "href": "reference/rom.linear_form_rom.html#classes",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html",
    "href": "reference/rom.rom_error_est.html",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "rom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\nThis module provides:\n\ncompute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm).\nplot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up.\ngenerate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console.\n\nThe rom folder contains core tools for reduced-order modeling, including:\n\nAssembly abstractions for reduced bilinear and linear forms\nError evaluation and reporting utilities (this module)\nHyper-reduction and cubature integration tools\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html#functions",
    "href": "reference/rom.rom_error_est.html#functions",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.bilinear_forms.html",
    "href": "reference/templates.problem_template.bilinear_forms.html",
    "title": "templates.problem_template.bilinear_forms",
    "section": "",
    "text": "templates.problem_template.bilinear_forms\n\n\n\n\n\nName\nDescription\n\n\n\n\na\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver):\n\n\n\n\n\ntemplates.problem_template.bilinear_forms.a(u, v, w)\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver): ∫_Ω [your integrand here] dx\n\n\nu : array_like or callable Trial (or current Newton iterate) values at quadrature points. v : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for global matrix assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the Jacobian matrix.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.bilinear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.bilinear_forms.html#functions",
    "href": "reference/templates.problem_template.bilinear_forms.html#functions",
    "title": "templates.problem_template.bilinear_forms",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\na\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver):\n\n\n\n\n\ntemplates.problem_template.bilinear_forms.a(u, v, w)\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver): ∫_Ω [your integrand here] dx\n\n\nu : array_like or callable Trial (or current Newton iterate) values at quadrature points. v : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for global matrix assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the Jacobian matrix.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.bilinear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.linear_forms.html",
    "href": "reference/templates.problem_template.linear_forms.html",
    "title": "templates.problem_template.linear_forms",
    "section": "",
    "text": "templates.problem_template.linear_forms\n\n\n\n\n\nName\nDescription\n\n\n\n\nl\nTemplate for your problem’s linear (load or residual) form:\n\n\n\n\n\ntemplates.problem_template.linear_forms.l(v, w)\nTemplate for your problem’s linear (load or residual) form: ∫_Ω [your integrand here] dx\n\n\nv : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for right-hand side vector assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the residual vector.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.linear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.linear_forms.html#functions",
    "href": "reference/templates.problem_template.linear_forms.html#functions",
    "title": "templates.problem_template.linear_forms",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nl\nTemplate for your problem’s linear (load or residual) form:\n\n\n\n\n\ntemplates.problem_template.linear_forms.l(v, w)\nTemplate for your problem’s linear (load or residual) form: ∫_Ω [your integrand here] dx\n\n\nv : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for right-hand side vector assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the residual vector.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.linear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.problem_def.html",
    "href": "reference/templates.problem_template.problem_def.html",
    "title": "templates.problem_template.problem_def",
    "section": "",
    "text": "templates.problem_template.problem_def\n\n\n\n\n\nName\nDescription\n\n\n\n\nProblemTemplate\nTemplate for an affine or non-linear ROM problem.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate()\nTemplate for an affine or non-linear ROM problem.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn a list of bilinear form callables (or Jacobian forms for nonlinear problems).\n\n\ndomain\nSetup mesh, basis, DOFs, and boundary conditions.\n\n\nfom_operators\nAssemble (and cache on first call) the full-order operators\n\n\nfom_rhs\nAssemble (and cache on first call) the full-order right-hand side vector.\n\n\nfom_solver\nSolve the full-order model for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn a list of linear form callables (or residual forms for nonlinear problems).\n\n\nparameters\nGenerate sampling design over parameter space.\n\n\nproperties\nReturn a list of functions mapping physical parameters to coefficients.\n\n\nreduced_operators\nProject FOM operators onto the reduced basis and compute\n\n\nrom_solver\nSolve the reduced-order model and reconstruct the full solution.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.bilinear_forms()\nReturn a list of bilinear form callables (or Jacobian forms for nonlinear problems). Each form should have signature a(u, v, w).\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.domain()\nSetup mesh, basis, DOFs, and boundary conditions.\nReturns: dict with keys like - ‘mesh’ - ‘basis’ - ‘free_dofs’ - ‘dirichlet_dofs’ - ‘dirichlet_value’ # …any other domain-specific items…\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_operators(cls)\nAssemble (and cache on first call) the full-order operators needed by the FOM solver (e.g. stiffness matrix).\nReturns: tuple of FOM operators\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_rhs(cls)\nAssemble (and cache on first call) the full-order right-hand side vector.\nReturns: full-order RHS vector\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_solver(cls, param)\nSolve the full-order model for given parameters.\nReturns: solution array satisfying BCs\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.linear_forms()\nReturn a list of linear form callables (or residual forms for nonlinear problems). Each form should have signature l(v, w).\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.parameters(n_samples)\nGenerate sampling design over parameter space.\nParameters: n_samples (int): number of samples to draw.\nReturns: params, param_ranges, train_mask, test_mask\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.properties()\nReturn a list of functions mapping physical parameters to coefficients. E.g. [k_func, q_func, …]\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.reduced_operators(\n    cls,\n    param,\n)\nProject FOM operators onto the reduced basis and compute any mean or offset terms needed for the ROM.\nReturns: (modal_solution_full_space, mean_correction)\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.rom_solver(cls, param)\nSolve the reduced-order model and reconstruct the full solution.\nReturns: (parameter_scaled_modal_solution, mean_correction)",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.problem_def"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.problem_def.html#classes",
    "href": "reference/templates.problem_template.problem_def.html#classes",
    "title": "templates.problem_template.problem_def",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nProblemTemplate\nTemplate for an affine or non-linear ROM problem.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate()\nTemplate for an affine or non-linear ROM problem.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn a list of bilinear form callables (or Jacobian forms for nonlinear problems).\n\n\ndomain\nSetup mesh, basis, DOFs, and boundary conditions.\n\n\nfom_operators\nAssemble (and cache on first call) the full-order operators\n\n\nfom_rhs\nAssemble (and cache on first call) the full-order right-hand side vector.\n\n\nfom_solver\nSolve the full-order model for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn a list of linear form callables (or residual forms for nonlinear problems).\n\n\nparameters\nGenerate sampling design over parameter space.\n\n\nproperties\nReturn a list of functions mapping physical parameters to coefficients.\n\n\nreduced_operators\nProject FOM operators onto the reduced basis and compute\n\n\nrom_solver\nSolve the reduced-order model and reconstruct the full solution.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.bilinear_forms()\nReturn a list of bilinear form callables (or Jacobian forms for nonlinear problems). Each form should have signature a(u, v, w).\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.domain()\nSetup mesh, basis, DOFs, and boundary conditions.\nReturns: dict with keys like - ‘mesh’ - ‘basis’ - ‘free_dofs’ - ‘dirichlet_dofs’ - ‘dirichlet_value’ # …any other domain-specific items…\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_operators(cls)\nAssemble (and cache on first call) the full-order operators needed by the FOM solver (e.g. stiffness matrix).\nReturns: tuple of FOM operators\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_rhs(cls)\nAssemble (and cache on first call) the full-order right-hand side vector.\nReturns: full-order RHS vector\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_solver(cls, param)\nSolve the full-order model for given parameters.\nReturns: solution array satisfying BCs\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.linear_forms()\nReturn a list of linear form callables (or residual forms for nonlinear problems). Each form should have signature l(v, w).\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.parameters(n_samples)\nGenerate sampling design over parameter space.\nParameters: n_samples (int): number of samples to draw.\nReturns: params, param_ranges, train_mask, test_mask\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.properties()\nReturn a list of functions mapping physical parameters to coefficients. E.g. [k_func, q_func, …]\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.reduced_operators(\n    cls,\n    param,\n)\nProject FOM operators onto the reduced basis and compute any mean or offset terms needed for the ROM.\nReturns: (modal_solution_full_space, mean_correction)\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.rom_solver(cls, param)\nSolve the reduced-order model and reconstruct the full solution.\nReturns: (parameter_scaled_modal_solution, mean_correction)",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.problem_def"
    ]
  },
  {
    "objectID": "reference/utils.basic.html",
    "href": "reference/utils.basic.html",
    "title": "utils.basic",
    "section": "",
    "text": "utils.basic\nutils.basic\nThis module imports essential libraries commonly used in pyHyperRom. By using from pyHyperRom.basic import *, users can access frequently utilized libraries."
  },
  {
    "objectID": "reference/utils.custom_nnls.html",
    "href": "reference/utils.custom_nnls.html",
    "title": "utils.custom_nnls",
    "section": "",
    "text": "utils.custom_nnls\nutils.custom_nnls"
  },
  {
    "objectID": "reference/utils.dynamics.newmark_beta.html",
    "href": "reference/utils.dynamics.newmark_beta.html",
    "title": "utils.dynamics.newmark_beta",
    "section": "",
    "text": "utils.dynamics.newmark_beta\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\n\n\n\nutils.dynamics.newmark_beta.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i]."
  },
  {
    "objectID": "reference/utils.dynamics.newmark_beta.html#functions",
    "href": "reference/utils.dynamics.newmark_beta.html#functions",
    "title": "utils.dynamics.newmark_beta",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\n\n\n\nutils.dynamics.newmark_beta.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i]."
  },
  {
    "objectID": "reference/utils.fem_utils.html",
    "href": "reference/utils.fem_utils.html",
    "title": "utils.fem_utils",
    "section": "",
    "text": "utils.fem_utils\nutils.fem_utils"
  },
  {
    "objectID": "reference/utils.newton_solver.html",
    "href": "reference/utils.newton_solver.html",
    "title": "utils.newton_solver",
    "section": "",
    "text": "utils.newton_solver\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.newton_solver.html#functions",
    "href": "reference/utils.newton_solver.html#functions",
    "title": "utils.newton_solver",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.html",
    "href": "reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils"
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html",
    "href": "reference/utils.reduced_basis.svd.html",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "utils.reduced_basis.svd\n\n\n\n\n\nName\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html#functions",
    "href": "reference/utils.reduced_basis.svd.html#functions",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.rom_utils.html",
    "href": "reference/utils.rom_utils.html",
    "title": "utils.rom_utils",
    "section": "",
    "text": "utils.rom_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.rom_utils.html#functions",
    "href": "reference/utils.rom_utils.html#functions",
    "title": "utils.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html",
    "href": "reference/utils.visualization.generate_vtk.html",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html#functions",
    "href": "reference/utils.visualization.generate_vtk.html#functions",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.plot_utils.html",
    "href": "reference/utils.visualization.plot_utils.html",
    "title": "utils.visualization.plot_utils",
    "section": "",
    "text": "utils.visualization.plot_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\nplot_deim_weights\nCreate a stem plot of xi with a zoomed inset.\n\n\nplot_ecsw_weights_3d\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\nutils.visualization.plot_utils.plot_deim_weights(\n    xi,\n    zoom_indices=(0, 1),\n    figsize=(12, 3),\n    nbins=6,\n    line_color='#163e64',\n    stem_color='#a6a6a6',\n    zoom_loc='upper left',\n    zoom_size=('25%', '40%'),\n    zoom_title='Zoomed-in view',\n    zoom_box_offset_x=-0.5,\n    zoom_box_offset_y=-0.2,\n    zoom_box_width=1.0,\n    zoom_box_height_scale=0.4,\n    zoom_box_color='red',\n    zoom_box_linestyle='--',\n    zoom_box_linewidth=1.0,\n)\nCreate a stem plot of xi with a zoomed inset. Uses constrained_layout for automatic spacing.\n\n\n\nutils.visualization.plot_utils.plot_ecsw_weights_3d(\n    mesh,\n    weights,\n    projection='3d',\n    plane='xy',\n    figsize=(8, 6),\n    cmap='viridis',\n    zero_color='#eeeeee',\n    zero_alpha=0.3,\n    weight_threshold=0.001,\n)\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh with attributes: - p: array of shape (3, n_nodes) for node coords. - t: array of shape (nodes_per_elem, n_elems).\nrequired\n\n\nweights\n1D ndarray of length n_elems\nECSW weight per element.\nrequired\n\n\nprojection\n'3d' or projected\n‘3d’ = scatter in 3D; ‘projected’ = heatmap on a plane.\n'3d'\n\n\nplane\n'xy', 'xz', or 'yz'\nwhich plane to project onto if projected.\n'xy'\n\n\nfigsize\nfigure size.\n\n(8, 6)\n\n\ncmap\nname of colormap for &gt;threshold weights.\n\n'viridis'\n\n\nzero_color\ncolor for weights ≤ threshold.\n\n'#eeeeee'\n\n\nzero_alpha\nalpha for zero_color points.\n\n0.3\n\n\nweight_threshold\nfloat\nany w ≤ this will be considered “zero” for display.\n0.001\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fig, ax)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.plot_utils"
    ]
  },
  {
    "objectID": "reference/utils.visualization.plot_utils.html#functions",
    "href": "reference/utils.visualization.plot_utils.html#functions",
    "title": "utils.visualization.plot_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nplot_deim_weights\nCreate a stem plot of xi with a zoomed inset.\n\n\nplot_ecsw_weights_3d\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\nutils.visualization.plot_utils.plot_deim_weights(\n    xi,\n    zoom_indices=(0, 1),\n    figsize=(12, 3),\n    nbins=6,\n    line_color='#163e64',\n    stem_color='#a6a6a6',\n    zoom_loc='upper left',\n    zoom_size=('25%', '40%'),\n    zoom_title='Zoomed-in view',\n    zoom_box_offset_x=-0.5,\n    zoom_box_offset_y=-0.2,\n    zoom_box_width=1.0,\n    zoom_box_height_scale=0.4,\n    zoom_box_color='red',\n    zoom_box_linestyle='--',\n    zoom_box_linewidth=1.0,\n)\nCreate a stem plot of xi with a zoomed inset. Uses constrained_layout for automatic spacing.\n\n\n\nutils.visualization.plot_utils.plot_ecsw_weights_3d(\n    mesh,\n    weights,\n    projection='3d',\n    plane='xy',\n    figsize=(8, 6),\n    cmap='viridis',\n    zero_color='#eeeeee',\n    zero_alpha=0.3,\n    weight_threshold=0.001,\n)\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh with attributes: - p: array of shape (3, n_nodes) for node coords. - t: array of shape (nodes_per_elem, n_elems).\nrequired\n\n\nweights\n1D ndarray of length n_elems\nECSW weight per element.\nrequired\n\n\nprojection\n'3d' or projected\n‘3d’ = scatter in 3D; ‘projected’ = heatmap on a plane.\n'3d'\n\n\nplane\n'xy', 'xz', or 'yz'\nwhich plane to project onto if projected.\n'xy'\n\n\nfigsize\nfigure size.\n\n(8, 6)\n\n\ncmap\nname of colormap for &gt;threshold weights.\n\n'viridis'\n\n\nzero_color\ncolor for weights ≤ threshold.\n\n'#eeeeee'\n\n\nzero_alpha\nalpha for zero_color points.\n\n0.3\n\n\nweight_threshold\nfloat\nany w ≤ this will be considered “zero” for display.\n0.001\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fig, ax)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.plot_utils"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html",
    "href": "reference/utils.visualization.vtuwriter.html",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "utils.visualization.vtuwriter\n\n\n\n\n\nName\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html#classes",
    "href": "reference/utils.visualization.vtuwriter.html#classes",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html",
    "href": "Resources/intro/rom_intro_ex.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling",
    "text": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling\nWe consider the boundary value problem\n\\[\n- \\frac{d}{dx}\\left(k\\,\\frac{dT}{dx}\\right) = q, \\quad x \\in [0, L],\n\\]\nsubject to the boundary conditions:\n\nNeumann: \\(\\left. \\dfrac{dT}{dx} \\right|_{x=0} = 0\\),\nDirichlet: \\(T(L) = T_L\\),\n\nwhere the material parameters are defined as:\n\\[\nk = 16 + \\mu, \\qquad q = 35000 + \\beta,\n\\]\nwith \\(\\mu\\) and \\(\\beta\\) denoting input parameters.\n\n\nWeak Formulation\nMultiplying the governing equation by a test function \\(v \\in V\\) that vanishes at \\(x = L\\), and integrating over the domain yields the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q\\,v(x)\\, dx.\n\\]\n\n\n\nFinite Element Discretization\nDiscretize the interval \\([0, L]\\) into \\(N\\) uniform linear elements of length \\(h = L / N\\). Approximate the solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are piecewise linear basis functions, and \\(T_j\\) are the nodal temperatures. Choosing \\(v = \\phi_i(x)\\) leads to the discrete form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q\\, \\phi_i(x) \\, dx.\n\\]\nThe global system can be written as:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwith\n\n\\(K_{ij} = \\int_0^L k, \\dfrac{d\\phi_j}{dx} \\dfrac{d\\phi_i}{dx} , dx\\) (stiffness matrix),\n\\(F_i = \\int_0^L q, \\phi_i(x) , dx\\) (load vector),\n\\(\\mathbf{T} = [T_1, \\dots, T_n]^\\top\\) (nodal temperatures).\n\nOn each element, the local contributions are:\n\nStiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLoad vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}.\n\\]\n\nThe Neumann condition at \\(x = 0\\) is naturally satisfied. The Dirichlet condition \\(T(L) = T_L\\) is imposed directly on the final equation.\n\n\n\nAnalytical Reference Solution\nFor constant \\(k\\) and \\(q\\), the exact solution is:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2),\n\\]\nwhich provides a useful reference for numerical verification."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "Motivation for Reduced-Order Modeling",
    "text": "Motivation for Reduced-Order Modeling\nWhen evaluating \\(\\mathbf{T}\\) for multiple parameter pairs \\((\\mu, \\beta)\\), solving the full system \\(\\mathbf{K} \\mathbf{T} = \\mathbf{F}\\) repeatedly becomes computationally expensive. This challenge arises in applications such as parameter studies, optimization loops, or real-time simulation.\nReduced-order modeling (ROM) mitigates this cost by projecting the full system onto a lower-dimensional subspace, enabling rapid evaluation with minimal accuracy loss. The approach involves:\n\nAn offline phase where representative solutions (“snapshots”) are collected and used to construct a low-dimensional basis,\nAn online phase where the system is solved in the reduced space, avoiding expensive computations at full resolution.\n\nIn problems with affine parameter dependence, the ROM can be formulated such that no linear solves are required in the online stage, making it suitable for many-query scenarios."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "href": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "title": "SCIKIT-ROM",
    "section": "Affine Reduced-Order Modeling (ROM)",
    "text": "Affine Reduced-Order Modeling (ROM)\nWe approximate the full-order solution using a reduced affine expansion:\n\\[\n\\mathbf{T} \\approx \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a},\n\\]\nwhere:\n\n\\(\\mathbf{T}_{\\text{mean}} \\in \\mathbb{R}^N\\) is the mean of collected snapshots,\n\\(\\mathbf{U} \\in \\mathbb{R}^{N \\times r}\\) is the reduced basis (e.g., from POD),\n\\(\\mathbf{a} \\in \\mathbb{R}^r\\) are reduced coordinates.\n\nSubstituting into the system and applying Galerkin projection:\n\\[\n\\mathbf{K} (\\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}) = \\mathbf{f}\n\\;\\Rightarrow\\;\n\\mathbf{U}^\\top \\mathbf{K} \\mathbf{U} \\mathbf{a} = \\mathbf{U}^\\top(\\mathbf{f} - \\mathbf{K} \\mathbf{T}_{\\text{mean}}).\n\\]\nDefine:\n\nReduced stiffness: \\(\\mathbf{K}_r = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{U}\\),\nReduced source: \\(\\mathbf{b} = \\mathbf{U}^\\top \\mathbf{f}\\),\nProjected offset: \\(\\mathbf{g} = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{T}_{\\text{mean}}\\).\n\nThen:\n\\[\n\\mathbf{a} = \\mathbf{K}_r^{-1}(\\mathbf{b} - \\mathbf{g}),\n\\qquad\n\\hat{\\mathbf{T}} = \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}.\n\\]"
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "href": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "title": "SCIKIT-ROM",
    "section": "Efficient Online Evaluation for Affine Parametric Systems",
    "text": "Efficient Online Evaluation for Affine Parametric Systems\nAssume the system admits the following affine form:\n\\[\n\\mathbf{K}(\\mu) = \\mu\\, \\mathbf{K}_1,\n\\quad\n\\mathbf{f}(\\beta) = \\beta\\, \\mathbf{f}_1.\n\\]\nThen, in the offline phase, precompute:\nIn the online phase, for any \\((\\mu, \\beta)\\):\n\\[\n\\boxed{\n\\hat{\\mathbf{T}}(\\mu, \\beta)\n= \\mathbf{T}_{\\text{mean}}\n+ \\mathbf{U} \\left( \\frac{\\beta}{\\mu} \\mathbf{a}_1 - \\mathbf{c}_1 \\right)\n}\n\\]\nThis avoids matrix assembly and linear solves during inference, resulting in fast and scalable evaluation. Below we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  }
]