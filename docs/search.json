[
  {
    "objectID": "twisting.html#problem-setup",
    "href": "twisting.html#problem-setup",
    "title": "P.2 Twisting of a Neo-Hookean Block",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.2 Twisting of a Neo-Hookean Block"
    ]
  },
  {
    "objectID": "Resources/intro/rom_intro.html",
    "href": "Resources/intro/rom_intro.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "scikit-rom\nscikit-rom is a lightweight, Python-based platform designed for projection-based model reduction of finite element models with moderate to large problem sizes (up to approximately 600,000 degrees of freedom). Built on top of scikit-fem, an easy-to-use finite element assembly library, this repository demonstrates reduced-order modeling (ROM) techniques for a range of linear and nonlinear problems, including time-dependent ones. Current examples primarily focus on thermal and mechanical systems, with extensions to fluid dynamics planned for future releases.\nBeyond its application to real-world finite element problems, the library also serves as a valuable testing ground for new model reduction algorithms and as a tutorial resource for those new to the field.\n\n\n\nWhat is Reduced-Order Modeling?\nReduced-order modeling (ROM) is a computational strategy for approximating high-fidelity numerical models with significantly reduced computational cost. Instead of solving large-scale systems—often with millions of unknowns—ROM techniques construct low-dimensional surrogates that retain the dominant physics of the system, enabling efficient and repeated evaluations.\nThe underlying principle is that many physical systems exhibit behavior that can be captured by a small number of dominant modes, despite their discretization on fine spatial meshes. Techniques such as Proper Orthogonal Decomposition (POD) extract these modes from full-order simulations, enabling the construction of reduced models that are both accurate and computationally efficient.\n\n\n\nOffline–Online Decomposition\nscikit-rom implements the classical offline–online decomposition paradigm:\n\nOffline Phase (computationally intensive, performed once):\n\nSampling of the parameter space\nGeneration of full-order solution snapshots\nComputation of the reduced basis via singular value decomposition (SVD)\nAssembly of parameter-independent reduced operators\n\nOnline Phase (efficient, performed repeatedly):\n\nEvaluation of the system response for new parameter values using preassembled reduced operators\nSpeedups on the order of 10–500× relative to full-order models are typical"
  },
  {
    "objectID": "reference/utils.visualization.html",
    "href": "reference/utils.visualization.html",
    "title": "utils.visualization",
    "section": "",
    "text": "utils.visualization"
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html",
    "href": "reference/utils.visualization.generate_vtu.html",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "utils.visualization.generate_vtu\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html#functions",
    "href": "reference/utils.visualization.generate_vtu.html#functions",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html",
    "href": "reference/utils.visualization.color_palette.html",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "utils.visualization.color_palette\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html#functions",
    "href": "reference/utils.visualization.color_palette.html#functions",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.rom_error_est.html",
    "href": "reference/utils.rom_error_est.html",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "utils.rom_error_est\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.rom_error_est.html#functions",
    "href": "reference/utils.rom_error_est.html#functions",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone"
  },
  {
    "objectID": "reference/utils.reduced_basis.html",
    "href": "reference/utils.reduced_basis.html",
    "title": "utils.reduced_basis",
    "section": "",
    "text": "utils.reduced_basis"
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html",
    "href": "reference/utils.newton_solver_rom.html",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "utils.newton_solver_rom\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html#functions",
    "href": "reference/utils.newton_solver_rom.html#functions",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit."
  },
  {
    "objectID": "reference/utils.imports.html",
    "href": "reference/utils.imports.html",
    "title": "utils.imports",
    "section": "",
    "text": "utils.imports\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework: – Core imports for OS, filesystem, timing, and randomness – Numerical & symbolic computing: NumPy, SciPy (dense & sparse), Sympy – Finite‐element tools: scikit‐fem (from skfem import *), mesh I/O via meshio – Linear algebra solvers: dense (LU), sparse (splu, spilu, CG), and multigrid (pyamg) – Sampling & design‐of‐experiments: Sobol, Latin Hypercube (SciPy QMC & pyDOE) – Plotting & visualization: Matplotlib (2D/3D, custom styles), ptitprince, and optional animation modules\n– Utilities for dynamic imports, path handling, and Cartesian products These imports and utilities ensure consistent, ready‐to‐use functionality across the entire reduced‐order modeling pipeline.",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.imports"
    ]
  },
  {
    "objectID": "reference/utils.errors.html",
    "href": "reference/utils.errors.html",
    "title": "utils.errors",
    "section": "",
    "text": "utils.errors\nutils.errors"
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html",
    "href": "reference/utils.dynamics.integrators.html",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "utils.dynamics.integrators\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n[Code: Suparno Bhattacharyya]\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.dynamics.integrators.html#functions",
    "href": "reference/utils.dynamics.integrators.html#functions",
    "title": "utils.dynamics.integrators",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\nwbz_alpha\nWood-Bossak-Zienkiewicz (WBZ-α) method.\n\n\n\n\n\nutils.dynamics.integrators.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i].\n[Code: Suparno Bhattacharyya]\n\n\n\nutils.dynamics.integrators.wbz_alpha(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    gamma=0.5,\n    beta=0.25,\n    alpha_m=0.0,\n)\nWood-Bossak-Zienkiewicz (WBZ-α) method. Extension of Newmark method with algorithmic damping parameter alpha_m. alpha_m: numerical damping parameter (0 ≤ alpha_m ≤ 1)",
    "crumbs": [
      "**Documentation**",
      "Dynamics",
      "utils.dynamics.integrators"
    ]
  },
  {
    "objectID": "reference/utils.basis.pod.html",
    "href": "reference/utils.basis.pod.html",
    "title": "utils.basis.pod",
    "section": "",
    "text": "utils.basis.pod\nutils.basis.pod"
  },
  {
    "objectID": "reference/templates.problem_template.properties.html",
    "href": "reference/templates.problem_template.properties.html",
    "title": "templates.problem_template.properties",
    "section": "",
    "text": "templates.problem_template.properties\n\n\n\n\n\nName\nDescription\n\n\n\n\nproperty_fn\nTemplate for a material or source property function.\n\n\n\n\n\ntemplates.problem_template.properties.property_fn(param)\nTemplate for a material or source property function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparam\nfloat\nUser-defined parameter controlling the property.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nComputed property value.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.properties"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.properties.html#functions",
    "href": "reference/templates.problem_template.properties.html#functions",
    "title": "templates.problem_template.properties",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nproperty_fn\nTemplate for a material or source property function.\n\n\n\n\n\ntemplates.problem_template.properties.property_fn(param)\nTemplate for a material or source property function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparam\nfloat\nUser-defined parameter controlling the property.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nComputed property value.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.properties"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.params.html",
    "href": "reference/templates.problem_template.params.html",
    "title": "templates.problem_template.params",
    "section": "",
    "text": "templates.problem_template.params\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameters\nTemplate for generating training/testing parameter samples.\n\n\n\n\n\ntemplates.problem_template.params.parameters(N_snap)\nTemplate for generating training/testing parameter samples.\nUses generate_sobol from skrom.rom.rom_utils to sample uniformly over each interval in param_ranges.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of samples per set.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nparams\n(ndarray, shape(2 * N_snap, D))\nStacked [training; testing] samples.\n\n\nparam_ranges\nlist of tuple\n[(p1_min, p1_max), …, (pD_min, pD_max)] for each parameter.\n\n\ntrain_mask\nndarray of bool\nTrue for the first N_snap entries of params.\n\n\ntest_mask\nndarray of bool\nTrue for the remaining entries.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.params"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.params.html#functions",
    "href": "reference/templates.problem_template.params.html#functions",
    "title": "templates.problem_template.params",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nparameters\nTemplate for generating training/testing parameter samples.\n\n\n\n\n\ntemplates.problem_template.params.parameters(N_snap)\nTemplate for generating training/testing parameter samples.\nUses generate_sobol from skrom.rom.rom_utils to sample uniformly over each interval in param_ranges.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of samples per set.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nparams\n(ndarray, shape(2 * N_snap, D))\nStacked [training; testing] samples.\n\n\nparam_ranges\nlist of tuple\n[(p1_min, p1_max), …, (pD_min, pD_max)] for each parameter.\n\n\ntrain_mask\nndarray of bool\nTrue for the first N_snap entries of params.\n\n\ntest_mask\nndarray of bool\nTrue for the remaining entries.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.params"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.domain.html",
    "href": "reference/templates.problem_template.domain.html",
    "title": "templates.problem_template.domain",
    "section": "",
    "text": "templates.problem_template.domain\n\n\n\n\n\nName\nDescription\n\n\n\n\ndomain_\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\ntemplates.problem_template.domain.domain_(**kwargs)\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\nAny problem-specific parameters needed for mesh generation, basis construction, and boundary identification.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{ ‘mesh’: , ‘basis’: , ‘free_dofs’: , ‘dirichlet_dofs’: , ‘dirichlet_value’: , # add other entries as needed }",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.domain"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.domain.html#functions",
    "href": "reference/templates.problem_template.domain.html#functions",
    "title": "templates.problem_template.domain",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndomain_\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\ntemplates.problem_template.domain.domain_(**kwargs)\nTemplate for setting up the computational domain and boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\ndict\nAny problem-specific parameters needed for mesh generation, basis construction, and boundary identification.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{ ‘mesh’: , ‘basis’: , ‘free_dofs’: , ‘dirichlet_dofs’: , ‘dirichlet_value’: , # add other entries as needed }",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.domain"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html",
    "href": "reference/rom.rom_utils.html",
    "title": "rom.rom_utils",
    "section": "",
    "text": "rom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O, and Newton solvers in reduced‐order modeling (ROM) workflows.\nThis module provides:\n\nSnapshot train/test splitting routines:\n\ntrain_test_split, latin_hypercube_train_test_split, sobol_train_test_split\n\nSample generators:\n\ngenerate_sobol, generate_lhs, generate_gaussian_samples\n\nBasis management:\n\nupdate_basis – deflation and augmentation of reduced bases\n\nSolution reconstruction:\n\nreconstruct_solution – expand reduced vectors back to full order\n\nROM data persistence:\n\nrom_data_gen, load_rom_data\n\nNewton solvers for ROM systems:\n\nnewton_hyper_rom_solver, newton_solver_rom\n\n\nTogether, these functions support data preparation, sampling design, basis enrichment, I/O, and nonlinear solves in full‐to‐reduced‐order pipelines.\n[Authors: Suparno Bhattacharyya, Ali Hamza Abidi Syed]\n\n\n\n\n\nName\nDescription\n\n\n\n\ncollect_residuals\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\n\n\ncompute_nonlinear_snapshots\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve nonlinear reduced-order system using Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nselect_elements_and_gauss_weights\nSelect elements and corresponding weights from Gauss points, ensuring consistency\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n)\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\nThis function processes training snapshots to collect residual evaluations that will be used for hyperreduction (reducing computational cost of nonlinear ROM terms).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfos_solutions\nndarray\nFull order solutions (not directly used but maintained for interface consistency)\nrequired\n\n\nNLS_train_ms\n(ndarray, shape(n_snapshots, n_dofs))\nMean-subtracted training snapshots (temperature fluctuations from mean)\nrequired\n\n\nNLS_train_mean\n(ndarray, shape(n_dofs))\nMean temperature field across all training snapshots\nrequired\n\n\nV_sel\n(ndarray, shape(n_dofs, n_modes))\nSelected POD basis matrix (reduced basis vectors)\nrequired\n\n\nreconstruct_solution\ncallable\nFunction to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean)\nrequired\n\n\nResidual\nLinearFormROM object\nROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nq_mus\n(ndarray, shape(n_snapshots, n_residual_components))\nCollected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter\n\n\n\n\n\n\n\nrom.rom_utils.compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n)\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnon_linear_func\n\nA function with signature non_linear_func(u=, param=) → array.\nrequired\n\n\nfos_solutions\n\nSequence of full-order solutions (each an ndarray).\nrequired\n\n\nparam_list\n\nSequence of parameter values, same length as fos_solutions.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_nl\nndarray\nArray of shape (n_snapshots, …) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]).\n\n\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.03,\n    maxit=200,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.03\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n200\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    alpha=1.0,\n    tol=0.001,\n    maxit=100,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve nonlinear reduced-order system using Newton’s method.\nProvides two solution strategies: efficient LU refactorization for ROM systems or direct solving with adaptive step damping.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction that assembles Jacobian and residual: (J, R) = func(u_rom, …)\nrequired\n\n\nu_rom\narray - like\nInitial guess for reduced-order state vector\nrequired\n\n\n*args\ntuple\nAdditional positional arguments passed to assemble_func\n()\n\n\nalpha\nfloat\nStep size damping factor (only used when use_lu=False)\n1.0\n\n\ntol\nfloat\nConvergence tolerance on Newton step norm\n1e-3\n\n\nmaxit\nint\nMaximum number of Newton iterations\n100\n\n\nuse_lu\nbool\nIf True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction.\nFalse\n\n\njac_tol\nfloat\nRelative tolerance for Jacobian reuse (only used when use_lu=True)\n1e-1\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to assemble_func\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\narray - like\nConverged reduced-order state vector u_rom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf Newton iteration fails to converge within maxit iterations (only when use_lu=True)\n\n\n\n\n\n\n\nLU mode: Reuses Jacobian factorization until relative change exceeds jac_tol\nDirect mode: Applies adaptive damping every 40 iterations, includes logging\nPart of ROM workflow for efficient nonlinear system solving\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.select_elements_and_gauss_weights(\n    n_gauss_points,\n    element_indices,\n    weights,\n)\nSelect elements and corresponding weights from Gauss points, ensuring consistency by including all Gauss points for each selected element with zero weights for unselected points.\nParameters: n_gauss_points (int): Number of Gauss points per element. element_indices (list or array): Selected Gauss point indices from ECM. weights (list or array): Corresponding weights for selected indices.\nReturns: dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points. For each selected element, the list will have exactly n_gauss_points entries.\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html#functions",
    "href": "reference/rom.rom_utils.html#functions",
    "title": "rom.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncollect_residuals\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\n\n\ncompute_nonlinear_snapshots\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve nonlinear reduced-order system using Newton’s method.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nselect_elements_and_gauss_weights\nSelect elements and corresponding weights from Gauss points, ensuring consistency\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.collect_residuals(\n    NLS_train_ms,\n    NLS_train_mean,\n    V_sel,\n    reconstruct_solution,\n    Residual,\n    training_params,\n    assemble_kwargs,\n    extra_kwargs=None,\n)\nCollect reduced evaluations of the ROM residual functional for hyperreduction.\nThis function processes training snapshots to collect residual evaluations that will be used for hyperreduction (reducing computational cost of nonlinear ROM terms).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfos_solutions\nndarray\nFull order solutions (not directly used but maintained for interface consistency)\nrequired\n\n\nNLS_train_ms\n(ndarray, shape(n_snapshots, n_dofs))\nMean-subtracted training snapshots (temperature fluctuations from mean)\nrequired\n\n\nNLS_train_mean\n(ndarray, shape(n_dofs))\nMean temperature field across all training snapshots\nrequired\n\n\nV_sel\n(ndarray, shape(n_dofs, n_modes))\nSelected POD basis matrix (reduced basis vectors)\nrequired\n\n\nreconstruct_solution\ncallable\nFunction to reconstruct full-order solution from ROM coefficients Signature: u_full = reconstruct_solution(u_reduced, V_sel, u_mean)\nrequired\n\n\nResidual\nLinearFormROM object\nROM residual operator with hyperreduction capability Must have method: hyperreduction(prev=solution, k_param=k, q_param=q)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nq_mus\n(ndarray, shape(n_snapshots, n_residual_components))\nCollected residual evaluations for all training snapshots Each row contains the projected residual evaluation for a single parameter\n\n\n\n\n\n\n\nrom.rom_utils.compute_nonlinear_snapshots(\n    non_linear_func,\n    fos_solutions,\n    param_list,\n)\nEvaluate a nonlinear RHS function over a set of FOM snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnon_linear_func\n\nA function with signature non_linear_func(u=, param=) → array.\nrequired\n\n\nfos_solutions\n\nSequence of full-order solutions (each an ndarray).\nrequired\n\n\nparam_list\n\nSequence of parameter values, same length as fos_solutions.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_nl\nndarray\nArray of shape (n_snapshots, …) where each slice F_nl[i] is non_linear_func(u=fos_solutions[i], param=param_list[i]).\n\n\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    assemble_func,\n    u,\n    tol=0.03,\n    maxit=200,\n    param=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.03\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n200\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    alpha=1.0,\n    tol=0.001,\n    maxit=100,\n    use_lu=False,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve nonlinear reduced-order system using Newton’s method.\nProvides two solution strategies: efficient LU refactorization for ROM systems or direct solving with adaptive step damping.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction that assembles Jacobian and residual: (J, R) = func(u_rom, …)\nrequired\n\n\nu_rom\narray - like\nInitial guess for reduced-order state vector\nrequired\n\n\n*args\ntuple\nAdditional positional arguments passed to assemble_func\n()\n\n\nalpha\nfloat\nStep size damping factor (only used when use_lu=False)\n1.0\n\n\ntol\nfloat\nConvergence tolerance on Newton step norm\n1e-3\n\n\nmaxit\nint\nMaximum number of Newton iterations\n100\n\n\nuse_lu\nbool\nIf True, use LU factorization with Jacobian reuse for efficiency. If False, use direct solve with step damping and full reconstruction.\nFalse\n\n\njac_tol\nfloat\nRelative tolerance for Jacobian reuse (only used when use_lu=True)\n1e-1\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to assemble_func\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\narray - like\nConverged reduced-order state vector u_rom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf Newton iteration fails to converge within maxit iterations (only when use_lu=True)\n\n\n\n\n\n\n\nLU mode: Reuses Jacobian factorization until relative change exceeds jac_tol\nDirect mode: Applies adaptive damping every 40 iterations, includes logging\nPart of ROM workflow for efficient nonlinear system solving\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.select_elements_and_gauss_weights(\n    n_gauss_points,\n    element_indices,\n    weights,\n)\nSelect elements and corresponding weights from Gauss points, ensuring consistency by including all Gauss points for each selected element with zero weights for unselected points.\nParameters: n_gauss_points (int): Number of Gauss points per element. element_indices (list or array): Selected Gauss point indices from ECM. weights (list or array): Corresponding weights for selected indices.\nReturns: dict: Mapping from each selected element to a list of weights, with zeros for unselected Gauss points. For each selected element, the list will have exactly n_gauss_points entries.\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.html",
    "href": "reference/rom.html",
    "title": "rom",
    "section": "",
    "text": "rom\nThe rom folder provides core reduced‐order modeling tools:\n– Projection & assembly classes (BilinearFormROM, LinearFormROM): • Project full‐order stiffness and load contributions onto reduced bases • Handle Dirichlet boundary conditions via free‐DOF mappings • Support chunked/clustered assembly for memory‐efficient reduced operators\n– Error evaluation & visualization (error_utils.py): • Compute time‐dependent and global error metrics (L2, RMSE, R², energy‐norm, etc.) • Generate scatter plots, spatial snapshots, raincloud plots, and tabular reports\n– ROM utilities (utils.py): • Snapshot splitting and sampling (random, Latin‐Hypercube, Sobol, Gaussian) • Basis enrichment via deflation and QR re‐orthonormalization • Solution reconstruction from reduced coefficients • Data I/O for ROM simulations (rom_data_gen, load_rom_data) • Newton solvers for (hyper‐)reduced systems"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html",
    "href": "reference/rom.linear_form_hyperrom.html",
    "title": "rom.linear_form_hyperrom",
    "section": "",
    "text": "rom.linear_form_hyperrom"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.linear_form_hyperrom",
    "section": "hyperreduce/linear_form_hyperrom.py",
    "text": "hyperreduce/linear_form_hyperrom.py\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/rom.linear_form_hyperrom.html#classes",
    "href": "reference/rom.linear_form_hyperrom.html#classes",
    "title": "rom.linear_form_hyperrom",
    "section": "Classes",
    "text": "Classes\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\nLinearFormHYPERROM\nrom.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\nassemble_weighted\nrom.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(**kwargs)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\nextract_element_vector\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\nextract_element_vector_rom\nrom.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.linear_form_hyperrom_ecsw\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_ecsw\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#hyperreducelinear_form_hyperrom.py",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.linear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.linear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_ecsw\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nrom.ecsw.linear_form_hyperrom_ecsw.LinearFormHYPERROM_ecsw.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.linear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html",
    "href": "reference/rom.ecsw.custom_nnls.html",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "rom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n[Original C++ code: libROM team at LLNL, Python adaptation: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.custom_nnls.html#classes",
    "href": "reference/rom.ecsw.custom_nnls.html#classes",
    "title": "rom.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nrom.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.linear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element linear forms.\nThis module implements hyperreduction of linear forms using the Discrete Empirical Interpolation Method (DEIM) combined with element sampling for efficient load vector assembly. It provides dramatic computational speedups by: - Assembling only a subset of finite elements based on DEIM selection - Using efficient vector assembly techniques for sparse operations - Reconstructing full load vectors via DEIM interpolation matrices - Supporting parallel element vector extraction when available\nTL;DR: Enables speedup in linear form assembly for ROMs by evaluating only essential elements and reconstructing the full load vector through intelligent interpolation.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\nTL;DR: Dramatically accelerates linear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time ROM applications with parameter-dependent forcing terms.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in linear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled for load vector construction, dramatically reducing the active element count.\nSparse Assembly: Assembles only the selected elements using efficient vector assembly techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order load vector using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order load vector onto the reduced test basis to produce the final reduced-order linear form.\n\nThis hyperreduction is particularly effective for problems where: - Load distributions are spatially localized or have low-rank structure - Real-time simulation speed is critical for control applications - Parameter-dependent forcing terms exhibit smooth variation - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time ROM evaluation with parameter-dependent loads.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function to be hyperreduced. Should accept test basis functions and return element-wise load contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection analysis.\nrequired\n\n\nubasis\nBasis\nTest basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix that projects full-order load vectors to the r-dimensional reduced test space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order load vectors from sampled values: F_reduced = deim_mat @ F_sampled[sampled_rows]\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean load vector for centering. Required if load data was mean-subtracted during DEIM basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element vector extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\nndarray of shape (n_free, r)\nCopy of the left (test) reduced basis matrix for load vector projection.\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements for assembly.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis\nBasis\nOriginal full-order finite element basis reference.\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for load vector reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows\nndarray of shape (n_active_elements * n_local_dofs,)\nFlattened element-DOF indices for efficient vector assembly operations.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced load vector using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse load vector over hyperreduced element set.\n\n\nextract_element_vector_rom\nExtract element load vectors for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced load vector using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order load vector.\nThis method orchestrates the complete hyperreduction assembly process:\n\nParameter Setup: Combines default finite element parameters with user-provided kwargs for element-level load evaluation.\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order load vector using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse vector, providing the minimal information needed for reconstruction.\nVector Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order load vector from the sampled values.\n\nThe mathematical operation performed is: F_reduced = deim_mat @ F_sampled[sampled_rows]\nwhere F_sampled is the sparse load vector assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control, such as material parameters or time-dependent loading conditions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_reduced\nndarray of shape (r,)\nReduced-order load vector ready for use in ROM systems. This is the hyperreduced approximation of the full-order load projected onto the reduced test basis.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse load vector over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element load vectors only from selected elements and building the global sparse load vector using optimized scatter-add operations.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction for load vectors:\n\nElement Vector Extraction: Calls extract_element_vector_rom() to compute local load contributions for selected elements only, avoiding expensive integration over the entire domain.\nData Preparation: Flattens the element load vectors into a 1D array matching the connectivity pattern for efficient assembly.\nScatter-Add Assembly: Uses NumPy’s add.at function to efficiently accumulate element contributions at their global DOF locations, handling overlapping contributions correctly.\n\nThe assembly process preserves the mathematical structure of the full-order load vector while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_vector_rom for controlling element-level assembly behavior, such as load magnitude parameters or spatial distribution functions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf\nndarray of shape (n_dofs,)\nSparse global load vector assembled over the hyperreduced element set. Only selected elements contribute to this vector, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element load vectors for hyperreduced mesh assembly.\nTL;DR: Computes local element load vectors for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global load vector assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global linear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the linear form: F_e[i] = ∫_Ω_e φ_i(x) * form(x) dx\nwhere φ_i are test basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nFinite element basis for test functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the linear form evaluation, such as load magnitude parameters, time-dependent coefficients, or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\nndarray of shape (n_elements, n_local_dofs)\nArray of local element load vectors. Each element_vectors[e] contains the n_local_dofs-length load vector for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no valid basis is provided for the load vector extraction.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.linear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.linear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM_deim\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    sampled_rows,\n    deim_mat,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced linear form for efficient ROM load vector assembly.\nTL;DR: Dramatically accelerates linear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time ROM applications with parameter-dependent forcing terms.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in linear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled for load vector construction, dramatically reducing the active element count.\nSparse Assembly: Assembles only the selected elements using efficient vector assembly techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order load vector using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order load vector onto the reduced test basis to produce the final reduced-order linear form.\n\nThis hyperreduction is particularly effective for problems where: - Load distributions are spatially localized or have low-rank structure - Real-time simulation speed is critical for control applications - Parameter-dependent forcing terms exhibit smooth variation - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time ROM evaluation with parameter-dependent loads.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function to be hyperreduced. Should accept test basis functions and return element-wise load contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection analysis.\nrequired\n\n\nubasis\nBasis\nTest basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix that projects full-order load vectors to the r-dimensional reduced test space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order load vectors from sampled values: F_reduced = deim_mat @ F_sampled[sampled_rows]\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean load vector for centering. Required if load data was mean-subtracted during DEIM basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element vector extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\nndarray of shape (n_free, r)\nCopy of the left (test) reduced basis matrix for load vector projection.\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements for assembly.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis\nBasis\nOriginal full-order finite element basis reference.\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for load vector reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows\nndarray of shape (n_active_elements * n_local_dofs,)\nFlattened element-DOF indices for efficient vector assembly operations.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced load vector using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse load vector over hyperreduced element set.\n\n\nextract_element_vector_rom\nExtract element load vectors for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced load vector using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order load vector.\nThis method orchestrates the complete hyperreduction assembly process:\n\nParameter Setup: Combines default finite element parameters with user-provided kwargs for element-level load evaluation.\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order load vector using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse vector, providing the minimal information needed for reconstruction.\nVector Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order load vector from the sampled values.\n\nThe mathematical operation performed is: F_reduced = deim_mat @ F_sampled[sampled_rows]\nwhere F_sampled is the sparse load vector assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control, such as material parameters or time-dependent loading conditions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nF_reduced\nndarray of shape (r,)\nReduced-order load vector ready for use in ROM systems. This is the hyperreduced approximation of the full-order load projected onto the reduced test basis.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse load vector over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element load vectors only from selected elements and building the global sparse load vector using optimized scatter-add operations.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction for load vectors:\n\nElement Vector Extraction: Calls extract_element_vector_rom() to compute local load contributions for selected elements only, avoiding expensive integration over the entire domain.\nData Preparation: Flattens the element load vectors into a 1D array matching the connectivity pattern for efficient assembly.\nScatter-Add Assembly: Uses NumPy’s add.at function to efficiently accumulate element contributions at their global DOF locations, handling overlapping contributions correctly.\n\nThe assembly process preserves the mathematical structure of the full-order load vector while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_vector_rom for controlling element-level assembly behavior, such as load magnitude parameters or spatial distribution functions.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf\nndarray of shape (n_dofs,)\nSparse global load vector assembled over the hyperreduced element set. Only selected elements contribute to this vector, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.linear_form_hyperrom_deim.LinearFormHYPERROM_deim.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element load vectors for hyperreduced mesh assembly.\nTL;DR: Computes local element load vectors for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global load vector assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global linear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the linear form: F_e[i] = ∫_Ω_e φ_i(x) * form(x) dx\nwhere φ_i are test basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nFinite element basis for test functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the linear form evaluation, such as load magnitude parameters, time-dependent coefficients, or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\nndarray of shape (n_elements, n_local_dofs)\nArray of local element load vectors. Each element_vectors[e] contains the n_local_dofs-length load vector for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no valid basis is provided for the load vector extraction.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.linear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.bilinear_form_hyperrom_deim.html",
    "href": "reference/rom.deim.bilinear_form_hyperrom_deim.html",
    "title": "rom.deim.bilinear_form_hyperrom_deim",
    "section": "",
    "text": "rom.deim.bilinear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element bilinear forms.\nThis module implements hyperreduction of bilinear forms using the Discrete Empirical Interpolation Method (DEIM) combined with element sampling. It provides dramatic computational speedups by: - Assembling only a subset of finite elements based on DEIM selection - Using sparse matrix techniques for efficient memory usage - Reconstructing full operators via DEIM interpolation matrices - Supporting parallel element matrix extraction when available\nTL;DR: Enables ~100-1000x speedup in bilinear form assembly for ROMs by evaluating only essential elements and reconstructing the full operator through intelligent interpolation.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_deim\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    sampled_rows,\n    deim_mat,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time nonlinear ROM applications.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in bilinear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled, dramatically reducing the active element count from thousands to tens.\nSparse Assembly: Assembles only the selected elements using efficient sparse matrix techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order operator using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order matrix onto the reduced basis to produce the final reduced-order bilinear form.\n\nThis hyperreduction is particularly effective for problems where: - Nonlinear effects are spatially localized - Real-time simulation speed is critical - The parameter-dependent operators have low-rank structure - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time nonlinear ROM evaluation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept basis functions and return element-wise contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection.\nrequired\n\n\nubasis\nBasis\nTrial/test basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix. Currently unused in this implementation but maintained for interface compatibility.\nrequired\n\n\nrob\nndarray of shape (n_free, r)\nRight (trial) reduced basis matrix that projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order operators from sampled values: A_reduced = deim_mat @ A_sampled[sampled_rows] @ rob\nrequired\n\n\nvbasis\nBasis\nTest function basis. If None, defaults to ubasis for Galerkin methods.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean solution snapshot for centering. Required if snapshot data was mean-subtracted during basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for operator reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_elems\nint\nNumber of active elements in the hyperreduced mesh.\n\n\nn_loc\nint\nNumber of local degrees of freedom per element.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows, cols\nndarray\nBroadcasted row and column indices for sparse matrix assembly.\n\n\nrow_flat, col_flat\nndarray\nFlattened index arrays for efficient COO matrix construction.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse matrix over hyperreduced element set.\n\n\nextract_element_matrices_rom\nExtract element matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order operator matrix.\nThis method orchestrates the complete hyperreduction assembly process:\n\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order matrix using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse matrix, providing the minimal information needed for reconstruction.\nOperator Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order operator from the sampled values.\nBasis Projection: Projects the reconstructed operator onto the reduced trial basis to produce the final r×r reduced-order matrix.\n\nThe mathematical operation performed is: A_reduced = deim_mat @ A_sampled[sampled_rows, :] @ rob\nwhere A_sampled is the sparse matrix assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nA_reduced\nndarray of shape (r, r)\nReduced-order bilinear form matrix ready for use in ROM systems. This is the hyperreduced approximation of the full-order operator projected onto the reduced basis.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse matrix over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element matrices only from selected elements and building the global sparse matrix using optimized COO format construction.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction:\n\nElement Matrix Extraction: Calls extract_element_matrices_rom() to compute local stiffness matrices for selected elements only, avoiding expensive integration over the entire domain.\nSparse Data Preparation: Flattens the element matrices and corresponding row/column indices into triplet format (I, J, V) suitable for sparse matrix construction.\nZero Filtering: Optionally removes zero entries to minimize memory usage and improve sparse matrix performance.\nCOO Construction: Builds the sparse matrix using coordinate (COO) format and converts to compressed sparse row (CSR) for efficient subsequent operations.\n\nThe assembly process preserves the mathematical structure of the full-order operator while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_matrices_rom for controlling element-level assembly behavior.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK\nscipy.sparse.csr_matrix of shape (n_dofs, n_dofs)\nSparse global stiffness matrix assembled over the hyperreduced element set. Only selected elements contribute to this matrix, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nFinite element basis for trial functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nFinite element basis for test functions. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.bilinear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.bilinear_form_hyperrom_deim.html#classes",
    "href": "reference/rom.deim.bilinear_form_hyperrom_deim.html#classes",
    "title": "rom.deim.bilinear_form_hyperrom_deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_deim\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    sampled_rows,\n    deim_mat,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nDEIM-based hyperreduced bilinear form for efficient ROM assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through strategic element sampling and DEIM interpolation, essential for real-time nonlinear ROM applications.\nThis class implements a hyperreduction strategy that combines element sampling with the Discrete Empirical Interpolation Method (DEIM) to achieve massive computational savings in bilinear form assembly. The approach works by:\n\nElement Selection: Uses DEIM-selected degrees of freedom to identify which finite elements must be assembled, dramatically reducing the active element count from thousands to tens.\nSparse Assembly: Assembles only the selected elements using efficient sparse matrix techniques, avoiding computation over the entire domain.\nDEIM Reconstruction: Reconstructs the full reduced-order operator using the DEIM interpolation matrix, enabling accurate approximation from limited assembly data.\nBasis Projection: Projects the sampled full-order matrix onto the reduced basis to produce the final reduced-order bilinear form.\n\nThis hyperreduction is particularly effective for problems where: - Nonlinear effects are spatially localized - Real-time simulation speed is critical - The parameter-dependent operators have low-rank structure - Computational resources are severely constrained\nThe method transforms assembly complexity from O(n_elements) to O(n_selected) where n_selected &lt;&lt; n_elements, enabling real-time nonlinear ROM evaluation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept basis functions and return element-wise contributions.\nrequired\n\n\nelem_weight\narray_like of shape (n_elements,)\nElement weight vector where 1 indicates selected elements and 0 indicates elements to skip. Typically derived from DEIM DOF selection.\nrequired\n\n\nubasis\nBasis\nTrial/test basis functions for the full-order finite element space. Contains mesh connectivity and quadrature information.\nrequired\n\n\nlob\nndarray of shape (n_free, r)\nLeft (test) reduced basis matrix. Currently unused in this implementation but maintained for interface compatibility.\nrequired\n\n\nrob\nndarray of shape (n_free, r)\nRight (trial) reduced basis matrix that projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nsampled_rows\narray_like of int, shape (n_samp,)\nGlobal DOF indices selected by DEIM for interpolation. These are the only rows where full assembly information is retained.\nrequired\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM interpolation matrix that reconstructs full reduced-order operators from sampled values: A_reduced = deim_mat @ A_sampled[sampled_rows] @ rob\nrequired\n\n\nvbasis\nBasis\nTest function basis. If None, defaults to ubasis for Galerkin methods.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of unconstrained degrees of freedom. Used for boundary condition handling in the full-order system.\nNone\n\n\nmean\nndarray\nMean solution snapshot for centering. Required if snapshot data was mean-subtracted during basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable parallel assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nweight\nndarray of shape (n_elements,)\nCopy of element weight vector indicating active elements.\n\n\nnonzero_elements\nndarray of int\nIndices of elements with nonzero weights (selected for assembly).\n\n\nubasis_rom\nBasis\nFinite element basis restricted to the hyperreduced mesh containing only selected elements.\n\n\nsampled_rows\nndarray of int, shape (n_samp,)\nGlobal DOF indices where DEIM interpolation is performed.\n\n\nn_samp\nint\nNumber of DEIM sampling points (length of sampled_rows).\n\n\ndeim_mat\nndarray of shape (r, n_samp)\nDEIM projection matrix for operator reconstruction.\n\n\nedofs\nndarray of shape (n_active_elements, n_local_dofs)\nElement-to-DOF connectivity mapping for the reduced mesh.\n\n\nn_elems\nint\nNumber of active elements in the hyperreduced mesh.\n\n\nn_loc\nint\nNumber of local degrees of freedom per element.\n\n\nn_dofs\nint\nTotal number of global DOFs in the restricted mesh.\n\n\nrows, cols\nndarray\nBroadcasted row and column indices for sparse matrix assembly.\n\n\nrow_flat, col_flat\nndarray\nFlattened index arrays for efficient COO matrix construction.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_deim\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\n\n\ndeim_elem_assembly\nAssemble sparse matrix over hyperreduced element set.\n\n\nextract_element_matrices_rom\nExtract element matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.assemble_deim(\n    **kwargs,\n)\nAssemble the hyperreduced bilinear form using DEIM reconstruction.\nTL;DR: Main assembly method that combines sparse element assembly with DEIM interpolation to produce the reduced-order operator matrix.\nThis method orchestrates the complete hyperreduction assembly process:\n\nSparse Assembly: Calls deim_elem_assembly() to build the sparse full-order matrix using only selected elements, dramatically reducing computational cost.\nDEIM Sampling: Extracts values at DEIM-selected rows from the sparse matrix, providing the minimal information needed for reconstruction.\nOperator Reconstruction: Uses the DEIM interpolation matrix to reconstruct the full reduced-order operator from the sampled values.\nBasis Projection: Projects the reconstructed operator onto the reduced trial basis to produce the final r×r reduced-order matrix.\n\nThe mathematical operation performed is: A_reduced = deim_mat @ A_sampled[sampled_rows, :] @ rob\nwhere A_sampled is the sparse matrix assembled over selected elements only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nKeyword arguments passed through to deim_elem_assembly for element-level assembly control.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nA_reduced\nndarray of shape (r, r)\nReduced-order bilinear form matrix ready for use in ROM systems. This is the hyperreduced approximation of the full-order operator projected onto the reduced basis.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.deim_elem_assembly(\n    **kwargs,\n)\nAssemble sparse matrix over hyperreduced element set.\nTL;DR: Performs efficient sparse assembly by extracting element matrices only from selected elements and building the global sparse matrix using optimized COO format construction.\nThis method handles the computationally intensive element-level assembly phase of hyperreduction:\n\nElement Matrix Extraction: Calls extract_element_matrices_rom() to compute local stiffness matrices for selected elements only, avoiding expensive integration over the entire domain.\nSparse Data Preparation: Flattens the element matrices and corresponding row/column indices into triplet format (I, J, V) suitable for sparse matrix construction.\nZero Filtering: Optionally removes zero entries to minimize memory usage and improve sparse matrix performance.\nCOO Construction: Builds the sparse matrix using coordinate (COO) format and converts to compressed sparse row (CSR) for efficient subsequent operations.\n\nThe assembly process preserves the mathematical structure of the full-order operator while dramatically reducing computational cost by focusing only on elements containing DEIM-selected degrees of freedom.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to extract_element_matrices_rom for controlling element-level assembly behavior.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK\nscipy.sparse.csr_matrix of shape (n_dofs, n_dofs)\nSparse global stiffness matrix assembled over the hyperreduced element set. Only selected elements contribute to this matrix, making it much cheaper to construct than the full-order equivalent.\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim.BilinearFormHYPERROM_deim.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for sparse global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost.\nThe method supports both serial and parallel execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and the integration is performed using the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nFinite element basis for trial functions containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nFinite element basis for test functions. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in the extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.bilinear_form_hyperrom_deim"
    ]
  },
  {
    "objectID": "reference/problem_structure.html",
    "href": "reference/problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Linear Elasticity\n\n\n\nGoal. This comprehensive hands-on tutorial walks you through every file in problem_1 and shows how to assemble an affine reduced-order model (ROM) for a 3-D linear-elastic block using scikit-rom. We’ll explain the theory behind each step and demonstrate how reduced-order modeling can dramatically accelerate computational mechanics simulations.\n\n\n\n\nReduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples\n\n\n\n\n\nFirst, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible.\n\n\n\n\nThe domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable.\n\n\n\n\nThis module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement\n\n\n\n\nThis is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase.\n\n\n\n\nThis module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads\n\n\n\n\nFor ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.\nfrom src.skrom.rom.rom_utils import generate_sobol\n\ndef parameters(N_snap=32):\n    # Sobol over (E, nu) in [100, 200] × [0.25, 0.35]\n    return generate_sobol([[100.,200.],[0.25,0.35]], 2*N_snap)\nDetailed Explanation:\n\nSobol Sequences: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.\nParameter Ranges:\n\nYoung’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)\nPoisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)\n\nSample Size: 2*N_snap samples are generated so they can be split into training and testing sets.\n\nUsage Pattern:\nE_nu_train, E_nu_test = np.split(parameters(32), 2)\nThis gives you 32 training samples and 32 testing samples for validation.\nWhy Good Sampling Matters: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others.\n\n\n\n\nThis is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\n\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations.\n\n\n\n\n\nThe offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.\nfrom src.skrom.problem_classes import new_problem\n\nprob = new_problem(\"problem_1\")\n\n# 1) draw parameter samples\ntheta_train = prob.parameters(n_samples=64)\n\n# 2) build snapshots\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\n\n# 3) compute POD basis\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\n\n# 4) assemble reduced operators\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nDetailed Step-by-Step Explanation:\n\n\ntheta_train = prob.parameters(n_samples=64)\nThis generates 64 parameter combinations \\((E_i, \\nu_i)\\) using the Sobol sequence. These parameters should span the expected range of operating conditions.\n\n\n\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\nFor each parameter combination, the full finite element problem is solved: \\[K(\\theta_i) u_i = f\\]\nThe resulting displacement vectors \\(u_i\\) are called “snapshots” and are stored as columns in matrix \\(U\\). If you have \\(N\\) degrees of freedom and \\(n_{snap}\\) parameter samples, then \\(U \\in \\mathbb{R}^{N \\times n_{snap}}\\).\n\n\n\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\nPOD performs Singular Value Decomposition on the snapshot matrix: \\[U = V \\Sigma W^T\\]\nThe columns of \\(V\\) are the POD modes, ordered by importance (largest singular values first). We keep only the first \\(r=50\\) modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.\nKey Insight: The POD basis \\(V\\) captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.\n\n\n\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nThe full-order operators are projected onto the reduced space: \\[A_r^q = V^T A^q V, \\quad f_r = V^T f\\]\nFor our affine case: - \\(A_r^1 = V^T K_\\lambda V\\) (reduced volumetric stiffness) - \\(A_r^2 = V^T K_\\mu V\\) (reduced deviatoric stiffness) - \\(f_r = V^T f\\) (reduced load vector)\nThese are small \\(r \\times r\\) matrices instead of \\(N \\times N\\) matrices, enabling rapid online assembly.\n\n\n\n\n\nOnce the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods\n\n\n\n\nIt’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction\n\n\n\n\n\n\nThe choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used."
  },
  {
    "objectID": "reference/problem_structure.html#what-is-reduced-order-modeling",
    "href": "reference/problem_structure.html#what-is-reduced-order-modeling",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy.\nThis is particularly powerful for:\n\nParameter studies: Exploring how a system responds to different material properties, boundary conditions, or geometry\nOptimization: Finding optimal designs without expensive repeated full-scale simulations\nReal-time applications: Control systems, digital twins, and interactive simulations\nUncertainty quantification: Monte Carlo studies with thousands of parameter samples"
  },
  {
    "objectID": "reference/problem_structure.html#prerequisites",
    "href": "reference/problem_structure.html#prerequisites",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "First, install the required packages:\npip install scikit-rom scikit-fem numpy scipy matplotlib\nPackage Overview: - scikit-rom: The main ROM framework we’ll be using - scikit-fem: A Python finite element library for discretizing PDEs - numpy/scipy: Numerical computing foundations - matplotlib: For visualization and plotting results\nYou should also clone the project so that the package layout shown below is on your PYTHONPATH:\nproblem_1/\n├─ domain.py           # Geometry, mesh, and finite element setup\n├─ bilinear_forms.py   # Weak form implementation (stiffness matrix)\n├─ linear_forms.py     # Right-hand side terms (loads, tractions)\n├─ properties.py       # Material property definitions\n├─ params.py           # Parameter sampling for training/testing\n└─ problem_def.py      # Main problem class that orchestrates everything\nThis modular structure separates concerns and makes the code maintainable and extensible."
  },
  {
    "objectID": "reference/problem_structure.html#geometry-finite-element-setup-domain.py",
    "href": "reference/problem_structure.html#geometry-finite-element-setup-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The domain.py file constructs the physical domain, mesh, and finite-element bases. This is where we define the computational geometry and specify boundary conditions.\nfrom skfem import MeshHex, Basis, ElementVector\n\ndef domain_(lx=1.0, ly=1.0, lz=1.0, factor=10, dirichlet_boundary_value=0.0):\n    mesh   = MeshHex().refined(factor) * [lx, ly, lz]\n    element = ElementVector(ElementHex1())\n    basis   = Basis(mesh, element)\n    # facet selectors (λ-functions that return True on selected facets)\n    left  = basis.mesh.facets_satisfying(lambda x: x[0] &lt; 1e-12)\n    right = basis.mesh.facets_satisfying(lambda x: x[0] &gt; lx - 1e-12)\n    fbasis_dirichlet = basis.restrict(left)\n    fbasis_neumann   = basis.restrict(right)\n    return dict(\n        mesh=mesh, basis=basis,\n        fbasis_dirichlet=fbasis_dirichlet,\n        fbasis_neumann=fbasis_neumann,\n        dirichlet_boundary_value=dirichlet_boundary_value\n    )\nDetailed Explanation:\n\nMesh Generation: MeshHex().refined(factor) creates a structured hexahedral mesh. The factor parameter controls refinement level - higher values give finer meshes with more elements. The mesh is then scaled to dimensions [lx, ly, lz].\nElement Type: ElementVector(ElementHex1()) specifies vector-valued trilinear hexahedral elements. This is appropriate for 3D elasticity where each node has three displacement degrees of freedom (u_x, u_y, u_z).\nBasis Functions: The Basis object encapsulates the finite element space, combining the mesh topology with the element type to define shape functions and their derivatives.\nBoundary Identification: The lambda functions identify mesh facets (faces) on the left and right boundaries:\n\nleft: facets where x-coordinate is approximately 0 (fixed boundary)\nright: facets where x-coordinate is approximately lx (loaded boundary)\n\nBoundary Bases: fbasis_dirichlet and fbasis_neumann are restricted function spaces on the boundary facets, used for applying boundary conditions.\n\nWhy This Structure? The helper returns a dictionary so that subsequent stages can be kept in pure-function style, making the code more modular and testable."
  },
  {
    "objectID": "reference/problem_structure.html#constitutive-law-material-properties-properties.py",
    "href": "reference/problem_structure.html#constitutive-law-material-properties-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This module defines the material behavior through elastic constants. We implement a simple inclusion model where part of the domain has different stiffness properties.\nfrom skfem.models.elasticity import lame_parameters\n\ndef lame_params(E, nu, region):\n    lam, mu = lame_parameters(E, nu)\n    if region == \"region_1\":      # stiffer inclusion\n        lam *= 50; mu *= 50\n    return lam, mu\nDetailed Explanation:\n\nLamé Parameters: In linear elasticity, material behavior is characterized by two independent elastic constants. The Lamé parameters (λ, μ) are mathematically convenient:\n\nλ (lambda): relates to bulk compression/expansion\nμ (mu): the shear modulus, relates to shape changes\n\nConversion from Engineering Constants: The function lame_parameters(E, nu) converts from the more intuitive engineering constants:\n\nE: Young’s modulus (stiffness in uniaxial tension)\nν: Poisson’s ratio (lateral contraction ratio)\n\nMaterial Heterogeneity: The region parameter allows for different material properties in different parts of the domain. Here, “region_1” represents a stiffer inclusion with 50× higher stiffness, simulating a composite material or reinforcement.\n\nPhysical Interpretation: This could represent scenarios like: - A metal block with a ceramic inclusion - Biological tissue with calcified regions - Composite materials with fiber reinforcement"
  },
  {
    "objectID": "reference/problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "href": "reference/problem_structure.html#affine-stiffness-tensor-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This is the heart of the finite element formulation. We implement the weak form of the linear elasticity equations and structure it to exploit the affine parameter dependence.\nThe weak form of linear elasticity states: Find \\(u\\) such that \\[a(u,v; \\lambda,\\mu) = \\ell(v) \\quad \\forall v\\]\nwhere the bilinear form is: \\[\na(u,v; \\lambda,\\mu) = \\int_\\Omega\n\\bigl[\n\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\operatorname{tr}(\\varepsilon(v)) +\n2\\mu\\,\\varepsilon(u):\\varepsilon(v)\n\\bigr]\\,d\\Omega\n\\]\nfrom skfem.helpers import sym_grad, ddot, trace\n\n@BilinearForm\ndef stiffness_lam(u, v, w):\n    lam = w[\"lam\"]\n    return lam * trace(sym_grad(u)) * trace(sym_grad(v))\n\n@BilinearForm\ndef stiffness_mu(u, v, w):\n    mu = w[\"mu\"]\n    return 2.0 * mu * ddot(sym_grad(u), sym_grad(v))\nDetailed Explanation:\n\nStrain Tensor: sym_grad(u) computes the symmetric gradient (strain tensor): \\[\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^T)\\]\nVolumetric Term: trace(sym_grad(u)) gives the volumetric strain (dilatation): \\[\\operatorname{tr}(\\varepsilon) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}\\]\nDeviatoric Term: ddot(sym_grad(u), sym_grad(v)) is the double contraction: \\[\\varepsilon(u):\\varepsilon(v) = \\sum_{i,j} \\varepsilon_{ij}(u)\\varepsilon_{ij}(v)\\]\nAffine Structure: The key insight is that the stiffness matrix can be written as: \\[K(\\lambda,\\mu) = \\lambda K_\\lambda + \\mu K_\\mu\\] where \\(K_\\lambda\\) and \\(K_\\mu\\) are parameter-independent matrices.\n\nWhy This Matters for ROM: Because each term is affine in \\((\\lambda,\\mu)\\), the global stiffness matrix can be pre-assembled offline as a linear combination of two parameter-independent blocks. This is crucial for computational efficiency in the online phase."
  },
  {
    "objectID": "reference/problem_structure.html#right-hand-side-linear_forms.py",
    "href": "reference/problem_structure.html#right-hand-side-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This module defines the loading conditions applied to the structure.\n@LinearForm\ndef traction(v, w):\n    return -1e-2 * v[1]   # constant Neumann traction in $y$-direction\nDetailed Explanation:\n\nNeumann Boundary Condition: This implements a traction (stress) boundary condition on the right face of the domain. The load is applied in the negative y-direction.\nMagnitude: The factor -1e-2 sets the load magnitude. This might represent:\n\nPressure loading (e.g., 0.01 MPa)\nBody forces scaled appropriately\nDistributed surface tractions\n\nParameter Independence: Again, this is a single parameter-independent load vector, which allows for efficient offline precomputation.\n\nPhysical Interpretation: This could represent: - Uniform pressure on a surface - Gravitational loading - Thermal expansion effects - Applied mechanical loads"
  },
  {
    "objectID": "reference/problem_structure.html#parameter-sampling-params.py",
    "href": "reference/problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "For ROM construction, we need to sample the parameter space systematically to capture the system’s behavior across all expected operating conditions.\nfrom src.skrom.rom.rom_utils import generate_sobol\n\ndef parameters(N_snap=32):\n    # Sobol over (E, nu) in [100, 200] × [0.25, 0.35]\n    return generate_sobol([[100.,200.],[0.25,0.35]], 2*N_snap)\nDetailed Explanation:\n\nSobol Sequences: These are quasi-random sequences designed to fill high-dimensional spaces more uniformly than random sampling. This ensures better coverage of the parameter space with fewer samples.\nParameter Ranges:\n\nYoung’s modulus E: [100, 200] (units depend on your problem, e.g., GPa)\nPoisson’s ratio ν: [0.25, 0.35] (dimensionless, typical range for metals)\n\nSample Size: 2*N_snap samples are generated so they can be split into training and testing sets.\n\nUsage Pattern:\nE_nu_train, E_nu_test = np.split(parameters(32), 2)\nThis gives you 32 training samples and 32 testing samples for validation.\nWhy Good Sampling Matters: The quality of your ROM depends heavily on how well the training snapshots represent the solution manifold. Poor sampling can lead to ROMs that work well for some parameters but fail catastrophically for others."
  },
  {
    "objectID": "reference/problem_structure.html#orchestrating-everything-problem_def.py",
    "href": "reference/problem_structure.html#orchestrating-everything-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "This is the main orchestration file that ties all components together using the scikit-rom framework.\n@register_problem(\"problem_1\")\nclass ProblemAffine(Problem):\n    def domain(self):            # geometry + BC\n        from .domain import domain_\n        return domain_()\n\n    def bilinear_forms(self):    # tuple of affine blocks\n        from .bilinear_forms import stiffness_lam, stiffness_mu\n        return stiffness_lam, stiffness_mu\n\n    def linear_forms(self):      # RHS blocks\n        from .linear_forms import traction\n        return (traction,)\n\n    def parameters(self, n_samples):   # ⇒ array (n, 2)\n        from .params import parameters\n        return parameters(n_samples)\n\n    def coeff_funcs(self):       # map (E,nu) → (λ, μ)\n        from .properties import lame_params\n        return lame_params\nDetailed Explanation:\nThe ProblemAffine class inherits from the scikit-rom Problem base class, which provides the heavy-lifting infrastructure. You only need to implement the problem-specific methods:\n\ndomain(): Returns the mesh, basis functions, and boundary conditions\nbilinear_forms(): Returns the tuple of affine bilinear form blocks\nlinear_forms(): Returns the right-hand side terms\nparameters(): Generates parameter samples for training/testing\ncoeff_funcs(): Maps between parameter representations\n\nThe Master Class Philosophy: The master class supplies most of the heavy lifting including: - Matrix assembly and boundary condition application - Snapshot generation for multiple parameter values - Singular Value Decomposition (SVD) and Proper Orthogonal Decomposition (POD) - Hyper-reduction techniques for further speedup - Error estimation and validation metrics - Visualization and plotting utilities\nYou only override what is problem-specific, following the principle of separation of concerns.\n\n\n\n\n\n\n\n\n\n\n\nMethod\nPurpose\nOffline?\nOnline?\n\n\n\n\ndomain()\nbuild mesh, BCs\n✔️\n\n\n\nbilinear_forms()\nreturn affine bilinear blocks\n✔️\n\n\n\nlinear_forms()\nreturn RHS blocks\n✔️\n\n\n\ncoeff_funcs()\nconvert material params → coefficients\n\n✔️\n\n\nparameters()\ntraining / test design\n✔️\n\n\n\nsolve(mu) (inherited)\nassemble & solve ROM\n\n✔️\n\n\n\nThis separation enforces the offline/online paradigm automatically, which is fundamental to efficient ROM implementations."
  },
  {
    "objectID": "reference/problem_structure.html#offline-workflow-building-the-rom",
    "href": "reference/problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The offline phase is where the computational investment is made. This is typically done once and can be time-consuming, but it enables many fast online evaluations.\nfrom src.skrom.problem_classes import new_problem\n\nprob = new_problem(\"problem_1\")\n\n# 1) draw parameter samples\ntheta_train = prob.parameters(n_samples=64)\n\n# 2) build snapshots\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\n\n# 3) compute POD basis\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\n\n# 4) assemble reduced operators\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nDetailed Step-by-Step Explanation:\n\n\ntheta_train = prob.parameters(n_samples=64)\nThis generates 64 parameter combinations \\((E_i, \\nu_i)\\) using the Sobol sequence. These parameters should span the expected range of operating conditions.\n\n\n\nU = prob.snapshots(theta_train)  # shape (n_dofs, n_snaps)\nFor each parameter combination, the full finite element problem is solved: \\[K(\\theta_i) u_i = f\\]\nThe resulting displacement vectors \\(u_i\\) are called “snapshots” and are stored as columns in matrix \\(U\\). If you have \\(N\\) degrees of freedom and \\(n_{snap}\\) parameter samples, then \\(U \\in \\mathbb{R}^{N \\times n_{snap}}\\).\n\n\n\nrbasis = prob.reduced_basis(U, r=50)  # keep 50 modes\nPOD performs Singular Value Decomposition on the snapshot matrix: \\[U = V \\Sigma W^T\\]\nThe columns of \\(V\\) are the POD modes, ordered by importance (largest singular values first). We keep only the first \\(r=50\\) modes, dramatically reducing the problem size from potentially thousands or millions of DOFs to just 50.\nKey Insight: The POD basis \\(V\\) captures the dominant patterns in the solution space. If the system exhibits low-dimensional behavior, most of the energy is contained in the first few modes.\n\n\n\nprob.build_rom(rbasis)               # affine blocks → (A_r^1, A_r^2), f_r\nThe full-order operators are projected onto the reduced space: \\[A_r^q = V^T A^q V, \\quad f_r = V^T f\\]\nFor our affine case: - \\(A_r^1 = V^T K_\\lambda V\\) (reduced volumetric stiffness) - \\(A_r^2 = V^T K_\\mu V\\) (reduced deviatoric stiffness) - \\(f_r = V^T f\\) (reduced load vector)\nThese are small \\(r \\times r\\) matrices instead of \\(N \\times N\\) matrices, enabling rapid online assembly."
  },
  {
    "objectID": "reference/problem_structure.html#online-solve-real-time-evaluation",
    "href": "reference/problem_structure.html#online-solve-real-time-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Once the ROM is built, evaluating it for new parameters is extremely fast:\nE, nu = 150.0, 0.30          # ← new parameter\nu_r   = prob.solve((E,nu))   # ≈ 100× faster than full FE!\nWhat Happens Under the Hood:\n\nParameter Conversion: \\((E, \\nu) \\rightarrow (\\lambda, \\mu)\\) using the coefficient function\nRapid Assembly: \\(K_r(\\lambda,\\mu) = \\lambda A_r^1 + \\mu A_r^2\\)\nSmall System Solve: \\(K_r(\\lambda,\\mu) u_r = f_r\\) (only \\(r \\times r\\) system!)\nReturn: The reduced solution \\(u_r \\in \\mathbb{R}^r\\)\n\nRecovery to Full Space:\nu_full = prob.recover(u_r)   # back-project to FOM space\nThis maps the reduced vector back to the full finite element space: \\[u_{full} = V u_r\\]\nNow \\(u_{full}\\) has the same dimension as the original finite element solution and can be used for post-processing, visualization, or VTK export.\nSpeed-Up Mechanisms: - Dimension Reduction: Solving \\(r \\times r\\) instead of \\(N \\times N\\) systems - Affine Structure: Pre-computed operators avoid reassembly - Optimized Solvers: Small dense systems can use direct methods"
  },
  {
    "objectID": "reference/problem_structure.html#validation-ensuring-rom-quality",
    "href": "reference/problem_structure.html#validation-ensuring-rom-quality",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "It’s crucial to validate that your ROM maintains accuracy across the parameter space:\nerr_rel, speed_up = prob.validate(n_test=20, tol=1e-3)\nprint(f\"median error = {err_rel:.2e}, speed-up ×{speed_up:.0f}\")\nWhat This Does:\n\nTest Parameter Generation: Creates 20 new parameter combinations not used in training\nDual Solve: For each test parameter:\n\nSolves the full finite element problem (slow but accurate)\nSolves the ROM problem (fast approximation)\n\nError Computation: Computes relative error in appropriate norm (typically energy norm for mechanics)\nTiming Comparison: Measures computational time for both approaches\n\nError Metrics: The relative error is typically computed as: \\[\\text{error} = \\frac{\\|u_{FOM} - u_{ROM}\\|_E}{\\|u_{FOM}\\|_E}\\]\nwhere \\(\\|\\cdot\\|_E\\) is the energy norm: \\(\\|u\\|_E^2 = u^T K u\\).\nInterpreting Results: - Good ROM: Error &lt; 1e-3, speed-up &gt; 10× - Excellent ROM: Error &lt; 1e-5, speed-up &gt; 100× - Poor ROM: High error or low speed-up indicates need for: - More training samples - Higher reduced dimension \\(r\\) - Better parameter sampling - Different basis construction"
  },
  {
    "objectID": "reference/problem_structure.html#advanced-topics",
    "href": "reference/problem_structure.html#advanced-topics",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "The choice of \\(r\\) (number of POD modes) involves a trade-off: - Too small: Poor approximation quality - Too large: Slow online evaluation\nRule of Thumb: Plot the singular values and choose \\(r\\) such that: \\[\\frac{\\sum_{i=1}^r \\sigma_i^2}{\\sum_{i=1}^{n_{snap}} \\sigma_i^2} &gt; 0.999\\]\nThis ensures 99.9% of the “energy” is captured.\n\n\n\nOur example exploits affine parameter dependence: \\[K(\\mu) = \\sum_{q=1}^Q \\Theta_q(\\mu) K_q\\]\nFor non-linear, non-affine problems, hyperreduction techniques are used."
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html",
    "href": "reference/problem_classes.master_class_static.html",
    "title": "problem_classes.master_class_static",
    "section": "",
    "text": "problem_classes.master_class_static\nModule for static reduced-order modeling (ROM):"
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#classes",
    "href": "reference/problem_classes.master_class_static.html#classes",
    "title": "problem_classes.master_class_static",
    "section": "Classes",
    "text": "Classes\n\n\n\nName\nDescription\n\n\n\n\nProblem\nAbstract base for conductivity problems under affine decomposition.\n\n\nfom_simulation\nOffline snapshot generator using full-order FEM.\n\n\nrom_simulation\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\n\n\n\nProblem\nproblem_classes.master_class_static.Problem()\nAbstract base for conductivity problems under affine decomposition.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nReturn affine bilinear form components.\n\n\ndomain\nReturn geometry and FEM bases.\n\n\nfom_solver\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nReturn affine linear form components.\n\n\nparameters\nGenerate sampling of parameter space.\n\n\nproperties\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nSolve reduced-order model for given parameters.\n\n\n\n\nbilinear_forms\nproblem_classes.master_class_static.Problem.bilinear_forms()\nReturn affine bilinear form components.\n\n\ndomain\nproblem_classes.master_class_static.Problem.domain()\nReturn geometry and FEM bases.\n\n\nfom_solver\nproblem_classes.master_class_static.Problem.fom_solver()\nSolve full-order FEM system for given parameters.\n\n\nhyper_rom_solver\nproblem_classes.master_class_static.Problem.hyper_rom_solver()\nSolve hyper-reduced-order model for given parameters.\n\n\nlinear_forms\nproblem_classes.master_class_static.Problem.linear_forms()\nReturn affine linear form components.\n\n\nparameters\nproblem_classes.master_class_static.Problem.parameters()\nGenerate sampling of parameter space.\n\n\nproperties\nproblem_classes.master_class_static.Problem.properties()\nReturn function to compute parameter-dependent coefficients.\n\n\nrom_solver\nproblem_classes.master_class_static.Problem.rom_solver()\nSolve reduced-order model for given parameters.\n\n\n\n\nfom_simulation\nproblem_classes.master_class_static.fom_simulation(num_snapshots=32)\nOffline snapshot generator using full-order FEM.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nrun_simulation\nGenerate snapshots and record timings.\n\n\n\n\nrun_simulation\nproblem_classes.master_class_static.fom_simulation.run_simulation()\nGenerate snapshots and record timings.\n\n\n\n\nrom_simulation\nproblem_classes.master_class_static.rom_simulation(\n    mean=None,\n    fos_solutions=None,\n    train_mask=None,\n    test_mask=None,\n    V_sel=None,\n    n_sel=None,\n    N_rom_snap=None,\n)\nPlain Galerkin ROM evaluator with error and speed-up metrics.\n\nMethods\n\n\n\nName\nDescription\n\n\n\n\nrun_hyper_rom_simulation\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\n\nrun_rom_simulation\nExecute ROM solves, compute error percentages and speed-ups.\n\n\n\n\nrun_hyper_rom_simulation\nproblem_classes.master_class_static.rom_simulation.run_hyper_rom_simulation(z)\nExecute hyper-ROM solves, compute error percentages and speed-ups.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nz\narray_like\nWeight vector for hyper-reduction (stored for reference).\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nhyper_rom_error\nlist of float\nPercent error per snapshot.\n\n\nhyper_speed_up\nlist of float\nFull/FOM time ratio per snapshot.\n\n\n\n\n\n\nrun_rom_simulation\nproblem_classes.master_class_static.rom_simulation.run_rom_simulation()\nExecute ROM solves, compute error percentages and speed-ups.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nrom_error\nlist of float\nPercent error per snapshot.\n\n\nspeed_up\nlist of float\nFull/ROM time ratio per snapshot."
  },
  {
    "objectID": "reference/problem_classes.master_class_static.html#functions",
    "href": "reference/problem_classes.master_class_static.html#functions",
    "title": "problem_classes.master_class_static",
    "section": "Functions",
    "text": "Functions\n\n\n\nName\nDescription\n\n\n\n\nget_problem\nInstantiate a registered problem by name.\n\n\nregister_problem\nDecorator to register a problem class under a given name.\n\n\n\n\nget_problem\nproblem_classes.master_class_static.get_problem(name)\nInstantiate a registered problem by name.\n\n\nregister_problem\nproblem_classes.master_class_static.register_problem(name)\nDecorator to register a problem class under a given name."
  },
  {
    "objectID": "reference/hyperreduction.html",
    "href": "reference/hyperreduction.html",
    "title": "hyperreduction",
    "section": "",
    "text": "hyperreduction\nhyperreduction\nThe hyperreduce package provides tools to perform hyper‐reduction on full‐order models.\nContents: - bilinear_form_hyperrom.py & linear_form_hyperrom.py: Classes that cluster elements by free‐DOF counts, project local stiffness/load contributions onto reduced bases, and assemble global reduced matrices/vectors. - hyperreduce.py: End‐to‐end pipeline combining randomized SVD preprocessing with bounded NNLS solves for weight selection, plus plotting diagnostics. - custom_nnls.py: Wrapped NNLS solver specialized for hyper‐reduction constraints.\nThese modules streamline the construction of sparse, hyper‐reduced operators and right‐hand sides for fast, accurate reduced‐order simulations."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.html",
    "href": "reference/hyperreduction.ecsw.html",
    "title": "hyperreduction.ecsw",
    "section": "",
    "text": "hyperreduction.ecsw\nhyperreduction.ecsw"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "hyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol)."
  },
  {
    "objectID": "reference/fom.html",
    "href": "reference/fom.html",
    "title": "fom",
    "section": "",
    "text": "fom"
  },
  {
    "objectID": "reference/fom.html#fem_utils.py",
    "href": "reference/fom.html#fem_utils.py",
    "title": "fom",
    "section": "fem_utils.py",
    "text": "fem_utils.py\nFinite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools"
  },
  {
    "objectID": "problem_structure.html",
    "href": "problem_structure.html",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "",
    "text": "Video\nLinear Elasticity\nThis comprehensive tutorial demonstrates the complete process of developing a reduced-order model (ROM) for a three-dimensional linear elastic structure using scikit-rom. You’ll learn how each component operates, understand the interconnections between files, and discover how to build an affine ROM that enables real-time or near-real-time simulations.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-description",
    "href": "problem_structure.html#problem-description",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Problem Description",
    "text": "Problem Description\nWe analyze a 3D block governed by linear elasticity principles. The structure features two distinct material regions with different stiffness properties, enabling demonstration of spatially varying material handling through affine decomposition. Core characteristics include:\nLinear Affine Elasticity: The stiffness matrix is constructed as a linear combination of blocks that are affine in the Lamé parameters \\((\\lambda, \\mu)\\).\nDomain Partitioning: The block is divided into two regions with distinct elastic properties.\nParameter Space: Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) are sampled for both offline and online ROM phases.\nBoundary Conditions: Dirichlet constraints (fixed displacement) on one face; Neumann conditions (applied traction) on the opposing face.\nLink\n Video tutorial",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#project-architecture",
    "href": "problem_structure.html#project-architecture",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "Project Architecture",
    "text": "Project Architecture\nThe simulation workflow is organized through the following directory structure and files:\nproblem_1/\n├─ domain.py           # Mesh generation, basis setup, boundary and region partitioning\n├─ bilinear_forms.py   # Affine weak form (stiffness) assembly\n├─ linear_forms.py     # Load (traction) right-hand side term\n├─ properties.py       # Lamé parameter computation per region\n├─ params.py           # Sampling (E, ν) for training and testing\n└─ problem_def.py      # Main orchestration: assembles all components for scikit-rom\n└─ problem_1.ipynb     # Executes the complete workflow starting from data generation to model reduction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "href": "problem_structure.html#geometry-finite-element-framework-domain.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "1. Geometry & Finite Element Framework — domain.py",
    "text": "1. Geometry & Finite Element Framework — domain.py\nMesh Construction: The domain represents a 3D block discretized with hexahedral elements, parameterized by dimensions \\((l_x, l_y, l_z)\\) and mesh refinement factor for resolution control.\nBasis Functions: Employs vector-valued trilinear hexahedral elements to represent 3D displacement fields.\nBoundary Identification:\n\n'left': Dirichlet (fixed displacement)\n'right': Neumann (applied load)\n\nRegion Partitioning: The mesh is divided along the \\(x\\)-axis at the midpoint into:\n\nregion_1: \\(x \\leq 0.5 \\cdot l_x\\) (stiffer region)\nregion_2: \\(x &gt; 0.5 \\cdot l_x\\) (softer region)\n\nThe module returns a comprehensive dictionary containing the mesh, bases, boundary DOFs, and a per-region basis dictionary for subsequent operator assembly.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "href": "problem_structure.html#material-properties-affine-coefficient-functions-properties.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "2. Material Properties & Affine Coefficient Functions — properties.py",
    "text": "2. Material Properties & Affine Coefficient Functions — properties.py\nLamé Parameters: Transforms Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\) into Lamé parameters \\((\\lambda, \\mu)\\) using skfem utilities.\nRegion Handling:\n\nFor region_1, both \\(\\lambda\\) and \\(\\mu\\) are scaled by \\(50\\times\\) (stiffer inclusion)\nFor region_2, properties remain unchanged (baseline material)",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "href": "problem_structure.html#affine-stiffness-matrix-assembly-bilinear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py",
    "text": "3. Affine Stiffness Matrix Assembly — bilinear_forms.py\nAffine Bilinear Forms:\n\nstiffness_lam: Weak form for the \\(\\lambda\\) (volumetric) component\nstiffness_mu: Weak form for the \\(\\mu\\) (shear) component\n\nMathematics: Each block is computed per-region (using basis restriction). The global stiffness matrix is expressed as:\n\\(K(E,\\nu) = \\sum_{\\text{regions}} \\lambda \\cdot K_{\\lambda,\\text{region}} + \\mu \\cdot K_{\\mu,\\text{region}}\\)\nParameter-Dependent Evaluation: Lamé parameters are computed as needed for each region via the region-aware property function.\nThis approach ensures the assembly aligns with the affine decomposition essential for efficient ROM evaluation.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "href": "problem_structure.html#right-hand-side-loads-linear_forms.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "4. Right-Hand Side (Loads) — linear_forms.py",
    "text": "4. Right-Hand Side (Loads) — linear_forms.py\nNeumann Traction: Implements a constant traction (-1e-2) in the global \\(y\\)-direction applied to the ‘right’ face.\nAffine in Parameters: The load vector is parameter-independent and only needs to be assembled once for the entire ROM process.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#parameter-sampling-params.py",
    "href": "problem_structure.html#parameter-sampling-params.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "5. Parameter Sampling — params.py",
    "text": "5. Parameter Sampling — params.py\nParameter Ranges:\n\n\\(E\\): [2.0, 10.0]\n\\(\\nu\\): [0.2, 0.4]\n\nSampling Strategy: Uses Sobol sequences to create quasi-random sets of \\((E,\\nu)\\) pairs for:\n\nTraining snapshots (for ROM basis construction)\nTesting snapshots (for validation)\n\nMasks Provided: Returns boolean arrays to cleanly separate training vs testing data.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#problem-orchestration-problem_def.py",
    "href": "problem_structure.html#problem-orchestration-problem_def.py",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "6. Problem Orchestration — problem_def.py",
    "text": "6. Problem Orchestration — problem_def.py\nMaster Problem Class: Inherits from the scikit-rom base and registers essential routines:\n\ndomain(): Loads mesh and DOFs from domain.py\nbilinear_forms(): Returns affine weak forms for \\(\\lambda\\) and \\(\\mu\\)\nlinear_forms(): Returns the Neumann loading routine\nproperties(): Returns the regionwise Lamé parameter mapper\nparameters(n_samples): Returns parameter sets and train/test split\n\nAffine Operator Assembly: On the first solve, stiffness and load “blocks” are assembled separately for each region/material.\nFull-Order Solve: Assembles and solves the condensed system with Dirichlet BCs for each parameter instance.\nROM Projection: Projects global blocks onto the reduced basis, incorporating an offline mean-shift to keep the ROM centered.\nThis design ensures a clear separation between model definition (problem file) and algorithmic ROM machinery (provided by scikit-rom).",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#offline-workflow-building-the-rom",
    "href": "problem_structure.html#offline-workflow-building-the-rom",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "7. Offline Workflow: Building the ROM",
    "text": "7. Offline Workflow: Building the ROM\nStep-by-step process:\n\nParameter Sampling: Generate \\(n\\) training samples \\((E_i, \\nu_i)\\) using the routine from params.py.\nFull-Order Simulations: For each parameter, solve the full high-fidelity FEM system and store the solution as a snapshot.\nData Processing:\n\nMean Subtraction: Subtract the mean from all snapshots to center the dataset\nSVD/POD: Perform singular value decomposition on the mean-subtracted snapshots to find the dominant modes (energy-ranked spatial patterns)\nMode Truncation: Retain only the leading \\(r\\) modes (user- or error-determined) for reduced basis\n\nReduced Operator Assembly: Project per-region blocks \\((K_{\\lambda,\\text{region}}, K_{\\mu,\\text{region}})\\) into the reduced space, yielding ultra-compact operators.\n\nThe reduced model is now ready for very rapid online predictions.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#online-workflow-fast-evaluation",
    "href": "problem_structure.html#online-workflow-fast-evaluation",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "8. Online Workflow: Fast Evaluation",
    "text": "8. Online Workflow: Fast Evaluation\nFor a new parameter set \\((E, \\nu)\\):\n\nCompute Per-Region Lamé Parameters: Map input parameters to \\((\\lambda, \\mu)\\) values for each region.\nAssemble Reduced Stiffness: Combine precomputed regionwise blocks using affine expressions.\nSolve Reduced System: The resulting linear system has size equal to the number of modes \\((r \\ll N)\\), making it extremely fast.\nMean Recovery: Add back the mean field to produce the full-field displacement solution, ready for visualization or further analysis.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#validation-error-assessment",
    "href": "problem_structure.html#validation-error-assessment",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "9. Validation & Error Assessment",
    "text": "9. Validation & Error Assessment\nTest Set: Evaluate the ROM on held-out (never-seen) parameter pairs.\nError Metrics:\n\nRelative error (L2 or energy norm) between ROM and high-fidelity FOM solutions\nStatistical fit metrics (e.g., R² score)\n\nSpeed-up Factor: The ROM typically achieves significant speed-up (often orders of magnitude) versus direct FEM.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#summary-table-of-key-methods",
    "href": "problem_structure.html#summary-table-of-key-methods",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "10. Summary Table of Key Methods",
    "text": "10. Summary Table of Key Methods\n\n\n\n\n\n\n\n\nMethod\nPurpose\nTypical Location in Pipeline\n\n\n\n\ndomain()\nSetup mesh, BCs, DOFs, and per-region bases\nFirst, before assembly\n\n\nbilinear_forms()\nReturn affine form handles for λ, μ\nOperator initialization\n\n\nlinear_forms()\nSpecify right-hand-side (load)\nOperator assembly\n\n\nproperties()\nMap (E, ν, region) → (λ, μ)\nParameter unpacking\n\n\nparameters()\nProduce sampled (E, ν) + train/test masks\nOffline/online split\n\n\nfom_solver()\nRun and store full-order solutions\nSnapshot generation (offline)\n\n\nrom_solver()\nAssemble and solve projected ROM system\nRapid online prediction",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "problem_structure.html#best-practices",
    "href": "problem_structure.html#best-practices",
    "title": "Tutorial: Building a Reduced-Order Model with scikit-rom",
    "section": "11. Best Practices",
    "text": "11. Best Practices\n\nAlways center your snapshot data before SVD to ensure best POD convergence\nUse enough training samples (and parameter space coverage) to avoid overfitting or “holes” in ROM accuracy\nCheck ROM error on multiple, unseen test samples\nVisualize spatial error fields—not just scalar error metrics—for insight into local ROM limitations\nLeverage the modular file structure for extending to other domains, BCs, and PDEs\n\nThis workflow and modular codebase provide a flexible, scalable foundation for reduced-order modeling of parametrized PDEs in computational mechanics, accelerating simulation, optimization, and interactive design.",
    "crumbs": [
      "**Examples**",
      "Tutorial: Building a Reduced-Order Model with scikit-rom"
    ]
  },
  {
    "objectID": "nonlinear_power_law.html#problem-setup",
    "href": "nonlinear_power_law.html#problem-setup",
    "title": "P.1 Nonlinear power-law (strain-hardening) bar under gravity and line load",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.1 Nonlinear power-law (strain-hardening) bar under gravity and line load"
    ]
  },
  {
    "objectID": "linear bending.html#problem-setup",
    "href": "linear bending.html#problem-setup",
    "title": "P.3 Heterogeneous linear elasticity in a two-material 3D block",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink\nSee detailed tutorial for this problem",
    "crumbs": [
      "**Examples**",
      "Computational Mechanics",
      "P.3 Heterogeneous linear elasticity in a two-material 3D block"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to skrom",
    "section": "",
    "text": "scikit-rom is a lightweight, Python-based platform designed for projection-based model reduction of finite element models with moderate to large problem sizes (up to approximately 600,000 degrees of freedom). Built on top of scikit-fem, an easy-to-use finite element assembly library, this repository demonstrates reduced-order modeling (ROM) techniques for a range of linear and nonlinear problems, including time-dependent ones. Current examples primarily focus on thermal and mechanical systems, with extensions to fluid dynamics planned for future releases.\nBeyond its application to real-world finite element problems, the library also serves as a valuable testing ground for new model reduction algorithms and as a tutorial resource for those new to the field."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Welcome to skrom",
    "section": "Installation",
    "text": "Installation\n\n\nThis tutorial explains how to install SKROM (scikit-ROM):\nInstallation Steps:\n\nClone the repository:\n\ngit clone https://github.com/suparnob100/scikit-rom\ncd scikit-rom\n\nInstall with pip:\n\n\nFor developers (editable install):\n\npip install -e .\n\nFor regular users:\n\npip install .\n(Use pip3 instead of pip on Mac)\nNotes:\n\nUse -e for development; it lets you edit the code without reinstalling.\nRegular users should use standard installation.\nReinstallation automatically removes the old version.\nThe installation completes in seconds and shows “successfully built SKROM.”\nAll instructions are available on the GitHub page."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Welcome to skrom",
    "section": "Getting Started",
    "text": "Getting Started"
  },
  {
    "objectID": "index.html#recommended-reading",
    "href": "index.html#recommended-reading",
    "title": "Welcome to skrom",
    "section": "Recommended Reading",
    "text": "Recommended Reading\nTo dive deeper, check out:\n\nHyper-reduction Techniques for Efficient Simulation"
  },
  {
    "objectID": "linear star.html#problem-setup",
    "href": "linear star.html#problem-setup",
    "title": "P.4 Linear heat conduction with non-affine parametric source on a star-shaped plate",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Heat Transfer",
      "P.4 Linear heat conduction with non-affine parametric source on a star-shaped plate"
    ]
  },
  {
    "objectID": "non_linear.html#problem-setup",
    "href": "non_linear.html#problem-setup",
    "title": "P.5 Nonlinear heat conduction in a two-material 1-D rod",
    "section": "Problem Setup",
    "text": "Problem Setup\nLink",
    "crumbs": [
      "**Examples**",
      "Heat Transfer",
      "P.5 Nonlinear heat conduction in a two-material 1-D rod"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html",
    "href": "reference/fom.fem_utils.html",
    "title": "fom.fem_utils",
    "section": "",
    "text": "fom.fem_utils\nFinite element utilities for preconditioning, mesh operations, and nonlinear solving.\nThis module includes: - build_pc_amgsa: construct AMG smoothed aggregation preconditioner. - element2location: generate element-to-coordinate mappings from mesh data. - newton_solver and its helpers: perform Newton–Raphson solves with or without Dirichlet BC. - compute_basis_regions: create reduced bases for mesh regions. - load_domain, load_mesh_and_basis: domain/mesh loading utilities. - unwrap_attr: attribute unwrapping helper.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nCreate reduced basis functions for specified mesh regions.\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_domain\nLoad domain information and assign attributes to instance.\n\n\nload_mesh_and_basis\nLoad only mesh and basis from domain and assign to instance.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method.\n\n\nunwrap_attr\nUnwrap 0-dimensional object arrays to their scalar values.\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\nTL;DR: Creates an AMG preconditioner from a system matrix for efficient iterative solving of large sparse linear systems.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers like conjugate gradient.\n\n\n\n\n\n\n&gt;&gt;&gt; import scipy.sparse as sp\n&gt;&gt;&gt; A = sp.diags([1, -2, 1], [-1, 0, 1], shape=(100, 100))\n&gt;&gt;&gt; M = build_pc_amgsa(A)\n&gt;&gt;&gt; # Use M as preconditioner in iterative solver\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nCreate reduced basis functions for specified mesh regions.\nTL;DR: Given boolean masks defining mesh regions, returns basis functions restricted to each region for efficient regional computations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nobject\nFinite element basis object with nelems attribute and with_elements method.\nrequired\n\n\nmasks\ndict of str to ndarray of bool\nDictionary mapping region names to boolean element masks of shape (basis.nelems,). True values indicate elements belonging to the region.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nregion_bases\ndict of str to object\nDictionary mapping region names to reduced basis objects containing only elements specified by the corresponding mask.\n\n\n\n\n\n\n&gt;&gt;&gt; masks = {'left': np.array([True, False, True]), \n...          'right': np.array([False, True, False])}\n&gt;&gt;&gt; region_bases = compute_basis_regions(basis, masks)\n&gt;&gt;&gt; # region_bases['left'] contains basis for left region elements\n\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\nTL;DR: Extracts element-wise coordinate information from mesh connectivity, useful for element-based computations in finite element methods.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity). Expected to have p as shape (spatial_dim, n_nodes) and t as shape (n_local_nodes_per_element, n_elements).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element. For 1D meshes, this gives coordinates of element endpoints.\n\n\n\n\n\n\n&gt;&gt;&gt; # For a 1D mesh with 3 elements and 4 nodes\n&gt;&gt;&gt; element_coords = element2location(mesh)\n&gt;&gt;&gt; # element_coords[0] gives coordinates of first element's nodes\n\n\n\n\nfom.fem_utils.load_domain(instance)\nLoad domain information and assign attributes to instance.\nTL;DR: Calls instance.domain() and assigns all returned attributes to the instance object for convenient access.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method that returns a dictionary of domain attributes.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting attributes based on the domain dictionary keys and values.\n\n\n\n&gt;&gt;&gt; load_domain(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh, problem_instance.basis, etc. are available\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nLoad only mesh and basis from domain and assign to instance.\nTL;DR: Extracts just mesh and basis from instance.domain() for cases where only these two components are needed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method returning a dictionary containing at least ‘mesh’ and ‘basis’ keys.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting only mesh and basis attributes, ignoring other domain components.\n\n\n\n&gt;&gt;&gt; load_mesh_and_basis(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh and problem_instance.basis are available\n\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method.\nTL;DR: Newton solver with optional Dirichlet boundary conditions that iteratively solves F(u) = 0 by computing Jacobian and RHS at each iteration.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the Jacobian matrix. Should accept (u, *assemble_args) and return the Jacobian matrix J where J[i,j] = ∂F_i/∂u_j.\nrequired\n\n\nrhs_fn\ncallable\nFunction that assembles the RHS vector. Should accept (u, *assemble_args) and return the residual vector F(u).\nrequired\n\n\nu0\nndarray of shape (n_dofs,)\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nPrescribed values at the Dirichlet DOFs. Must have same length as dirichlet_dofs.\nNone\n\n\n*assemble_args\ntuple\nAdditional positional arguments passed to assemble_fn and rhs_fn.\n()\n\n\ntol\nfloat\nConvergence tolerance based on the L2 norm of the solution update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations before giving up.\n50\n\n\nalpha\nfloat\nStep length parameter for solution updates.\n1.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray of shape (n_dofs,)\nApproximate solution vector after convergence or maximum iterations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations and no Dirichlet boundary conditions are specified.\n\n\n\n\n\n\nThe Newton method solves F(u) = 0 by iterating u_{k+1} = u_k - α * J_k^{-1} * F(u_k), where J_k is the Jacobian at u_k. For problems with Dirichlet BC, the system is condensed to solve only for free DOFs.\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nUnwrap 0-dimensional object arrays to their scalar values.\nTL;DR: Converts 0-d numpy object arrays to their contained scalar value using .item(), useful for cleaning up attributes after certain operations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject containing the attribute to unwrap.\nrequired\n\n\nattr_name\nstr\nName of the attribute to unwrap.\nrequired\n\n\n\n\n\n\nOnly applies unwrapping if the attribute is a 0-dimensional numpy array with object dtype. The instance is modified in-place.\n\n\n\n&gt;&gt;&gt; # If instance.result is np.array(42, dtype=object)\n&gt;&gt;&gt; unwrap_attr(instance, 'result')\n&gt;&gt;&gt; # Now instance.result is 42 (scalar int)",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html#functions",
    "href": "reference/fom.fem_utils.html#functions",
    "title": "fom.fem_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\ncompute_basis_regions\nCreate reduced basis functions for specified mesh regions.\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nload_domain\nLoad domain information and assign attributes to instance.\n\n\nload_mesh_and_basis\nLoad only mesh and basis from domain and assign to instance.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method.\n\n\nunwrap_attr\nUnwrap 0-dimensional object arrays to their scalar values.\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\nTL;DR: Creates an AMG preconditioner from a system matrix for efficient iterative solving of large sparse linear systems.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers like conjugate gradient.\n\n\n\n\n\n\n&gt;&gt;&gt; import scipy.sparse as sp\n&gt;&gt;&gt; A = sp.diags([1, -2, 1], [-1, 0, 1], shape=(100, 100))\n&gt;&gt;&gt; M = build_pc_amgsa(A)\n&gt;&gt;&gt; # Use M as preconditioner in iterative solver\n\n\n\n\nfom.fem_utils.compute_basis_regions(basis, masks)\nCreate reduced basis functions for specified mesh regions.\nTL;DR: Given boolean masks defining mesh regions, returns basis functions restricted to each region for efficient regional computations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nobject\nFinite element basis object with nelems attribute and with_elements method.\nrequired\n\n\nmasks\ndict of str to ndarray of bool\nDictionary mapping region names to boolean element masks of shape (basis.nelems,). True values indicate elements belonging to the region.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nregion_bases\ndict of str to object\nDictionary mapping region names to reduced basis objects containing only elements specified by the corresponding mask.\n\n\n\n\n\n\n&gt;&gt;&gt; masks = {'left': np.array([True, False, True]), \n...          'right': np.array([False, True, False])}\n&gt;&gt;&gt; region_bases = compute_basis_regions(basis, masks)\n&gt;&gt;&gt; # region_bases['left'] contains basis for left region elements\n\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\nTL;DR: Extracts element-wise coordinate information from mesh connectivity, useful for element-based computations in finite element methods.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity). Expected to have p as shape (spatial_dim, n_nodes) and t as shape (n_local_nodes_per_element, n_elements).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element. For 1D meshes, this gives coordinates of element endpoints.\n\n\n\n\n\n\n&gt;&gt;&gt; # For a 1D mesh with 3 elements and 4 nodes\n&gt;&gt;&gt; element_coords = element2location(mesh)\n&gt;&gt;&gt; # element_coords[0] gives coordinates of first element's nodes\n\n\n\n\nfom.fem_utils.load_domain(instance)\nLoad domain information and assign attributes to instance.\nTL;DR: Calls instance.domain() and assigns all returned attributes to the instance object for convenient access.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method that returns a dictionary of domain attributes.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting attributes based on the domain dictionary keys and values.\n\n\n\n&gt;&gt;&gt; load_domain(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh, problem_instance.basis, etc. are available\n\n\n\n\nfom.fem_utils.load_mesh_and_basis(instance)\nLoad only mesh and basis from domain and assign to instance.\nTL;DR: Extracts just mesh and basis from instance.domain() for cases where only these two components are needed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with a domain() method returning a dictionary containing at least ‘mesh’ and ‘basis’ keys.\nrequired\n\n\n\n\n\n\nThis function modifies the instance in-place by setting only mesh and basis attributes, ignoring other domain components.\n\n\n\n&gt;&gt;&gt; load_mesh_and_basis(problem_instance)\n&gt;&gt;&gt; # Now problem_instance.mesh and problem_instance.basis are available\n\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    rhs_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n    alpha=1.0,\n)\nSolve a nonlinear system using the Newton–Raphson method.\nTL;DR: Newton solver with optional Dirichlet boundary conditions that iteratively solves F(u) = 0 by computing Jacobian and RHS at each iteration.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the Jacobian matrix. Should accept (u, *assemble_args) and return the Jacobian matrix J where J[i,j] = ∂F_i/∂u_j.\nrequired\n\n\nrhs_fn\ncallable\nFunction that assembles the RHS vector. Should accept (u, *assemble_args) and return the residual vector F(u).\nrequired\n\n\nu0\nndarray of shape (n_dofs,)\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nPrescribed values at the Dirichlet DOFs. Must have same length as dirichlet_dofs.\nNone\n\n\n*assemble_args\ntuple\nAdditional positional arguments passed to assemble_fn and rhs_fn.\n()\n\n\ntol\nfloat\nConvergence tolerance based on the L2 norm of the solution update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations before giving up.\n50\n\n\nalpha\nfloat\nStep length parameter for solution updates.\n1.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray of shape (n_dofs,)\nApproximate solution vector after convergence or maximum iterations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations and no Dirichlet boundary conditions are specified.\n\n\n\n\n\n\nThe Newton method solves F(u) = 0 by iterating u_{k+1} = u_k - α * J_k^{-1} * F(u_k), where J_k is the Jacobian at u_k. For problems with Dirichlet BC, the system is condensed to solve only for free DOFs.\n\n\n\n\nfom.fem_utils.unwrap_attr(instance, attr_name)\nUnwrap 0-dimensional object arrays to their scalar values.\nTL;DR: Converts 0-d numpy object arrays to their contained scalar value using .item(), useful for cleaning up attributes after certain operations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject containing the attribute to unwrap.\nrequired\n\n\nattr_name\nstr\nName of the attribute to unwrap.\nrequired\n\n\n\n\n\n\nOnly applies unwrapping if the attribute is a 0-dimensional numpy array with object dtype. The instance is modified in-place.\n\n\n\n&gt;&gt;&gt; # If instance.result is np.array(42, dtype=object)\n&gt;&gt;&gt; unwrap_attr(instance, 'result')\n&gt;&gt;&gt; # Now instance.result is 42 (scalar int)",
    "crumbs": [
      "**Documentation**",
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.bilinear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly"
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element."
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "hyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html",
    "href": "reference/hyperreduction.linear_form_hyperrom.html",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.linear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data"
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "fom.fem_utils\nFinite element utilities for preconditioning, mesh operations, and nonlinear solving.\n\n\n\n\n\n\n\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,\n\n\n\n\n\n\n\n\n\nrom.deim.bilinear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element bilinear forms.\n\n\nrom.deim.linear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element linear forms.\n\n\nrom.deim.deim\nDiscrete Empirical Interpolation Method (DEIM) for nonlinear ROM acceleration.\n\n\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw\nECSW-based hyperreduction for finite element bilinear forms with element clustering.\n\n\nrom.ecsw.linear_form_hyperrom_ecsw\n\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\n\n\n\n\n\n\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.reduced_basis.svd\n\n\n\n\n\n\n\n\n\n\nutils.dynamics.integrators\n\n\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette\n\n\n\nutils.visualization.plot_utils\n\n\n\n\n\n\n\n\n\n\ntemplates.problem_template.bilinear_forms\n\n\n\ntemplates.problem_template.linear_forms\n\n\n\ntemplates.problem_template.params\n\n\n\ntemplates.problem_template.domain\n\n\n\ntemplates.problem_template.problem_def\n\n\n\ntemplates.problem_template.properties",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#full-order-model-fom",
    "href": "reference/index.html#full-order-model-fom",
    "title": "Function reference",
    "section": "",
    "text": "fom.fem_utils\nFinite element utilities for preconditioning, mesh operations, and nonlinear solving.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reduced-order-model-rom",
    "href": "reference/index.html#reduced-order-model-rom",
    "title": "Function reference",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#deim-hyper-reduction",
    "href": "reference/index.html#deim-hyper-reduction",
    "title": "Function reference",
    "section": "",
    "text": "rom.deim.bilinear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element bilinear forms.\n\n\nrom.deim.linear_form_hyperrom_deim\nDEIM-based hyperreduction for finite element linear forms.\n\n\nrom.deim.deim\nDiscrete Empirical Interpolation Method (DEIM) for nonlinear ROM acceleration.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#ecsw-hyper-reduction",
    "href": "reference/index.html#ecsw-hyper-reduction",
    "title": "Function reference",
    "section": "",
    "text": "rom.ecsw.bilinear_form_hyperrom_ecsw\nECSW-based hyperreduction for finite element bilinear forms with element clustering.\n\n\nrom.ecsw.linear_form_hyperrom_ecsw\n\n\n\nrom.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nrom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Function reference",
    "section": "",
    "text": "utils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.reduced_basis.svd",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#dynamics",
    "href": "reference/index.html#dynamics",
    "title": "Function reference",
    "section": "",
    "text": "utils.dynamics.integrators",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#visualization",
    "href": "reference/index.html#visualization",
    "title": "Function reference",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette\n\n\n\nutils.visualization.plot_utils",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#templates",
    "href": "reference/index.html#templates",
    "title": "Function reference",
    "section": "",
    "text": "templates.problem_template.bilinear_forms\n\n\n\ntemplates.problem_template.linear_forms\n\n\n\ntemplates.problem_template.params\n\n\n\ntemplates.problem_template.domain\n\n\n\ntemplates.problem_template.problem_def\n\n\n\ntemplates.problem_template.properties",
    "crumbs": [
      "**Documentation**",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/problem_classes.html",
    "href": "reference/problem_classes.html",
    "title": "problem_classes",
    "section": "",
    "text": "problem_classes"
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html",
    "href": "reference/rom.bilinear_form_rom.html",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\nThis module provides: - BilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html#classes",
    "href": "reference/rom.bilinear_form_rom.html#classes",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_matrices\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_matrices(\n    ubasis,\n    vbasis=None,\n    **kwargs,\n)\nExtract local element stiffness matrices for a given bilinear form.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\nBilinearForm\nA bilinear form instance (e.g., one decorated with @BilinearForm).\nrequired\n\n\nubasis\nBasis\nThe finite element basis associated with the trial function.\nrequired\n\n\nvbasis\nBasis\nThe finite element basis associated with the test function. If None, vbasis is set equal to ubasis.\nNone\n\n\nkwargs\ndict\nAdditional keyword arguments to be passed as extra parameters during the assembly process.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray\nA NumPy array of shape (n_elements, Nbfun, Nbfun) containing the local stiffness matrices for each element, where Nbfun is the number of local basis functions per element.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.deim.deim.html",
    "href": "reference/rom.deim.deim.html",
    "title": "rom.deim.deim",
    "section": "",
    "text": "rom.deim.deim\nDiscrete Empirical Interpolation Method (DEIM) for nonlinear ROM acceleration.\nThis module implements DEIM for reducing the dimension of nonlinear force terms in reduced-order models within finite element frameworks. DEIM enables efficient evaluation of nonlinear terms by: - Computing empirical modes from nonlinear force snapshots via SVD - Selecting optimal interpolation points using greedy algorithms - Constructing projection matrices for fast nonlinear term approximation - Mapping selected DOFs to element indicators for efficient assembly\nTL;DR: Dramatically reduces computational cost of nonlinear ROM evaluation by approximating nonlinear terms using interpolation at carefully selected points, achieving significant speedups while maintaining accuracy.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\n\n\n\n\n\nrom.deim.deim.deim(mesh, F_nl, V_sel, tol_f=0.01, extra_modes=0)\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\nTL;DR: Reduces computational cost of nonlinear terms in ROMs by ~1000x through strategic sampling and interpolation, enabling real-time nonlinear PDE solutions.\nThe Discrete Empirical Interpolation Method (DEIM) addresses the computational bottleneck in nonlinear reduced-order models where nonlinear terms must still be evaluated at all degrees of freedom. DEIM constructs an efficient approximation by:\n\nEmpirical Mode Analysis: Computes dominant modes of nonlinear force snapshots using SVD to capture the essential nonlinear behavior patterns.\nOptimal Point Selection: Uses a greedy algorithm to select interpolation points that maximize information content while minimizing approximation error.\nProjection Matrix Construction: Builds a projection matrix that enables fast reconstruction of full nonlinear terms from interpolated values.\nElement Mapping: Maps selected degrees of freedom to finite element indicators for efficient sparse assembly operations.\n\nThe method transforms the nonlinear term evaluation from O(n) to O(m) where m &lt;&lt; n, achieving dramatic computational savings essential for real-time applications.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nFinite element mesh containing connectivity information and node data.\nrequired\n\n\nF_nl\nndarray of shape (n_dofs, n_snapshots)\nSnapshot matrix of nonlinear force evaluations at various parameter values. Each column represents the nonlinear force vector for one parameter instance.\nrequired\n\n\nV_sel\nndarray of shape (n_dofs, n_modes)\nReduced basis matrix from POD, used for solution space projection.\nrequired\n\n\ntol_f\nfloat\nTolerance for SVD mode selection based on singular value decay. Smaller values retain more modes for higher accuracy.\n1e-2\n\n\nextra_modes\nint\nAdditional empirical modes to retain beyond those selected by tolerance criterion, useful for capturing marginal nonlinear effects.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nU_fs\nndarray\nTruncated empirical basis matrix containing selected nonlinear modes.\n\n\ndeim_mat\nndarray\nDEIM projection matrix enabling fast nonlinear term reconstruction: F_nl_approx = V.T @ U_fs @ deim_mat @ F_nl_sampled\n\n\nxi\nndarray of int\nBinary element indicator vector marking which elements contain selected DOFs.\n\n\nn_f_sel\nint\nNumber of empirical modes selected for DEIM approximation.\n\n\n\n\n\n\nDEIM is particularly effective for: - Nonlinear PDEs with localized nonlinear effects - Real-time control applications requiring fast ROM evaluation\n- Problems where nonlinear term evaluation dominates computational cost - Systems with smooth nonlinear behavior amenable to low-rank approximation\nThe method assumes the nonlinear terms can be well-approximated by a low-rank representation, which is typically valid for many physical systems.\n\n\n\n.. [1] Chaturantabut, S. and Sorensen, D.C., 2010. Nonlinear model reduction via discrete empirical interpolation method. SIAM journal on scientific computing, 32(5), pp.2737-2764.\n\n\n\n&gt;&gt;&gt; # Generate nonlinear force snapshots\n&gt;&gt;&gt; F_snapshots = compute_nonlinear_snapshots(problem, param_list)\n&gt;&gt;&gt; # Create DEIM approximation\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, reduced_basis, tol_f=1e-3)\n&gt;&gt;&gt; deim_matrix, sample_points = deim_obj.select_elems()\n&gt;&gt;&gt; # Use in ROM: F_approx = V.T @ U @ deim_matrix @ F_sampled\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim_red\nExecute greedy DEIM algorithm for optimal interpolation point selection.\n\n\nselect_elems\nSelect interpolation points and construct DEIM projection matrix.\n\n\n\n\n\nrom.deim.deim.deim.deim_red(f_basis, num_f_basis_vectors_used)\nExecute greedy DEIM algorithm for optimal interpolation point selection.\nTL;DR: Implements the core greedy algorithm that iteratively selects interpolation points to minimize approximation error in the empirical subspace.\nThe DEIM greedy algorithm works by:\n\nInitial Selection: Chooses the DOF with maximum absolute value in the first empirical mode as the starting interpolation point.\nIterative Refinement: For each subsequent mode, solves for optimal interpolation coefficients using previously selected points, then selects the DOF with maximum residual as the next point.\nResidual Minimization: Each new point is chosen to minimize the approximation error when reconstructing the current empirical mode from previously selected points.\n\nThis greedy strategy ensures that interpolation points capture maximum information content while maintaining numerical stability through well-conditioned interpolation matrices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf_basis\nndarray of shape (n_dofs, n_modes)\nEmpirical basis matrix from SVD of nonlinear force snapshots. Each column represents one empirical mode.\nrequired\n\n\nnum_f_basis_vectors_used\nint\nNumber of empirical modes to use for interpolation point selection. Cannot exceed the total number of available modes.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_basis_sampled\nndarray of shape (num_modes, num_modes)\nSquare matrix containing rows of the empirical basis corresponding to selected interpolation points. Used to construct the projection matrix.\n\n\nsampled_rows\nlist of int\nOrdered list of DOF indices selected as interpolation points. The order reflects the greedy selection sequence.\n\n\n\n\n\n\nThe algorithm ensures that the interpolation matrix f_basis_sampled remains well-conditioned by construction, as each new point is chosen to maximize the residual norm.\nFor problems with strong locality in nonlinear effects, DEIM typically selects points near regions of highest nonlinear activity, leading to physically intuitive sampling patterns.\nThe computational complexity is O(m³) where m is the number of modes, making it efficient even for moderately large empirical subspaces.\n\n\n\n&gt;&gt;&gt; # Empirical basis from SVD  \n&gt;&gt;&gt; U, s, Vt = np.linalg.svd(F_snapshots, full_matrices=False)\n&gt;&gt;&gt; sampled_basis, indices = deim_obj.deim_red(U, n_modes=10)\n&gt;&gt;&gt; print(f\"Condition number: {np.linalg.cond(sampled_basis):.2e}\")\n\n\n\n\nrom.deim.deim.deim.select_elems()\nSelect interpolation points and construct DEIM projection matrix.\nTL;DR: Core DEIM algorithm that identifies optimal sampling points and builds the projection matrix for fast nonlinear term approximation.\nThis method performs the complete DEIM setup:\n\nSVD Analysis: Decomposes nonlinear snapshots to identify dominant empirical modes that capture essential nonlinear behavior patterns.\nMode Selection: Applies tolerance-based truncation with optional extra modes to balance accuracy and computational efficiency.\nPoint Selection: Uses greedy DEIM algorithm to select interpolation points that minimize approximation error in the empirical subspace.\nElement Mapping: Maps selected DOFs to finite element indicators for efficient sparse matrix assembly during online evaluation.\nProjection Construction: Builds the DEIM projection matrix that enables reconstruction: F_full ≈ U_fs @ pinv(U_fs[selected_rows, :]) @ F_sampled\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndeim_mat\nndarray of shape (n_modes, n_selected_points)\nDEIM projection matrix for reconstructing full nonlinear terms from sampled values. Used as: F_approx = V.T @ U_fs @ deim_mat @ F_sampled\n\n\nsampled_rows\nlist of int\nIndices of degrees of freedom selected as DEIM interpolation points. These are the only DOFs where nonlinear terms need evaluation.\n\n\n\n\n\n\nThe projection matrix construction uses the Moore-Penrose pseudoinverse to ensure numerical stability even when the empirical basis is not perfectly conditioned.\nThe element mapping (self.xi) enables efficient assembly by identifying which finite elements contribute to the selected DOFs, allowing sparse matrix operations during online evaluation.\n\n\n\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, basis_matrix)\n&gt;&gt;&gt; proj_matrix, points = deim_obj.select_elems()\n&gt;&gt;&gt; print(f\"Selected {len(points)} points from {F_snapshots.shape[0]} DOFs\")\n&gt;&gt;&gt; print(f\"Reduction ratio: {F_snapshots.shape[0]/len(points):.1f}x\")",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.deim"
    ]
  },
  {
    "objectID": "reference/rom.deim.deim.html#classes",
    "href": "reference/rom.deim.deim.html#classes",
    "title": "rom.deim.deim",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndeim\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\n\n\n\n\n\nrom.deim.deim.deim(mesh, F_nl, V_sel, tol_f=0.01, extra_modes=0)\nDiscrete Empirical Interpolation Method for nonlinear ROM acceleration.\nTL;DR: Reduces computational cost of nonlinear terms in ROMs by ~1000x through strategic sampling and interpolation, enabling real-time nonlinear PDE solutions.\nThe Discrete Empirical Interpolation Method (DEIM) addresses the computational bottleneck in nonlinear reduced-order models where nonlinear terms must still be evaluated at all degrees of freedom. DEIM constructs an efficient approximation by:\n\nEmpirical Mode Analysis: Computes dominant modes of nonlinear force snapshots using SVD to capture the essential nonlinear behavior patterns.\nOptimal Point Selection: Uses a greedy algorithm to select interpolation points that maximize information content while minimizing approximation error.\nProjection Matrix Construction: Builds a projection matrix that enables fast reconstruction of full nonlinear terms from interpolated values.\nElement Mapping: Maps selected degrees of freedom to finite element indicators for efficient sparse assembly operations.\n\nThe method transforms the nonlinear term evaluation from O(n) to O(m) where m &lt;&lt; n, achieving dramatic computational savings essential for real-time applications.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nFinite element mesh containing connectivity information and node data.\nrequired\n\n\nF_nl\nndarray of shape (n_dofs, n_snapshots)\nSnapshot matrix of nonlinear force evaluations at various parameter values. Each column represents the nonlinear force vector for one parameter instance.\nrequired\n\n\nV_sel\nndarray of shape (n_dofs, n_modes)\nReduced basis matrix from POD, used for solution space projection.\nrequired\n\n\ntol_f\nfloat\nTolerance for SVD mode selection based on singular value decay. Smaller values retain more modes for higher accuracy.\n1e-2\n\n\nextra_modes\nint\nAdditional empirical modes to retain beyond those selected by tolerance criterion, useful for capturing marginal nonlinear effects.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nU_fs\nndarray\nTruncated empirical basis matrix containing selected nonlinear modes.\n\n\ndeim_mat\nndarray\nDEIM projection matrix enabling fast nonlinear term reconstruction: F_nl_approx = V.T @ U_fs @ deim_mat @ F_nl_sampled\n\n\nxi\nndarray of int\nBinary element indicator vector marking which elements contain selected DOFs.\n\n\nn_f_sel\nint\nNumber of empirical modes selected for DEIM approximation.\n\n\n\n\n\n\nDEIM is particularly effective for: - Nonlinear PDEs with localized nonlinear effects - Real-time control applications requiring fast ROM evaluation\n- Problems where nonlinear term evaluation dominates computational cost - Systems with smooth nonlinear behavior amenable to low-rank approximation\nThe method assumes the nonlinear terms can be well-approximated by a low-rank representation, which is typically valid for many physical systems.\n\n\n\n.. [1] Chaturantabut, S. and Sorensen, D.C., 2010. Nonlinear model reduction via discrete empirical interpolation method. SIAM journal on scientific computing, 32(5), pp.2737-2764.\n\n\n\n&gt;&gt;&gt; # Generate nonlinear force snapshots\n&gt;&gt;&gt; F_snapshots = compute_nonlinear_snapshots(problem, param_list)\n&gt;&gt;&gt; # Create DEIM approximation\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, reduced_basis, tol_f=1e-3)\n&gt;&gt;&gt; deim_matrix, sample_points = deim_obj.select_elems()\n&gt;&gt;&gt; # Use in ROM: F_approx = V.T @ U @ deim_matrix @ F_sampled\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndeim_red\nExecute greedy DEIM algorithm for optimal interpolation point selection.\n\n\nselect_elems\nSelect interpolation points and construct DEIM projection matrix.\n\n\n\n\n\nrom.deim.deim.deim.deim_red(f_basis, num_f_basis_vectors_used)\nExecute greedy DEIM algorithm for optimal interpolation point selection.\nTL;DR: Implements the core greedy algorithm that iteratively selects interpolation points to minimize approximation error in the empirical subspace.\nThe DEIM greedy algorithm works by:\n\nInitial Selection: Chooses the DOF with maximum absolute value in the first empirical mode as the starting interpolation point.\nIterative Refinement: For each subsequent mode, solves for optimal interpolation coefficients using previously selected points, then selects the DOF with maximum residual as the next point.\nResidual Minimization: Each new point is chosen to minimize the approximation error when reconstructing the current empirical mode from previously selected points.\n\nThis greedy strategy ensures that interpolation points capture maximum information content while maintaining numerical stability through well-conditioned interpolation matrices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf_basis\nndarray of shape (n_dofs, n_modes)\nEmpirical basis matrix from SVD of nonlinear force snapshots. Each column represents one empirical mode.\nrequired\n\n\nnum_f_basis_vectors_used\nint\nNumber of empirical modes to use for interpolation point selection. Cannot exceed the total number of available modes.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_basis_sampled\nndarray of shape (num_modes, num_modes)\nSquare matrix containing rows of the empirical basis corresponding to selected interpolation points. Used to construct the projection matrix.\n\n\nsampled_rows\nlist of int\nOrdered list of DOF indices selected as interpolation points. The order reflects the greedy selection sequence.\n\n\n\n\n\n\nThe algorithm ensures that the interpolation matrix f_basis_sampled remains well-conditioned by construction, as each new point is chosen to maximize the residual norm.\nFor problems with strong locality in nonlinear effects, DEIM typically selects points near regions of highest nonlinear activity, leading to physically intuitive sampling patterns.\nThe computational complexity is O(m³) where m is the number of modes, making it efficient even for moderately large empirical subspaces.\n\n\n\n&gt;&gt;&gt; # Empirical basis from SVD  \n&gt;&gt;&gt; U, s, Vt = np.linalg.svd(F_snapshots, full_matrices=False)\n&gt;&gt;&gt; sampled_basis, indices = deim_obj.deim_red(U, n_modes=10)\n&gt;&gt;&gt; print(f\"Condition number: {np.linalg.cond(sampled_basis):.2e}\")\n\n\n\n\nrom.deim.deim.deim.select_elems()\nSelect interpolation points and construct DEIM projection matrix.\nTL;DR: Core DEIM algorithm that identifies optimal sampling points and builds the projection matrix for fast nonlinear term approximation.\nThis method performs the complete DEIM setup:\n\nSVD Analysis: Decomposes nonlinear snapshots to identify dominant empirical modes that capture essential nonlinear behavior patterns.\nMode Selection: Applies tolerance-based truncation with optional extra modes to balance accuracy and computational efficiency.\nPoint Selection: Uses greedy DEIM algorithm to select interpolation points that minimize approximation error in the empirical subspace.\nElement Mapping: Maps selected DOFs to finite element indicators for efficient sparse matrix assembly during online evaluation.\nProjection Construction: Builds the DEIM projection matrix that enables reconstruction: F_full ≈ U_fs @ pinv(U_fs[selected_rows, :]) @ F_sampled\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndeim_mat\nndarray of shape (n_modes, n_selected_points)\nDEIM projection matrix for reconstructing full nonlinear terms from sampled values. Used as: F_approx = V.T @ U_fs @ deim_mat @ F_sampled\n\n\nsampled_rows\nlist of int\nIndices of degrees of freedom selected as DEIM interpolation points. These are the only DOFs where nonlinear terms need evaluation.\n\n\n\n\n\n\nThe projection matrix construction uses the Moore-Penrose pseudoinverse to ensure numerical stability even when the empirical basis is not perfectly conditioned.\nThe element mapping (self.xi) enables efficient assembly by identifying which finite elements contribute to the selected DOFs, allowing sparse matrix operations during online evaluation.\n\n\n\n&gt;&gt;&gt; deim_obj = deim(mesh, F_snapshots, basis_matrix)\n&gt;&gt;&gt; proj_matrix, points = deim_obj.select_elems()\n&gt;&gt;&gt; print(f\"Selected {len(points)} points from {F_snapshots.shape[0]} DOFs\")\n&gt;&gt;&gt; print(f\"Reduction ratio: {F_snapshots.shape[0]/len(points):.1f}x\")",
    "crumbs": [
      "**Documentation**",
      "DEIM Hyper-Reduction",
      "rom.deim.deim"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "rom.ecsw.bilinear_form_hyperrom_ecsw\nECSW-based hyperreduction for finite element bilinear forms with element clustering.\nThis module provides hyperreduction of bilinear forms using Energy-Conserving Sampling and Weighting (ECSW) combined with intelligent element clustering for efficient reduced-order stiffness assembly. It achieves dramatic computational speedups by: - Clustering elements by number of free DOFs for vectorized operations - Extracting and projecting element stiffness blocks onto reduced bases and weighing them - Assembling global reduced matrices via vectorized Einstein summation\nTL;DR: Enables substantial speedup in bilinear form assembly for ROMs while preserving stability and energy conservation through intelligent element clustering and weighted assembly strategies.\nAuthor: Suparno Bhattacharyya\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through energy-conserving element clustering and weighted sampling, providing both computational efficiency and numerical stability for real-time ROM applications.\nThis class implements a sophisticated hyperreduction strategy that combines Energy-Conserving Sampling and Weighting (ECSW) with intelligent element clustering to achieve massive computational savings while preserving crucial physical properties. The approach works through several key innovations:\nThis hyperreduction is particularly effective for problems where: - Energy conservation is critical (structural dynamics, wave propagation)\n\nElement distributions are relatively uniform (similar local DOF counts)\nComputational stability is paramount for long-time integration\nReal-time performance is required for control or optimization\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept test and trial basis functions and return element-wise stiffness contributions.\nrequired\n\n\nelem_weight\nscalar or array_like of shape (n_elements,)\nElement-wise ECSW weights determining the contribution of each element to the reduced assembly. Can be a single scalar applied to all elements or individual weights per element from ECSW analysis.\nrequired\n\n\nubasis\nBasis\nTrial-space finite element basis containing full DOF count, element connectivity, and quadrature information for the original mesh.\nrequired\n\n\nlob\nndarray of shape (n_free, r) or (n_full, r)\nLeft (test) reduced basis matrix. Shape depends on whether free_dofs is provided - if so, basis is defined only on free DOFs.\nrequired\n\n\nrob\nndarray of shape (n_free, r) or (n_full, r)\nRight (trial) reduced basis matrix with same shape requirements as lob. Projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, all reduced bases and operations are performed only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector for solution centering. Required if snapshot data was mean-subtracted during reduced basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable multi-threaded assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob, rob\nndarray\nLeft and right reduced basis matrices, possibly restricted to free DOFs.\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet boundary conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering and reconstruction.\n\n\nr\nint\nReduced dimension (number of reduced basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices, with Dirichlet DOFs mapped to -1.\n\n\ncluster_idx\nlist of ndarray\nElement indices grouped by number of free DOFs per element. Each entry contains indices of elements with the same free DOF count.\n\n\norder_cluster\nlist of ndarray\nLocal DOF ordering within each cluster for efficient submatrix extraction. Shape: (cluster_size, n_free_dofs_in_cluster).\n\n\nw_cluster\nlist of ndarray\nECSW weights corresponding to elements in each cluster.\n\n\nR_test_free, R_trial_free\nlist of ndarray\nTest and trial basis matrices restricted to free DOFs for each cluster. Shape: (cluster_size, n_free_dofs, r).\n\n\nunique_freedom\nndarray of int\nUnique counts of free DOFs per element, determining the number of clusters.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix using ECSW.\n\n\nextract_element_matrices_rom\nExtract element stiffness matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix using ECSW.\nTL;DR: Main assembly method that orchestrates element clustering, vectorized stiffness extraction, ECSW weighting, and reduced basis projection to produce the final r×r reduced-order stiffness matrix.\nThis method performs the complete ECSW hyperreduction assembly process through a sophisticated multi-stage algorithm:\n\nElement Matrix Extraction: Calls element extraction routines to compute local stiffness matrices for all active elements, leveraging parallel processing when available.\nCluster-Based Processing: Processes elements in clusters based on their free DOF count, enabling highly efficient vectorized operations and eliminating expensive Python loops.\nSubmatrix Extraction: For each cluster, extracts the free DOF submatrices from local element matrices using advanced NumPy indexing for maximum efficiency.\nECSW Weighting: Applies energy-conserving weights to preserve physical properties while enabling computational reduction.\nVectorized Contraction: Uses Einstein summation to perform parallel contractions over entire clusters: A_reduced += Σ_e R_test[e]^T @ (w[e] * K_local[e]) @ R_trial[e]\n\nThe final result preserves the mathematical structure of the full-order operator while achieving dramatic computational savings through intelligent clustering and vectorization strategies.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to element extraction routines for controlling assembly behavior, such as material parameters or quadrature settings.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\nndarray of shape (r, r)\nAssembled reduced-order stiffness matrix ready for use in ROM systems. This matrix preserves the energy conservation properties of the full-order operator while enabling real-time evaluation.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element stiffness matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for ECSW-weighted global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost while maintaining accuracy through ECSW weighting.\nThe method supports both execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and integration uses the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "href": "reference/rom.ecsw.bilinear_form_hyperrom_ecsw.html#classes",
    "title": "rom.ecsw.bilinear_form_hyperrom_ecsw",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM_ecsw\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nECSW-based hyperreduced bilinear form with element clustering for efficient assembly.\nTL;DR: Dramatically accelerates bilinear form assembly by ~1000x through energy-conserving element clustering and weighted sampling, providing both computational efficiency and numerical stability for real-time ROM applications.\nThis class implements a sophisticated hyperreduction strategy that combines Energy-Conserving Sampling and Weighting (ECSW) with intelligent element clustering to achieve massive computational savings while preserving crucial physical properties. The approach works through several key innovations:\nThis hyperreduction is particularly effective for problems where: - Energy conservation is critical (structural dynamics, wave propagation)\n\nElement distributions are relatively uniform (similar local DOF counts)\nComputational stability is paramount for long-time integration\nReal-time performance is required for control or optimization\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function to be hyperreduced. Should accept test and trial basis functions and return element-wise stiffness contributions.\nrequired\n\n\nelem_weight\nscalar or array_like of shape (n_elements,)\nElement-wise ECSW weights determining the contribution of each element to the reduced assembly. Can be a single scalar applied to all elements or individual weights per element from ECSW analysis.\nrequired\n\n\nubasis\nBasis\nTrial-space finite element basis containing full DOF count, element connectivity, and quadrature information for the original mesh.\nrequired\n\n\nlob\nndarray of shape (n_free, r) or (n_full, r)\nLeft (test) reduced basis matrix. Shape depends on whether free_dofs is provided - if so, basis is defined only on free DOFs.\nrequired\n\n\nrob\nndarray of shape (n_free, r) or (n_full, r)\nRight (trial) reduced basis matrix with same shape requirements as lob. Projects full-order solutions to the r-dimensional reduced space.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, all reduced bases and operations are performed only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector for solution centering. Required if snapshot data was mean-subtracted during reduced basis construction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element matrix extraction. Zero means serial execution, positive values enable multi-threaded assembly.\n0\n\n\ndtype\nnumpy.dtype\nNumerical precision for all computations and storage arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob, rob\nndarray\nLeft and right reduced basis matrices, possibly restricted to free DOFs.\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet boundary conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering and reconstruction.\n\n\nr\nint\nReduced dimension (number of reduced basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices, with Dirichlet DOFs mapped to -1.\n\n\ncluster_idx\nlist of ndarray\nElement indices grouped by number of free DOFs per element. Each entry contains indices of elements with the same free DOF count.\n\n\norder_cluster\nlist of ndarray\nLocal DOF ordering within each cluster for efficient submatrix extraction. Shape: (cluster_size, n_free_dofs_in_cluster).\n\n\nw_cluster\nlist of ndarray\nECSW weights corresponding to elements in each cluster.\n\n\nR_test_free, R_trial_free\nlist of ndarray\nTest and trial basis matrices restricted to free DOFs for each cluster. Shape: (cluster_size, n_free_dofs, r).\n\n\nunique_freedom\nndarray of int\nUnique counts of free DOFs per element, determining the number of clusters.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted_ecsw\nAssemble the globally weighted reduced stiffness matrix using ECSW.\n\n\nextract_element_matrices_rom\nExtract element stiffness matrices for hyperreduced mesh assembly.\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.assemble_weighted_ecsw(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix using ECSW.\nTL;DR: Main assembly method that orchestrates element clustering, vectorized stiffness extraction, ECSW weighting, and reduced basis projection to produce the final r×r reduced-order stiffness matrix.\nThis method performs the complete ECSW hyperreduction assembly process through a sophisticated multi-stage algorithm:\n\nElement Matrix Extraction: Calls element extraction routines to compute local stiffness matrices for all active elements, leveraging parallel processing when available.\nCluster-Based Processing: Processes elements in clusters based on their free DOF count, enabling highly efficient vectorized operations and eliminating expensive Python loops.\nSubmatrix Extraction: For each cluster, extracts the free DOF submatrices from local element matrices using advanced NumPy indexing for maximum efficiency.\nECSW Weighting: Applies energy-conserving weights to preserve physical properties while enabling computational reduction.\nVectorized Contraction: Uses Einstein summation to perform parallel contractions over entire clusters: A_reduced += Σ_e R_test[e]^T @ (w[e] * K_local[e]) @ R_trial[e]\n\nThe final result preserves the mathematical structure of the full-order operator while achieving dramatic computational savings through intelligent clustering and vectorization strategies.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to element extraction routines for controlling assembly behavior, such as material parameters or quadrature settings.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\nndarray of shape (r, r)\nAssembled reduced-order stiffness matrix ready for use in ROM systems. This matrix preserves the energy conservation properties of the full-order operator while enabling real-time evaluation.\n\n\n\n\n\n\n\nrom.ecsw.bilinear_form_hyperrom_ecsw.BilinearFormHYPERROM_ecsw.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract element stiffness matrices for hyperreduced mesh assembly.\nTL;DR: Computes local element stiffness matrices for the reduced element set using either serial or parallel execution, providing the fundamental building blocks for ECSW-weighted global assembly.\nThis method performs the core finite element integration to compute element-level contributions to the global bilinear form. The integration is performed only over elements selected by the hyperreduction strategy, dramatically reducing computational cost while maintaining accuracy through ECSW weighting.\nThe method supports both execution modes: - Serial Mode (nthreads=0): Sequential element-by-element computation - Parallel Mode (nthreads&gt;0): Multi-threaded parallel element processing\nFor each element, the method evaluates the bilinear form: K_e[i,j] = ∫_Ω_e φ_i(x) * form * φ_j(x) dx\nwhere φ_i, φ_j are basis functions and integration uses the quadrature rules embedded in the finite element basis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis containing mesh connectivity, quadrature points, and basis function evaluations.\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis. If None, defaults to ubasis for standard Galerkin formulations.\nNone\n\n\nelem_indices\narray_like of int\nSpecific element indices to include in extraction. If None, processes all elements in the hyperreduced mesh.\nNone\n\n\n**kwargs\ndict\nAdditional keyword arguments passed to the bilinear form evaluation, such as material parameters or other problem-specific data.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\nndarray of shape (n_elements, n_local_dofs, n_local_dofs)\nArray of local element stiffness matrices. Each element_matrices[e] contains the n_local_dofs × n_local_dofs stiffness matrix for element e.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial and test bases have incompatible quadrature point counts, indicating a mismatch in integration rules.",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.bilinear_form_hyperrom_ecsw"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html",
    "href": "reference/rom.ecsw.hyperreduce.html",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "rom.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n[Code: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.hyperreduce.html#functions",
    "href": "reference/rom.ecsw.hyperreduce.html#functions",
    "title": "rom.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nrom.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "**Documentation**",
      "ECSW Hyper-Reduction",
      "rom.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/rom.ecsw.html",
    "href": "reference/rom.ecsw.html",
    "title": "rom.ecsw",
    "section": "",
    "text": "rom.ecsw\nThe ecsw folder implements Empirical Cubature Subset Weighting (ECSW) methods.\nContents: - nnls_solver.py: Active‐set bounded NNLS solver (NNLSSolver) with L₂/L∞ criteria for computing nonnegative cubature weights under per-entry bounds. - Utilities for convergence testing (NNLS_termination), argument verification, and solver configuration.\nTogether, these tools select and weight integration points to approximate high‐dimensional integrals with a sparse subset, enabling efficient reduced‐order model assembly."
  },
  {
    "objectID": "reference/rom.linear_form_rom.html",
    "href": "reference/rom.linear_form_rom.html",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "rom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\nThis module provides: - LinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html#classes",
    "href": "reference/rom.linear_form_rom.html#classes",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html",
    "href": "reference/rom.rom_error_est.html",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "rom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\nThis module provides: - compute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm). - plot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up. - generate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console.\nThe rom folder contains core tools for reduced-order modeling, including: - Assembly abstractions for reduced bilinear and linear forms - Error evaluation and reporting utilities (this module) - Hyper-reduction and cubature integration tools\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html#functions",
    "href": "reference/rom.rom_error_est.html#functions",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "**Documentation**",
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.bilinear_forms.html",
    "href": "reference/templates.problem_template.bilinear_forms.html",
    "title": "templates.problem_template.bilinear_forms",
    "section": "",
    "text": "templates.problem_template.bilinear_forms\n\n\n\n\n\nName\nDescription\n\n\n\n\na\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver):\n\n\n\n\n\ntemplates.problem_template.bilinear_forms.a(u, v, w)\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver): ∫_Ω [your integrand here] dx\n\n\nu : array_like or callable Trial (or current Newton iterate) values at quadrature points. v : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for global matrix assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the Jacobian matrix.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.bilinear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.bilinear_forms.html#functions",
    "href": "reference/templates.problem_template.bilinear_forms.html#functions",
    "title": "templates.problem_template.bilinear_forms",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\na\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver):\n\n\n\n\n\ntemplates.problem_template.bilinear_forms.a(u, v, w)\nTemplate for your problem’s bilinear form (or Jacobian in a nonlinear solver): ∫_Ω [your integrand here] dx\n\n\nu : array_like or callable Trial (or current Newton iterate) values at quadrature points. v : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for global matrix assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the Jacobian matrix.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.bilinear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.linear_forms.html",
    "href": "reference/templates.problem_template.linear_forms.html",
    "title": "templates.problem_template.linear_forms",
    "section": "",
    "text": "templates.problem_template.linear_forms\n\n\n\n\n\nName\nDescription\n\n\n\n\nl\nTemplate for your problem’s linear (load or residual) form:\n\n\n\n\n\ntemplates.problem_template.linear_forms.l(v, w)\nTemplate for your problem’s linear (load or residual) form: ∫_Ω [your integrand here] dx\n\n\nv : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for right-hand side vector assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the residual vector.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.linear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.linear_forms.html#functions",
    "href": "reference/templates.problem_template.linear_forms.html#functions",
    "title": "templates.problem_template.linear_forms",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nl\nTemplate for your problem’s linear (load or residual) form:\n\n\n\n\n\ntemplates.problem_template.linear_forms.l(v, w)\nTemplate for your problem’s linear (load or residual) form: ∫_Ω [your integrand here] dx\n\n\nv : array_like or callable Test function values at quadrature points. w : dict Assembly context carrying any coefficients or parameters.\n\n\n\narray_like or float Elementwise integrand for right-hand side vector assembly.\n\n\n\nIn a nonlinear problem solved by Newton’s method, this form assembles the residual vector.",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.linear_forms"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.problem_def.html",
    "href": "reference/templates.problem_template.problem_def.html",
    "title": "templates.problem_template.problem_def",
    "section": "",
    "text": "templates.problem_template.problem_def\n\n\n\n\n\nName\nDescription\n\n\n\n\nProblemTemplate\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate()\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nImport element-level bilinear (or Jacobian) forms from\n\n\ndomain\nImport domain information from domain.py in the local directory.\n\n\nfom_operators\nAssemble (and cache) full-order operators (e.g. stiffness, mass)\n\n\nfom_rhs\nAssemble (and cache) the full-order RHS vector consumed by\n\n\nfom_solver\nSolve the high-fidelity model for one parameter point.\n\n\nhyper_rom_operators_deim\nCompute operators (interpolation indices, projection matrices, …)\n\n\nhyper_rom_operators_ecsw\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\nhyper_rom_solver_deim\nSolve the DEIM hyper-reduced model.\n\n\nhyper_rom_solver_ecsw\nSolve the ECSW hyper-reduced model.\n\n\nlinear_forms\nImport element-level linear / residual forms from linear_forms.py.\n\n\nparameters\nImport a sampling-design generator from params.py. The helper\n\n\nproperties\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from\n\n\nreduced_operators\nProject FOM operators onto the reduced basis so rom_solver can work\n\n\nrom_solver\nSolve the reduced-order model and reconstruct the high-dimensional\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.bilinear_forms()\nImport element-level bilinear (or Jacobian) forms from bilinear_forms.py. Nothing is assembled here – we merely hand back the callables.\n\n\n\n\n\nfrom bilinear_forms import a1, a2 return [a1, a2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.domain()\nImport domain information from domain.py in the local directory. No geometry is built here – we simply delegate to domain_.\n\n\n\n\n\nfrom domain import domain_ return domain_()\n\n\n\nRequired keys (but not limited to) in the returned dict: * ‘mesh’, ‘basis’ * ‘free_dofs’, ‘dirichlet_dofs’, ‘dirichlet_value’\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_operators(cls)\nAssemble (and cache) full-order operators (e.g. stiffness, mass) used by fom_solver.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nRuntime-state container injected by the master class. Provides simulation metadata such as cls.cur_itr (current sample), solver tolerances, logging utilities, etc.\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_rhs(cls)\nAssemble (and cache) the full-order RHS vector consumed by fom_solver and hyper-reduction routines.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nSimulation context (see fom_operators docstring).\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_solver(cls, param)\nSolve the high-fidelity model for one parameter point.\nCalled automatically by the master class when a simulation is run.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nContains run-time info such as cls.cur_itr.\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ at which to solve.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfull_solution\nndarray\n\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_deim(\n    cls,\n    param,\n)\nCompute operators (interpolation indices, projection matrices, …) for the DEIM method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_ecsw(\n    cls,\n    param,\n)\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_deim(\n    cls,\n    param,\n)\nSolve the DEIM hyper-reduced model.\nCalled automatically by the master class when a DEIM-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_ecsw(\n    cls,\n    param,\n)\nSolve the ECSW hyper-reduced model.\nCalled automatically by the master class when an ECSW-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.linear_forms()\nImport element-level linear / residual forms from linear_forms.py. No assembly happens here – we just return the callables.\n\n\n\n\n\nfrom linear_forms import f1, f2 return [f1, f2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.parameters(n_samples)\nImport a sampling-design generator from params.py. The helper function constructs training / test parameter sets.\n\n\n\n\n\nfrom params import parameters return parameters(n_samples)\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.properties()\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from properties.py located in the same folder.\n\n\n\n\n\nfrom properties import k_func, q_func return [k_func, q_func]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.reduced_operators(\n    cls,\n    param,\n)\nProject FOM operators onto the reduced basis so rom_solver can work in a low-dimensional space.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.rom_solver(cls, param)\nSolve the reduced-order model and reconstruct the high-dimensional field.\nCalled automatically by the master class during a simulation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nGives access to run-time metadata (e.g. cls.cur_itr).\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nu_red\nu_red – parameter-scaled modal coefficients",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.problem_def"
    ]
  },
  {
    "objectID": "reference/templates.problem_template.problem_def.html#classes",
    "href": "reference/templates.problem_template.problem_def.html#classes",
    "title": "templates.problem_template.problem_def",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nProblemTemplate\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate()\nTemplate for an affine or non-linear reduced-order-model (ROM) problem.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbilinear_forms\nImport element-level bilinear (or Jacobian) forms from\n\n\ndomain\nImport domain information from domain.py in the local directory.\n\n\nfom_operators\nAssemble (and cache) full-order operators (e.g. stiffness, mass)\n\n\nfom_rhs\nAssemble (and cache) the full-order RHS vector consumed by\n\n\nfom_solver\nSolve the high-fidelity model for one parameter point.\n\n\nhyper_rom_operators_deim\nCompute operators (interpolation indices, projection matrices, …)\n\n\nhyper_rom_operators_ecsw\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\nhyper_rom_solver_deim\nSolve the DEIM hyper-reduced model.\n\n\nhyper_rom_solver_ecsw\nSolve the ECSW hyper-reduced model.\n\n\nlinear_forms\nImport element-level linear / residual forms from linear_forms.py.\n\n\nparameters\nImport a sampling-design generator from params.py. The helper\n\n\nproperties\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from\n\n\nreduced_operators\nProject FOM operators onto the reduced basis so rom_solver can work\n\n\nrom_solver\nSolve the reduced-order model and reconstruct the high-dimensional\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.bilinear_forms()\nImport element-level bilinear (or Jacobian) forms from bilinear_forms.py. Nothing is assembled here – we merely hand back the callables.\n\n\n\n\n\nfrom bilinear_forms import a1, a2 return [a1, a2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.domain()\nImport domain information from domain.py in the local directory. No geometry is built here – we simply delegate to domain_.\n\n\n\n\n\nfrom domain import domain_ return domain_()\n\n\n\nRequired keys (but not limited to) in the returned dict: * ‘mesh’, ‘basis’ * ‘free_dofs’, ‘dirichlet_dofs’, ‘dirichlet_value’\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_operators(cls)\nAssemble (and cache) full-order operators (e.g. stiffness, mass) used by fom_solver.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nRuntime-state container injected by the master class. Provides simulation metadata such as cls.cur_itr (current sample), solver tolerances, logging utilities, etc.\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_rhs(cls)\nAssemble (and cache) the full-order RHS vector consumed by fom_solver and hyper-reduction routines.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nSimulation context (see fom_operators docstring).\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.fom_solver(cls, param)\nSolve the high-fidelity model for one parameter point.\nCalled automatically by the master class when a simulation is run.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nContains run-time info such as cls.cur_itr.\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ at which to solve.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfull_solution\nndarray\n\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_deim(\n    cls,\n    param,\n)\nCompute operators (interpolation indices, projection matrices, …) for the DEIM method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_operators_ecsw(\n    cls,\n    param,\n)\nCompute operators (sampling matrices, weights, …) for the ECSW method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_deim(\n    cls,\n    param,\n)\nSolve the DEIM hyper-reduced model.\nCalled automatically by the master class when a DEIM-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.hyper_rom_solver_ecsw(\n    cls,\n    param,\n)\nSolve the ECSW hyper-reduced model.\nCalled automatically by the master class when an ECSW-based simulation is executed.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.linear_forms()\nImport element-level linear / residual forms from linear_forms.py. No assembly happens here – we just return the callables.\n\n\n\n\n\nfrom linear_forms import f1, f2 return [f1, f2]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.parameters(n_samples)\nImport a sampling-design generator from params.py. The helper function constructs training / test parameter sets.\n\n\n\n\n\nfrom params import parameters return parameters(n_samples)\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.properties()\nImport coefficient-generating functions (e.g. k(μ), q(β), …) from properties.py located in the same folder.\n\n\n\n\n\nfrom properties import k_func, q_func return [k_func, q_func]\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.reduced_operators(\n    cls,\n    param,\n)\nProject FOM operators onto the reduced basis so rom_solver can work in a low-dimensional space.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object – simulation context\n\nrequired\n\n\nparam\nndarray or scalar – parameter vector/value μ\n\nrequired\n\n\n\n\n\n\n\ntemplates.problem_template.problem_def.ProblemTemplate.rom_solver(cls, param)\nSolve the reduced-order model and reconstruct the high-dimensional field.\nCalled automatically by the master class during a simulation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncls\nmaster_class object\nGives access to run-time metadata (e.g. cls.cur_itr).\nrequired\n\n\nparam\nndarray or scalar\nParameter vector/value μ.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nu_red\nu_red – parameter-scaled modal coefficients",
    "crumbs": [
      "**Documentation**",
      "Templates",
      "templates.problem_template.problem_def"
    ]
  },
  {
    "objectID": "reference/utils.basic.html",
    "href": "reference/utils.basic.html",
    "title": "utils.basic",
    "section": "",
    "text": "utils.basic\nutils.basic\nThis module imports essential libraries commonly used in pyHyperRom. By using from pyHyperRom.basic import *, users can access frequently utilized libraries."
  },
  {
    "objectID": "reference/utils.custom_nnls.html",
    "href": "reference/utils.custom_nnls.html",
    "title": "utils.custom_nnls",
    "section": "",
    "text": "utils.custom_nnls\nutils.custom_nnls"
  },
  {
    "objectID": "reference/utils.dynamics.newmark_beta.html",
    "href": "reference/utils.dynamics.newmark_beta.html",
    "title": "utils.dynamics.newmark_beta",
    "section": "",
    "text": "utils.dynamics.newmark_beta\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\n\n\n\nutils.dynamics.newmark_beta.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i]."
  },
  {
    "objectID": "reference/utils.dynamics.newmark_beta.html#functions",
    "href": "reference/utils.dynamics.newmark_beta.html#functions",
    "title": "utils.dynamics.newmark_beta",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewmark_with_damping\nNewmark-β integrator with Rayleigh damping C.\n\n\n\n\n\nutils.dynamics.newmark_beta.newmark_with_damping(\n    M,\n    C,\n    K,\n    force_free,\n    times,\n    U0=None,\n    V0=None,\n    beta=0.25,\n    gamma=0.5,\n)\nNewmark-β integrator with Rayleigh damping C. Uses copies of input matrices to avoid side effects. force_free(i, times) must return the load vector at times[i]."
  },
  {
    "objectID": "reference/utils.fem_utils.html",
    "href": "reference/utils.fem_utils.html",
    "title": "utils.fem_utils",
    "section": "",
    "text": "utils.fem_utils\nutils.fem_utils"
  },
  {
    "objectID": "reference/utils.newton_solver.html",
    "href": "reference/utils.newton_solver.html",
    "title": "utils.newton_solver",
    "section": "",
    "text": "utils.newton_solver\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.newton_solver.html#functions",
    "href": "reference/utils.newton_solver.html#functions",
    "title": "utils.newton_solver",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching."
  },
  {
    "objectID": "reference/utils.html",
    "href": "reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils"
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html",
    "href": "reference/utils.reduced_basis.svd.html",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "utils.reduced_basis.svd\n\n\n\n\n\nName\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html#functions",
    "href": "reference/utils.reduced_basis.svd.html#functions",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.rom_utils.html",
    "href": "reference/utils.rom_utils.html",
    "title": "utils.rom_utils",
    "section": "",
    "text": "utils.rom_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.rom_utils.html#functions",
    "href": "reference/utils.rom_utils.html#functions",
    "title": "utils.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis."
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html",
    "href": "reference/utils.visualization.generate_vtk.html",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html#functions",
    "href": "reference/utils.visualization.generate_vtk.html#functions",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\nsave_vtk_solution\nWrite a single solution vector to a VTK file.\n\n\nsave_vtk_time_series\nWrite one VTK per time-step and a .pvd that collects them.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_solution(\n    u,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n    split_dim=False,\n)\nWrite a single solution vector to a VTK file.\nApplies a translation to the mesh based on displacement values and saves the resulting geometry along with point data fields.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nDisplacement vector of length matching the mesh degrees of freedom.\nrequired\n\n\nmesh\nobject\nMesh object supporting translated(displacements) to return a new mesh and save(path, point_data=...) to write VTK files.\nrequired\n\n\nbasis\nobject\nBasis object containing attribute nodal_dofs, an integer array indexing into the global solution vector for nodal degrees of freedom.\nrequired\n\n\nscale\nfloat\nScalar multiplier applied to the displacement values before translation.\nrequired\n\n\nrun_dir\npathlib.Path\nDirectory in which the .vtk file will be created.\nrequired\n\n\nprefix\nstr\nFilename prefix (e.g., “test_sol_fos”).\nrequired\n\n\nsplit_dim\nbool\nIf True, splits the displacement into separate scalar fields (u_x, u_y, and u_z for 3D) in the VTK output; otherwise writes a single vector field u.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n[Author: Suparno Bhattacharyya]\n\n\n\n\n\n\n\n\nutils.visualization.generate_vtk.save_vtk_time_series(\n    U,\n    times,\n    mesh,\n    basis,\n    scale,\n    run_dir,\n    prefix,\n)\nWrite one VTK per time-step and a .pvd that collects them.\nU : full displacement history times : time vector mesh : skfem mesh basis : skfem basis scale : displacement scale run_dir: output directory prefix : file prefix, e.g. “beam”\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.plot_utils.html",
    "href": "reference/utils.visualization.plot_utils.html",
    "title": "utils.visualization.plot_utils",
    "section": "",
    "text": "utils.visualization.plot_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\nplot_deim_weights\nCreate a stem plot of xi with a zoomed inset.\n\n\nplot_ecsw_weights_3d\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\nutils.visualization.plot_utils.plot_deim_weights(\n    xi,\n    zoom_indices=(0, 1),\n    figsize=(12, 3),\n    nbins=6,\n    line_color='#163e64',\n    stem_color='#a6a6a6',\n    zoom_loc='upper left',\n    zoom_size=('25%', '40%'),\n    zoom_title='Zoomed-in view',\n    zoom_box_offset_x=-0.5,\n    zoom_box_offset_y=-0.2,\n    zoom_box_width=1.0,\n    zoom_box_height_scale=0.4,\n    zoom_box_color='red',\n    zoom_box_linestyle='--',\n    zoom_box_linewidth=1.0,\n)\nCreate a stem plot of xi with a zoomed inset. Uses constrained_layout for automatic spacing.\n\n\n\nutils.visualization.plot_utils.plot_ecsw_weights_3d(\n    mesh,\n    weights,\n    projection='3d',\n    plane='xy',\n    figsize=(8, 6),\n    cmap='viridis',\n    zero_color='#eeeeee',\n    zero_alpha=0.3,\n    weight_threshold=0.001,\n)\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh with attributes: - p: array of shape (3, n_nodes) for node coords. - t: array of shape (nodes_per_elem, n_elems).\nrequired\n\n\nweights\n1D ndarray of length n_elems\nECSW weight per element.\nrequired\n\n\nprojection\n'3d' or projected\n‘3d’ = scatter in 3D; ‘projected’ = heatmap on a plane.\n'3d'\n\n\nplane\n'xy', 'xz', or 'yz'\nwhich plane to project onto if projected.\n'xy'\n\n\nfigsize\nfigure size.\n\n(8, 6)\n\n\ncmap\nname of colormap for &gt;threshold weights.\n\n'viridis'\n\n\nzero_color\ncolor for weights ≤ threshold.\n\n'#eeeeee'\n\n\nzero_alpha\nalpha for zero_color points.\n\n0.3\n\n\nweight_threshold\nfloat\nany w ≤ this will be considered “zero” for display.\n0.001\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fig, ax)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.plot_utils"
    ]
  },
  {
    "objectID": "reference/utils.visualization.plot_utils.html#functions",
    "href": "reference/utils.visualization.plot_utils.html#functions",
    "title": "utils.visualization.plot_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nplot_deim_weights\nCreate a stem plot of xi with a zoomed inset.\n\n\nplot_ecsw_weights_3d\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\nutils.visualization.plot_utils.plot_deim_weights(\n    xi,\n    zoom_indices=(0, 1),\n    figsize=(12, 3),\n    nbins=6,\n    line_color='#163e64',\n    stem_color='#a6a6a6',\n    zoom_loc='upper left',\n    zoom_size=('25%', '40%'),\n    zoom_title='Zoomed-in view',\n    zoom_box_offset_x=-0.5,\n    zoom_box_offset_y=-0.2,\n    zoom_box_width=1.0,\n    zoom_box_height_scale=0.4,\n    zoom_box_color='red',\n    zoom_box_linestyle='--',\n    zoom_box_linewidth=1.0,\n)\nCreate a stem plot of xi with a zoomed inset. Uses constrained_layout for automatic spacing.\n\n\n\nutils.visualization.plot_utils.plot_ecsw_weights_3d(\n    mesh,\n    weights,\n    projection='3d',\n    plane='xy',\n    figsize=(8, 6),\n    cmap='viridis',\n    zero_color='#eeeeee',\n    zero_alpha=0.3,\n    weight_threshold=0.001,\n)\nVisualize ECSW weights on a 3D mesh, fading out near-zero weights.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh with attributes: - p: array of shape (3, n_nodes) for node coords. - t: array of shape (nodes_per_elem, n_elems).\nrequired\n\n\nweights\n1D ndarray of length n_elems\nECSW weight per element.\nrequired\n\n\nprojection\n'3d' or projected\n‘3d’ = scatter in 3D; ‘projected’ = heatmap on a plane.\n'3d'\n\n\nplane\n'xy', 'xz', or 'yz'\nwhich plane to project onto if projected.\n'xy'\n\n\nfigsize\nfigure size.\n\n(8, 6)\n\n\ncmap\nname of colormap for &gt;threshold weights.\n\n'viridis'\n\n\nzero_color\ncolor for weights ≤ threshold.\n\n'#eeeeee'\n\n\nzero_alpha\nalpha for zero_color points.\n\n0.3\n\n\nweight_threshold\nfloat\nany w ≤ this will be considered “zero” for display.\n0.001\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fig, ax)",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.plot_utils"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html",
    "href": "reference/utils.visualization.vtuwriter.html",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "utils.visualization.vtuwriter\n\n\n\n\n\nName\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html#classes",
    "href": "reference/utils.visualization.vtuwriter.html#classes",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n[Author: Suparno Bhattacharyya]\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)\n[Author: Suparno Bhattacharyya]",
    "crumbs": [
      "**Documentation**",
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html",
    "href": "Resources/intro/rom_intro_ex.html",
    "title": "SCIKIT-ROM",
    "section": "",
    "text": "Reduced-order modeling (ROM) is a computational technique that creates fast approximations of high-fidelity numerical models. Instead of solving large systems of equations with millions of degrees of freedom, ROM constructs a low-dimensional representation that captures the essential physics while being orders of magnitude faster to evaluate.\nThe key insight is that many physical systems exhibit low-dimensional behavior even when discretized on fine meshes. By identifying the dominant modes of the system’s response through techniques like Proper Orthogonal Decomposition (POD), we can build efficient surrogate models that maintain high accuracy."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#one-dimensional-steady-state-heat-conduction-finite-element-and-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling",
    "text": "One-Dimensional Steady-State Heat Conduction: Finite Element and Reduced-Order Modeling\nWe consider the boundary value problem\n\\[\n- \\frac{d}{dx}\\left(k\\,\\frac{dT}{dx}\\right) = q, \\quad x \\in [0, L],\n\\]\nsubject to the boundary conditions:\n\nNeumann: \\(\\left. \\dfrac{dT}{dx} \\right|_{x=0} = 0\\),\nDirichlet: \\(T(L) = T_L\\),\n\nwhere the material parameters are defined as:\n\\[\nk = 16 + \\mu, \\qquad q = 35000 + \\beta,\n\\]\nwith \\(\\mu\\) and \\(\\beta\\) denoting input parameters.\n\n\nWeak Formulation\nMultiplying the governing equation by a test function \\(v \\in V\\) that vanishes at \\(x = L\\), and integrating over the domain yields the weak form:\n\\[\n\\int_0^L k \\frac{dT}{dx} \\frac{dv}{dx} \\, dx = \\int_0^L q\\,v(x)\\, dx.\n\\]\n\n\n\nFinite Element Discretization\nDiscretize the interval \\([0, L]\\) into \\(N\\) uniform linear elements of length \\(h = L / N\\). Approximate the solution as:\n\\[\nT_h(x) = \\sum_{j=1}^{n} T_j \\phi_j(x),\n\\]\nwhere \\(\\phi_j(x)\\) are piecewise linear basis functions, and \\(T_j\\) are the nodal temperatures. Choosing \\(v = \\phi_i(x)\\) leads to the discrete form:\n\\[\n\\sum_{j=1}^{n} T_j \\int_0^L k \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx = \\int_0^L q\\, \\phi_i(x) \\, dx.\n\\]\nThe global system can be written as:\n\\[\n\\mathbf{K} \\mathbf{T} = \\mathbf{F},\n\\]\nwith\n\n\\(K_{ij} = \\int_0^L k, \\dfrac{d\\phi_j}{dx} \\dfrac{d\\phi_i}{dx} , dx\\) (stiffness matrix),\n\\(F_i = \\int_0^L q, \\phi_i(x) , dx\\) (load vector),\n\\(\\mathbf{T} = [T_1, \\dots, T_n]^\\top\\) (nodal temperatures).\n\nOn each element, the local contributions are:\n\nStiffness matrix:\n\\[\n\\mathbf{K}^{(e)} = \\frac{k}{h}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix},\n\\]\nLoad vector:\n\\[\n\\mathbf{F}^{(e)} = \\frac{q h}{2}\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}.\n\\]\n\nThe Neumann condition at \\(x = 0\\) is naturally satisfied. The Dirichlet condition \\(T(L) = T_L\\) is imposed directly on the final equation.\n\n\n\nAnalytical Reference Solution\nFor constant \\(k\\) and \\(q\\), the exact solution is:\n\\[\nT(x) = T_L + \\frac{q}{2k}(L^2 - x^2),\n\\]\nwhich provides a useful reference for numerical verification."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "href": "Resources/intro/rom_intro_ex.html#motivation-for-reduced-order-modeling",
    "title": "SCIKIT-ROM",
    "section": "Motivation for Reduced-Order Modeling",
    "text": "Motivation for Reduced-Order Modeling\nWhen evaluating \\(\\mathbf{T}\\) for multiple parameter pairs \\((\\mu, \\beta)\\), solving the full system \\(\\mathbf{K} \\mathbf{T} = \\mathbf{F}\\) repeatedly becomes computationally expensive. This challenge arises in applications such as parameter studies, optimization loops, or real-time simulation.\nReduced-order modeling (ROM) mitigates this cost by projecting the full system onto a lower-dimensional subspace, enabling rapid evaluation with minimal accuracy loss. The approach involves:\n\nAn offline phase where representative solutions (“snapshots”) are collected and used to construct a low-dimensional basis,\nAn online phase where the system is solved in the reduced space, avoiding expensive computations at full resolution.\n\nIn problems with affine parameter dependence, the ROM can be formulated such that no linear solves are required in the online stage, making it suitable for many-query scenarios."
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "href": "Resources/intro/rom_intro_ex.html#affine-reduced-order-modeling-rom",
    "title": "SCIKIT-ROM",
    "section": "Affine Reduced-Order Modeling (ROM)",
    "text": "Affine Reduced-Order Modeling (ROM)\nWe approximate the full-order solution using a reduced affine expansion:\n\\[\n\\mathbf{T} \\approx \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a},\n\\]\nwhere:\n\n\\(\\mathbf{T}_{\\text{mean}} \\in \\mathbb{R}^N\\) is the mean of collected snapshots,\n\\(\\mathbf{U} \\in \\mathbb{R}^{N \\times r}\\) is the reduced basis (e.g., from POD),\n\\(\\mathbf{a} \\in \\mathbb{R}^r\\) are reduced coordinates.\n\nSubstituting into the system and applying Galerkin projection:\n\\[\n\\mathbf{K} (\\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}) = \\mathbf{f}\n\\;\\Rightarrow\\;\n\\mathbf{U}^\\top \\mathbf{K} \\mathbf{U} \\mathbf{a} = \\mathbf{U}^\\top(\\mathbf{f} - \\mathbf{K} \\mathbf{T}_{\\text{mean}}).\n\\]\nDefine:\n\nReduced stiffness: \\(\\mathbf{K}_r = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{U}\\),\nReduced source: \\(\\mathbf{b} = \\mathbf{U}^\\top \\mathbf{f}\\),\nProjected offset: \\(\\mathbf{g} = \\mathbf{U}^\\top \\mathbf{K} \\mathbf{T}_{\\text{mean}}\\).\n\nThen:\n\\[\n\\mathbf{a} = \\mathbf{K}_r^{-1}(\\mathbf{b} - \\mathbf{g}),\n\\qquad\n\\hat{\\mathbf{T}} = \\mathbf{T}_{\\text{mean}} + \\mathbf{U} \\mathbf{a}.\n\\]"
  },
  {
    "objectID": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "href": "Resources/intro/rom_intro_ex.html#efficient-online-evaluation-for-affine-parametric-systems",
    "title": "SCIKIT-ROM",
    "section": "Efficient Online Evaluation for Affine Parametric Systems",
    "text": "Efficient Online Evaluation for Affine Parametric Systems\nAssume the system admits the following affine form:\n\\[\n\\mathbf{K}(\\mu) = \\mu\\, \\mathbf{K}_1,\n\\quad\n\\mathbf{f}(\\beta) = \\beta\\, \\mathbf{f}_1.\n\\]\nThen, in the offline phase, precompute:\nIn the online phase, for any \\((\\mu, \\beta)\\):\n\\[\n\\boxed{\n\\hat{\\mathbf{T}}(\\mu, \\beta)\n= \\mathbf{T}_{\\text{mean}}\n+ \\mathbf{U} \\left( \\frac{\\beta}{\\mu} \\mathbf{a}_1 - \\mathbf{c}_1 \\right)\n}\n\\]\nThis avoids matrix assembly and linear solves during inference, resulting in fast and scalable evaluation. Below we build a reduced order model in skrom to quickly calculate the temperature profiles for different parameter values (\\(\\mu, \\beta\\)).\n# ─────────────────────────────────────────────────────────────────────────────\n# Imports & Setup\n# ─────────────────────────────────────────────────────────────────────────────\nfrom pathlib import Path\nnotebook_path = Path().resolve()\n\nfrom src.skrom.utils.imports import *\nfrom src.skrom.rom.rom_utils import *\nfrom src.skrom.rom.rom_error_est import *\nfrom src.skrom.utils.visualization.color_palette import set_color_palette\nfrom src.skrom.utils.reduced_basis.svd import svd_mode_selector\nfrom src.skrom.rom.bilinear_form_rom import BilinearFormROM\nfrom src.skrom.rom.linear_form_rom import LinearFormROM\nfrom skfem.helpers import grad, dot\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import qmc  # for Sobol\nimport time\n\nset_color_palette()\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Mesh & BC\n# ─────────────────────────────────────────────────────────────────────────────\nnx, x_end = 2**17, 0.5\nmesh = MeshLine(np.linspace(0, x_end, nx+1))\nbasis = Basis(mesh, ElementLineP1())\nbc_val = 573.15\nD = np.where(np.isclose(basis.doflocs[0], x_end))[0]\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Material & Source\n# ─────────────────────────────────────────────────────────────────────────────\ndef conductivity(mu: float=0) -&gt; float:\n    \"\"\"$k(μ)=16+μ$.\"\"\"\n    return 16 + mu\n\ndef heat_source(beta: float=0) -&gt; float:\n    \"\"\"$Q(β)=35000+β$.\"\"\"\n    return 35000 + beta\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Forms & Assembly\n# ─────────────────────────────────────────────────────────────────────────────\n@LinearForm\ndef l(v,p):\n    \"\"\"$l(v;p)=∫Q(β)\\,v\\,dx$.\"\"\"\n    return heat_source(p['beta'])*v\n\n@BilinearForm\ndef a(u,v,p):\n    \"\"\"$a(u,v;p)=∫k(μ)\\,\\nabla u·\\nabla v\\,dx$.\"\"\"\n    return conductivity(p['mu'])*dot(grad(u),grad(v))\n\ndef assemble_system(p):\n    \"\"\"Return stiffness, load for params p.\"\"\"\n    return asm(a,basis,mu=p[0]), asm(l,basis,beta=p[1])\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Sobol Sampling\n# ─────────────────────────────────────────────────────────────────────────────\ndef generate_sobol(d,n,bounds):\n    \"\"\"Sobol in $[ℓ_i,u_i]$, n=2^m.\"\"\"\n    sampler = qmc.Sobol(d)\n    S = sampler.random_base2(m=int(np.log2(n)))\n    X = np.empty_like(S)\n    for i,(ℓ,u) in enumerate(bounds):\n        X[:,i] = ℓ + S[:,i]*(u-ℓ)\n    return X\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Data Generation & Split\n# ─────────────────────────────────────────────────────────────────────────────\nparam_ranges = [(-4,4),(-1000,1000)]\nN_snap = 32\nP_train = generate_sobol(2,N_snap,param_ranges)\nP_test  = generate_sobol(2,N_snap,param_ranges)\nP = np.vstack((P_train,P_test))\nmask = np.zeros(2*N_snap,bool); mask[:N_snap]=True\ntrain_mask,test_mask = mask,~mask\n\n\n\nparams\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Full-Order Solve (Affine)\n# ─────────────────────────────────────────────────────────────────────────────\nM0,b0 = assemble_system([-15,-34999])  # k=1,Q=1\nfos_sols, fos_times = [], []\nfor μ,β in P:\n    t0 = time.perf_counter()\n    A = conductivity(μ)*M0\n    f = heat_source(β)*b0\n    u = basis.zeros(); u[D]=bc_val\n    sol = solve(*condense(A,f,x=u,D=D))\n    fos_times.append(time.perf_counter()-t0)\n    fos_sols.append(sol.copy())\nLS = np.array(fos_sols)\n\n\n\nFos Train\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Training/Test Solutions & Centering\n# ─────────────────────────────────────────────────────────────────────────────\nLS_train, LS_test = LS[train_mask], LS[test_mask]\nmean_train = LS_train.mean(0)\nMS = LS_train - mean_train\n\n\n\nFos train with mean subtracted\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# POD Mode Selection\n# ─────────────────────────────────────────────────────────────────────────────\nn_sel, U = svd_mode_selector(MS, tolerance=1e-10, modes=True)\nV = U[:,:n_sel]\nNumber of modes selected: 2 \nPOD Modes:\n\n\n\nPOD Modes\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# ROM Form Construction\n# ─────────────────────────────────────────────────────────────────────────────\nfree = np.setdiff1d(np.arange(basis.N),D)\nBr = BilinearFormROM(a,basis,V,V,free_dofs=free,mean=mean_train)\nLr = LinearFormROM(l,basis,V,free_dofs=free,mean=mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Offline ROM Affine Assembly\n# ─────────────────────────────────────────────────────────────────────────────\nMr0 = Br.assemble(basis,mu=-15)\nbr0 = Lr.assemble(beta=-34999)\nmean_red = V.T@(M0@mean_train)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Online ROM Solve & Metrics\n# ─────────────────────────────────────────────────────────────────────────────\nspeed, error, LS_rom = [], [], []\nfos_test_time = np.array(fos_times)[test_mask]\ni = 0\n\nfor (μ,β),fos_time in zip(P_test,fos_test_time):\n    t0 = time.perf_counter()\n    Mr = conductivity(μ)*Mr0\n    br = heat_source(β)*br0 - conductivity(μ)*mean_red\n    ur = np.linalg.solve(Mr,br)\n    uR = reconstruct_solution(ur,V,mean_train)\n    dt = time.perf_counter()-t0\n    speed.append(fos_time/dt)\n    error.append(100*np.linalg.norm(LS_test[i]-uR)/np.linalg.norm(LS_test[i])+1e-15)\n    LS_rom.append(uR.copy())\n    i = i + 1\nLS_rom = np.array(LS_rom)\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Error Analysis & Reporting\n# ─────────────────────────────────────────────────────────────────────────────\nmatrix = compute_rom_error_metrics_flat(LS_test,LS_rom)\ngenerate_rom_error_report(matrix)\n# plot_rom_error_diagnostics_flat(\n#     LS_test,LS_rom,error,speed,\n#     sim_axis=['True','ROM'],metrics=matrix\n# )\nLS_rom = np.asarray(LS_rom)\n\n# Assign the list of speed‐up ratios (FOM time / ROM time) to a variable:\n#   speed_up[i] = t_fos_test[i] / t_rom[i]\nROM_speed_up = speed\n\n# Optional: drop the first entry if it's skewed by startup overhead\n# (e.g., JIT, memory allocation). Now ROM_speed_up.shape == (N_test - 1,).\nROM_speed_up = ROM_speed_up[1:]\n\n# Assign the list of relative errors (in %) for each test sample:\n#   ROM_relative_error[i]\n#   = 100 · ‖u_fos – u_rom‖₂ / ‖u_fos‖₂\nROM_relative_error = error\n\nplot_rom_error_diagnostics_flat(\n    LS_test,              # full‐order solution snapshots u_fos^(i)\n    LS_rom,               # hyper‐ROM solution snapshots u_rom^(i)\n    ROM_relative_error,   # list [e_1, …, e_N]\n    ROM_speed_up,         # list [s_1, …, s_N]\n    sim_axis=['True','ROM'],  # axis labels for true vs. ROM scatter\n    metrics=matrix            # the computed metrics matrix\n)\n  \n===================\nROM Accuracy Report\n===================\n\nGlobal Errors:\nL2 Error:                 8.2505e-06\nRelative L2 Error:        5.2750e-12\nL∞ Error:                 2.0845e-08\nRelative L∞ Error:        2.2554e-11\nRMSE:                     4.0286e-09\nMAE:                      1.6009e-09\n\nStatistical Fit:\nR² Score:                 1.0000\nExplained Variance:       1.0000\n\nError Distribution:\nMedian Error:             -9.4133e-11\n95th Percentile Error:    1.1765e-08\n\nTime/Parameter-Dependent Errors:\nAverage Rel L2 Error over time/parameter: 2.3908e-12\nMax Rel L2 Error over time/parameter: 1.5451e-11\nMin Rel L2 Error over time/parameter: 6.5942e-14"
  }
]