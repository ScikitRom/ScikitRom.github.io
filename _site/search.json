[
  {
    "objectID": "reference/utils.fem_utils.html",
    "href": "reference/utils.fem_utils.html",
    "title": "utils.fem_utils",
    "section": "",
    "text": "utils.fem_utils\nutils.fem_utils",
    "crumbs": [
      "Utilities",
      "utils.fem_utils"
    ]
  },
  {
    "objectID": "reference/utils.basic.html",
    "href": "reference/utils.basic.html",
    "title": "utils.basic",
    "section": "",
    "text": "utils.basic\nutils.basic\nThis module imports essential libraries commonly used in pyHyperRom. By using from pyHyperRom.basic import *, users can access frequently utilized libraries.",
    "crumbs": [
      "Utilities",
      "utils.basic"
    ]
  },
  {
    "objectID": "reference/fom.html",
    "href": "reference/fom.html",
    "title": "fom",
    "section": "",
    "text": "fom\n\n\nFinite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom"
    ]
  },
  {
    "objectID": "reference/utils.imports.html",
    "href": "reference/utils.imports.html",
    "title": "utils.imports",
    "section": "",
    "text": "utils.imports\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework: – Core imports for OS, filesystem, timing, and randomness – Numerical & symbolic computing: NumPy, SciPy (dense & sparse), Sympy – Finite‐element tools: scikit‐fem (from skfem import *), mesh I/O via meshio – Linear algebra solvers: dense (LU), sparse (splu, spilu, CG), and multigrid (pyamg) – Sampling & design‐of‐experiments: Sobol, Latin Hypercube (SciPy QMC & pyDOE) – Plotting & visualization: Matplotlib (2D/3D, custom styles), ptitprince, and optional animation modules\n– Utilities for dynamic imports, path handling, and Cartesian products These imports and utilities ensure consistent, ready‐to‐use functionality across the entire reduced‐order modeling pipeline.",
    "crumbs": [
      "Utilities",
      "utils.imports"
    ]
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html",
    "href": "reference/utils.newton_solver_rom.html",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "utils.newton_solver_rom\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit.",
    "crumbs": [
      "Utilities",
      "utils.newton_solver_rom"
    ]
  },
  {
    "objectID": "reference/utils.newton_solver_rom.html#functions",
    "href": "reference/utils.newton_solver_rom.html#functions",
    "title": "utils.newton_solver_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver_rom\nSolve a nonlinear system with Newton’s method + dense LU factorization.\n\n\n\n\n\nutils.newton_solver_rom.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear system with Newton’s method + dense LU factorization. Reuses LU factorization when the reduced Jacobian changes by less than jac_tol.\nParameters: assemble_func : callable Function that returns (J_rom, RHS_rom). Must accept u_rom as its first argument, then *args and **kwargs. u_rom : ndarray Initial guess for the reduced state; will be updated in place. *args : Positional args forwarded to assemble_func (e.g. u_old_rom, bc_data). tol : float Convergence threshold on ‖Δu‖. maxit : int Maximum Newton iterations. jac_tol : float Threshold on relative Frobenius‐norm change in Jacobian to trigger a refactorization. **kwargs : Keyword args forwarded to assemble_func (e.g. i=iteration).\nReturns: ndarray The converged u_rom.\nRaises: RuntimeError if LU factorization fails or no convergence in maxit.",
    "crumbs": [
      "Utilities",
      "utils.newton_solver_rom"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html",
    "href": "reference/utils.visualization.color_palette.html",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "utils.visualization.color_palette\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.visualization.color_palette.html#functions",
    "href": "reference/utils.visualization.color_palette.html#functions",
    "title": "utils.visualization.color_palette",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_color_palette\nSet a custom color palette for Matplotlib plots.\n\n\n\n\n\nutils.visualization.color_palette.set_color_palette()\nSet a custom color palette for Matplotlib plots.\nDefines and applies a predefined list of hexadecimal color codes to Matplotlib’s axes.prop_cycle, ensuring a consistent sequence of colors for plot elements.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncolors\nlist of str\nA list of hexadecimal color strings representing the palette applied.\n\n\n\n\n\n\n\nThe palette consists of 19 distinct colors chosen for clarity and visual appeal.\nApplying this palette affects all subsequent plots in the current session.\n\n\n\n\n&gt;&gt;&gt; colors = set_color_palette()\n&gt;&gt;&gt; plt.plot([0, 1, 2], [10, 20, 15])  # uses the first color in the returned palette\n&gt;&gt;&gt; plt.scatter([1, 2, 3], [5, 10, 20])  # uses the next color in the cycle",
    "crumbs": [
      "Visualization",
      "utils.visualization.color_palette"
    ]
  },
  {
    "objectID": "reference/utils.rom_error_est.html",
    "href": "reference/utils.rom_error_est.html",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "utils.rom_error_est\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone",
    "crumbs": [
      "Utilities",
      "utils.rom_error_est"
    ]
  },
  {
    "objectID": "reference/utils.rom_error_est.html#functions",
    "href": "reference/utils.rom_error_est.html#functions",
    "title": "utils.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\nutils.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_error_est.generate_rom_error_report(\n    metrics,\n    name='ROM Accuracy Report',\n)\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone",
    "crumbs": [
      "Utilities",
      "utils.rom_error_est"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html",
    "href": "reference/utils.visualization.vtuwriter.html",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "utils.visualization.vtuwriter\n\n\n\n\n\nName\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)",
    "crumbs": [
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "reference/hyperreduction.html",
    "href": "reference/hyperreduction.html",
    "title": "hyperreduction",
    "section": "",
    "text": "hyperreduction\nhyperreduction",
    "crumbs": [
      "Hyperreduction",
      "hyperreduction"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "docs",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "reference/utils.errors.html",
    "href": "reference/utils.errors.html",
    "title": "utils.errors",
    "section": "",
    "text": "utils.errors\nutils.errors",
    "crumbs": [
      "Utilities",
      "utils.errors"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html",
    "href": "reference/utils.visualization.generate_vtu.html",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "utils.visualization.generate_vtu\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtu.html#functions",
    "href": "reference/utils.visualization.generate_vtu.html#functions",
    "title": "utils.visualization.generate_vtu",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_mesh_from_params\nConstruct a SciKit-FEM mesh from JSON parameter entries.\n\n\nconvert_to_vtu_series\nConvert NumPy solution snapshots to a VTU series with PVD index.\n\n\n\n\n\nutils.visualization.generate_vtu.build_mesh_from_params(p)\nConstruct a SciKit-FEM mesh from JSON parameter entries.\nReads domain dimensions and mesh refinement factor from a parameter dictionary and uses them to build a finite-element mesh via the domain factory.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np\ndict\nDictionary of mesh parameters. Expected keys (3D): - lx : float, optional Domain length in the x-direction (default is 1.0). - ly : float, optional Domain length in the y-direction (default is 1.0). - lz : float, optional Domain length in the z-direction (default is 1.0). - factor : int, optional Mesh refinement factor controlling element subdivision (default is 4).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmesh\nMesh\nA SciKit-FEM mesh object constructed with the specified dimensions and refinement factor.\n\n\n\n\n\n\n&gt;&gt;&gt; params = {'lx': 2.0, 'ly': 1.0, 'lz': 0.5, 'factor': 6}\n&gt;&gt;&gt; mesh = build_mesh_from_params(params)\n&gt;&gt;&gt; mesh.p.shape  # number of spatial dimensions and nodes\n(3, N)\n\n\n\n\nIf any of the dimension keys are missing, defaults of 1.0 each are used.\nfactor must be convertible to int; non-integer inputs will be cast.\n\n\n\n\n\nutils.visualization.generate_vtu.convert_to_vtu_series(\n    root_dir,\n    sol_file_name='u_solution.npy',\n    vtu_folder_name='VTU',\n    steps=300,\n    stride=10,\n)\nConvert NumPy solution snapshots to a VTU series with PVD index.\nScans all subdirectories under root_dir for pairs of params.json and solution files, rebuilds the corresponding mesh, writes VTU files for each snapshot at intervals defined by stride up to steps, and aggregates outputs into a PVD file for streamlined visualization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_dir\nstr or Path\nBase directory to search recursively for solution runs.\nrequired\n\n\nsol_file_name\nstr\nFilename of the NumPy solution array (default is \"u_solution.npy\").\n'u_solution.npy'\n\n\nvtu_folder_name\nstr\nName of the subfolder to create for VTU outputs in each run directory (default is \"VTU\").\n'VTU'\n\n\nsteps\nint\nMaximum number of time steps to process from each solution array (default is 300).\n300\n\n\nstride\nint\nInterval between snapshots to write (every stride steps) (default is 10).\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nprocessed\nint\nTotal number of run folders processed (i.e., those containing both params.json and the solution file).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIOError\nIf reading params.json or the NumPy array fails for a detected folder.\n\n\n\n\n\n\n&gt;&gt;&gt; n = convert_to_vtu_series(\n...     'sim_runs', sol_file_name='solutions/u.npy',\n...     vtu_folder_name='VTU_out', steps=200, stride=5\n... )\n&gt;&gt;&gt; print(f\"Processed {n} runs.\")\n\n\n\n\nExisting root_dir contents are not modified or deleted; new VTU folders are created alongside original data.\nUses tqdm for a progress bar when scanning directories.\nPVD writer organizes all snapshot VTU files for each run into a single index file for use with ParaView or similar tools.",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtu"
    ]
  },
  {
    "objectID": "reference/rom.html",
    "href": "reference/rom.html",
    "title": "rom",
    "section": "",
    "text": "rom\nrom\nThe rom folder provides core reduced‐order modeling tools:\n– Projection & assembly classes (BilinearFormROM, LinearFormROM): • Project full‐order stiffness and load contributions onto reduced bases • Handle Dirichlet boundary conditions via free‐DOF mappings • Support chunked/clustered assembly for memory‐efficient reduced operators\n– Error evaluation & visualization (error_utils.py): • Compute time‐dependent and global error metrics (L2, RMSE, R², energy‐norm, etc.) • Generate scatter plots, spatial snapshots, raincloud plots, and tabular reports\n– ROM utilities (utils.py): • Snapshot splitting and sampling (random, Latin‐Hypercube, Sobol, Gaussian) • Basis enrichment via deflation and QR re‐orthonormalization • Solution reconstruction from reduced coefficients • Data I/O for ROM simulations (rom_data_gen, load_rom_data) • Newton solvers for (hyper‐)reduced systems",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom"
    ]
  },
  {
    "objectID": "reference/utils.basis.pod.html",
    "href": "reference/utils.basis.pod.html",
    "title": "utils.basis.pod",
    "section": "",
    "text": "utils.basis.pod\nutils.basis.pod",
    "crumbs": [
      "Utilities",
      "utils.basis.pod"
    ]
  },
  {
    "objectID": "reference/utils.rom_utils.html",
    "href": "reference/utils.rom_utils.html",
    "title": "utils.rom_utils",
    "section": "",
    "text": "utils.rom_utils\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis.",
    "crumbs": [
      "Utilities",
      "utils.rom_utils"
    ]
  },
  {
    "objectID": "reference/utils.rom_utils.html#functions",
    "href": "reference/utils.rom_utils.html#functions",
    "title": "utils.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\ngenerate_gaussian_samples\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds,\n\n\ngenerate_lhs\nGenerates a Latin Hypercube Sampling (LHS).\n\n\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\ngenerate_sobol\nGenerates a Sobol sequence.\n\n\nhyperreduce\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nplot_rom_error_diagnostics_flat\nPlot ROM error diagnostics for flat (time x space) data.\n\n\nreconstruct_solution\nReconstruct the full-order solution from the reduced solution.\n\n\nrom_data_gen\nSave ROM data under /ROM_data:\n\n\nsvd_mode_selector\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nsvd_mode_selector_var\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\n\n\nupdate_basis\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\nutils.rom_utils.compute_rom_error_metrics_flat(u, u_rom, K=None)\nCompute ROM error metrics for data shaped (n_snapshots, n_points).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\nFull-order field (each row is one snapshot in time).\nrequired\n\n\nu_rom\narray_like, same shape as u\nROM reconstruction.\nrequired\n\n\nK\n(array_like, optional, shape(n_space, n_space))\nStiffness matrix for energy‐norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\n{ # time‐dependent ‘L2_error_time’: ndarray (n_snap,), ‘relative_L2_error_time’: ndarray (n_snap,), ‘RMSE_time’: ndarray (n_snap,), ‘MAE_time’: ndarray (n_snap,), ‘time_avg_rel_L2_error’: float, # global ‘L2_error’: float, ‘relative_L2_error’: float, ‘Linf_error’: float, ‘RMSE’: float, ‘MAE’: float, ‘R2’: float, ‘explained_variance’: float, ‘quantiles’: { ‘median_error’: float, ‘p95_error’: float }, # if K is given ‘energy_norm_error’: float }\n\n\n\n\n\n\n\nutils.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerates Gaussian distributed samples for each dimension based on calculated means and standard deviations from bounds, without clipping them to the specified bounds.\nParameters: dimensions (int): Number of dimensions. num_points (int): Number of points to generate. bounds (list of tuples): Bounds for each dimension in the form (min, max), from which means and standard deviations are calculated.\nReturns: np.array: A numpy array containing the Gaussian distributed points.\n\n\n\nutils.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerates a Latin Hypercube Sampling (LHS).\nParameters: dimensions (int): Number of dimensions in the sample. num_points (int): Number of points in the sample. bounds (list of tuples): Each tuple contains the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the LHS points scaled to the provided bounds.\n\n\n\nutils.rom_utils.generate_rom_error_report(metrics, name='ROM Accuracy Report')\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\nutils.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerates a Sobol sequence.\nParameters: dimensions (int): Number of dimensions in the Sobol sequence. num_points (int): Number of points in the sequence. bounds (list of tuples): A list of tuples containing the lower and upper bounds for each dimension.\nReturns: np.array: A numpy array containing the Sobol sequence scaled to the provided bounds.\n\n\n\nutils.rom_utils.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nExecutes the randomized SVD + bounded NNLS pipeline on qoi.\n\n\nqoi : ndarray Input data of shape (n_samples, n_features) n_components : int Number of SVD components to retain verbosity : int Verbosity level for the solver plot : bool Whether to display singular value decay plot\n\n\n\nx : ndarray Solution vector from NNLS flag : int Exit flag from the solver\n\n\n\n\nutils.rom_utils.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nPlot ROM error diagnostics for flat (time x space) data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snap, n_space))\n\nrequired\n\n\nu_rom\narray_like, same shape\n\nrequired\n\n\nmetrics\ndict\nOutput from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple\n(nx, ny) to reshape each snapshot back to 2D for pcolormesh.\nNone\n\n\n\n\n\n\n\nutils.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct the full-order solution from the reduced solution. The reduced solution (u_reduced) is lifted via the reduced basis defined on the free DOFs, then the previously subtracted mean is added and the prescribed Dirichlet values are inserted.\nThe full solution is approximated as u_full = mean + V_free * u_reduced where V_free (here assumed to be self.lob) is defined on the free DOFs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\nndarray\nThe reduced solution vector of dimension (r,).\nrequired\n\n\nfull_dof_count\nint\nThe total number of DOFs in the full-order model.\nrequired\n\n\ndirichlet_nodes\nndarray\nArray of global DOF indices corresponding to Dirichlet boundary conditions.\nrequired\n\n\ndirichlet_values\nndarray\nArray of values for the Dirichlet nodes (must have the same length as dirichlet_nodes).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\nndarray\nThe reconstructed full-order solution of dimension (full_dof_count,).\n\n\n\n\n\n\n\nutils.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM data under /ROM_data: - Pops out save_kw[“L_solutions”] and writes it to fos_solution.npy - Writes the rest of save_kw into ROM_simulation_data.npz\n\n\n\nutils.rom_utils.svd_mode_selector(data, tolerance=0.001, modes=False, **kwargs)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelects the number of singular value decomposition (SVD) modes based on a tolerance.\nParameters: - data: The input data for SVD. - tolerance: The threshold for cumulative energy content in the SVD spectrum. - modes: If True, prints the number of selected modes.\nReturns: - The number of selected modes and the matrix of SVD left singular vectors.\n\n\n\nutils.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdates the reduced basis V using new transient snapshots W_mu.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent reduced basis (assumed orthonormal).\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for a parameter μ.\nrequired\n\n\nenergy_tol\nfloat\nCumulative energy threshold for selecting POD modes.\nrequired\n\n\nmax_modes\nint\nMaximum number of new basis vectors to add.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_new))\nUpdated orthonormal reduced basis.",
    "crumbs": [
      "Utilities",
      "utils.rom_utils"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Full-order model builders and utilities\n\n\n\nfom\n\n\n\nfom.fem_utils\nProvides functions for building algebraic multigrid smoothed aggregation preconditioners,\n\n\n\n\n\n\nReduced-order model builders and utilities\n\n\n\nrom\nThe rom folder provides core reduced‐order modeling tools:\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,\n\n\n\n\n\n\nHyper-reduction algorithms and ECSW routines\n\n\n\nhyperreduction.bilinear_form_hyperrom\n\n\n\nhyperreduction.linear_form_hyperrom\n\n\n\nhyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nhyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\n\n\n\n\n\n\nCore helpers and reduced-basis tools\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.old\n\n\n\nutils.old.rom_utils_old\n\n\n\nutils.reduced_basis\n\n\n\nutils.reduced_basis.svd\n\n\n\n\n\n\n\nVTU/VTP writers, color palettes, and style packages\n\n\n\nutils.visualization\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#full-order-model-fom",
    "href": "reference/index.html#full-order-model-fom",
    "title": "Function reference",
    "section": "",
    "text": "Full-order model builders and utilities\n\n\n\nfom\n\n\n\nfom.fem_utils\nProvides functions for building algebraic multigrid smoothed aggregation preconditioners,",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#reduced-order-model-rom",
    "href": "reference/index.html#reduced-order-model-rom",
    "title": "Function reference",
    "section": "",
    "text": "Reduced-order model builders and utilities\n\n\n\nrom\nThe rom folder provides core reduced‐order modeling tools:\n\n\nrom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\n\n\nrom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\n\n\nrom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\n\n\nrom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O,",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#hyperreduction",
    "href": "reference/index.html#hyperreduction",
    "title": "Function reference",
    "section": "",
    "text": "Hyper-reduction algorithms and ECSW routines\n\n\n\nhyperreduction.bilinear_form_hyperrom\n\n\n\nhyperreduction.linear_form_hyperrom\n\n\n\nhyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\n\n\nhyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Function reference",
    "section": "",
    "text": "Core helpers and reduced-basis tools\n\n\n\nutils.imports\nThe utils package aggregates frequently used libraries and helper routines for the pyHyperRom framework:\n\n\nutils.old\n\n\n\nutils.old.rom_utils_old\n\n\n\nutils.reduced_basis\n\n\n\nutils.reduced_basis.svd",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#visualization",
    "href": "reference/index.html#visualization",
    "title": "Function reference",
    "section": "",
    "text": "VTU/VTP writers, color palettes, and style packages\n\n\n\nutils.visualization\n\n\n\nutils.visualization.generate_vtk\n\n\n\nutils.visualization.generate_vtu\n\n\n\nutils.visualization.vtuwriter\n\n\n\nutils.visualization.color_palette",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/utils.newton_solver.html",
    "href": "reference/utils.newton_solver.html",
    "title": "utils.newton_solver",
    "section": "",
    "text": "utils.newton_solver\n\n\n\n\n\nName\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching.",
    "crumbs": [
      "Utilities",
      "utils.newton_solver"
    ]
  },
  {
    "objectID": "reference/utils.newton_solver.html#functions",
    "href": "reference/utils.newton_solver.html#functions",
    "title": "utils.newton_solver",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nnewton_solver\nNewton–Raphson with zero runtime‐cost BC switching.\n\n\n\n\n\nutils.newton_solver.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=1e-06,\n    maxit=50,\n)\nNewton–Raphson with zero runtime‐cost BC switching.",
    "crumbs": [
      "Utilities",
      "utils.newton_solver"
    ]
  },
  {
    "objectID": "reference/utils.custom_nnls.html",
    "href": "reference/utils.custom_nnls.html",
    "title": "utils.custom_nnls",
    "section": "",
    "text": "utils.custom_nnls\nutils.custom_nnls",
    "crumbs": [
      "Utilities",
      "utils.custom_nnls"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html",
    "href": "reference/utils.visualization.generate_vtk.html",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "utils.visualization.generate_vtk\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.visualization.generate_vtk.html#functions",
    "href": "reference/utils.visualization.generate_vtk.html#functions",
    "title": "utils.visualization.generate_vtk",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_vtk\nBatch export of full-order and reduced-order solutions to VTK.\n\n\n\n\n\nutils.visualization.generate_vtk.generate_vtk(\n    LS_test,\n    LS_rom,\n    mesh,\n    basis,\n    scale=1.0,\n    num_test=5,\n    out_dir='sol_vtk_files',\n    split_dim=False,\n)\nBatch export of full-order and reduced-order solutions to VTK.\nRandomly selects solution indices, generates translated meshes, and writes both full-order (FOS) and reduced-order (ROM) displacement fields to VTK files within separate test directories. Cleans output directory on each invocation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nLS_test\nsequence of array_like\nList or array of full-order solution vectors.\nrequired\n\n\nLS_rom\nsequence of array_like\nList or array of reduced-order solution vectors corresponding to LS_test indices.\nrequired\n\n\nmesh\nobject\nMesh object used for geometry translations (see _save_vtk_solution).\nrequired\n\n\nbasis\nobject\nBasis object with attribute nodal_dofs for nodal indexing.\nrequired\n\n\nscale\nfloat\nScale factor for displacements before applying to the mesh (default is 1.0).\n1.0\n\n\nnum_test\nint\nNumber of random test cases to export (default is 5).\n5\n\n\nout_dir\nstr\nBase directory path where subdirectories Test_1, Test_2, … will be created (default is “sol_vtk_files”).\n'sol_vtk_files'\n\n\nsplit_dim\nbool\nIf True, split displacement into per-axis scalar fields in VTK outputs (default is False).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nIf out_dir already exists, it will be removed entirely before new output is written.\nEach Test_i directory contains two files: test_sol_fos_i.vtk and test_sol_rom_i.vtk.\n\n\n\n\n&gt;&gt;&gt; generate_vtk(LS_test, LS_rom, mesh, basis, scale=0.5, num_test=3,\n...              out_dir=\"vtk_outputs\", split_dim=True)",
    "crumbs": [
      "Visualization",
      "utils.visualization.generate_vtk"
    ]
  },
  {
    "objectID": "reference/utils.old.rom_utils_old.html",
    "href": "reference/utils.old.rom_utils_old.html",
    "title": "utils.old.rom_utils_old",
    "section": "",
    "text": "utils.old.rom_utils_old\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\ngenerate_sobol\nGenerate a scaled Sobol sequence.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\nload_rom_data\nLoad ROM data from disk into memory or object attributes.\n\n\nnewton_rom_solver\nSolve ROM equations via Newton’s method.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\ntrain_test_split\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\nutils.old.rom_utils_old.generate_gaussian_samples(\n    dimensions,\n    num_points,\n    bounds,\n)\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of samples to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension; used to compute means and std devs.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian random samples (not clipped to bounds).\n\n\n\n\n\n\n\nMean is (min+max)/2, std dev is (max-min)/5.\n\n\n\n\n&gt;&gt;&gt; gauss = generate_gaussian_samples(2, 50, [(-2,2), (0,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of sample dimensions.\nrequired\n\n\nnum_points\nint\nNumber of LHS points to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) pairs per dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nLHS points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; lhs_pts = generate_lhs(3, 10, [(0,1), (1,2), (-1,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_sobol(dimensions, num_points, bounds)\nGenerate a scaled Sobol sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions for the sequence.\nrequired\n\n\nnum_points\nint\nNumber of Sobol points to generate (power of two recommended).\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nSobol sequence points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; sobol_pts = generate_sobol(2, 8, [(0,1), (0,5)])\n\n\n\n\nutils.old.rom_utils_old.latin_hypercube_train_test_split(\n    N_snap,\n    train_percentage=0.8,\n)\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nMask of training snapshots selected via LHS ordering.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nMask of testing snapshots.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = latin_hypercube_train_test_split(50, 0.6)\n\n\n\n\nutils.old.rom_utils_old.load_rom_data(self=None, rom_data_dir=None)\nLoad ROM data from disk into memory or object attributes.\nSearches for fos_solutions.npy and ROM_simulation_data.npz under the given directory (or infers from self.problem_name), loads arrays, and returns or assigns them.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf None, function returns data; otherwise assigns to self attributes.\nNone\n\n\nrom_data_dir\nstr or Path\nDirectory containing ROM_data; if None, inferred from self.problem_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fos_solutions, sim_data) if self is None\nTuple of the full-order solutions array and dict of other data.\n\n\n\nNone if self is not None\nData assigned as attributes on self.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf expected data files are missing.\n\n\n\n\n\n\n&gt;&gt;&gt; sols, data = load_rom_data(None, '/path/ROM_data')\n&gt;&gt;&gt; load_rom_data(problem_instance, rom_data_dir)\n\n\n\n\nutils.old.rom_utils_old.newton_rom_solver(\n    instance,\n    u,\n    tol=0.01,\n    maxit=50,\n    params=None,\n)\nSolve ROM equations via Newton’s method.\nIteratively updates the reduced coefficients u to converge to the full-order solution based on provided reduced operators and interpolation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nROM object with attributes T_ref, U, basis, and method reduced_operators.\nrequired\n\n\nu\nndarray\nInitial reduced coefficients vector.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the change norm (default is 1e-2).\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations (default is 50).\n50\n\n\nparams\ndict or None\nOptional parameters to pass to reduced_operators.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_sol\nndarray\nReconstructed full-order solution upon convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; u0 = np.zeros(instance.U.shape[1])\n&gt;&gt;&gt; u_sol = newton_rom_solver(instance, u0, tol=1e-5)\n\n\n\n\nutils.old.rom_utils_old.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\nExtracts full-order solutions and other simulation outputs into a dedicated ROM_data folder under problem_path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nKeyword-data mapping containing at least the key ‘fos_solutions’ for full-order snapshots and other arrays to save.\nrequired\n\n\nproblem_path\nstr or Path\nBase directory for the ROM_data subfolder.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n&gt;&gt;&gt; rom_data_gen({'fos_solutions': sols, 'U': U, 'basis': basis}, '/path/to/problem')\n\n\n\n\nutils.old.rom_utils_old.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of snapshots to split.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots assigned to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered training mask.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered testing mask.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = sobol_train_test_split(32)\n\n\n\n\nutils.old.rom_utils_old.train_test_split(\n    N_snap,\n    N_sel=None,\n    train_percentage=0.8,\n)\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots available.\nrequired\n\n\nN_sel\nint\nNumber of snapshots to select for splitting. If provided, samples are randomly chosen without replacement from the full set before splitting. Default is None (use all snapshots).\nNone\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to the training set (between 0 and 1). Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training samples.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing samples.\n\n\n\n\n\n\n\nIf N_sel is given, train_percentage is still applied relative to N_snap.\nMasks are built by first permuting or selecting indices, then assigning the first int(N_snap * train_percentage) to training, the rest to testing.\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = train_test_split(100, train_percentage=0.75)\n&gt;&gt;&gt; np.sum(train_mask), np.sum(test_mask)\n(75, 25)",
    "crumbs": [
      "Utilities",
      "utils.old.rom_utils_old"
    ]
  },
  {
    "objectID": "reference/utils.old.rom_utils_old.html#functions",
    "href": "reference/utils.old.rom_utils_old.html#functions",
    "title": "utils.old.rom_utils_old",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\ngenerate_sobol\nGenerate a scaled Sobol sequence.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\nload_rom_data\nLoad ROM data from disk into memory or object attributes.\n\n\nnewton_rom_solver\nSolve ROM equations via Newton’s method.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\ntrain_test_split\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\nutils.old.rom_utils_old.generate_gaussian_samples(\n    dimensions,\n    num_points,\n    bounds,\n)\nGenerate Gaussian-distributed samples based on provided bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of samples to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension; used to compute means and std devs.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian random samples (not clipped to bounds).\n\n\n\n\n\n\n\nMean is (min+max)/2, std dev is (max-min)/5.\n\n\n\n\n&gt;&gt;&gt; gauss = generate_gaussian_samples(2, 50, [(-2,2), (0,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sampling (LHS) design.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of sample dimensions.\nrequired\n\n\nnum_points\nint\nNumber of LHS points to generate.\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) pairs per dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nLHS points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; lhs_pts = generate_lhs(3, 10, [(0,1), (1,2), (-1,1)])\n\n\n\n\nutils.old.rom_utils_old.generate_sobol(dimensions, num_points, bounds)\nGenerate a scaled Sobol sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions for the sequence.\nrequired\n\n\nnum_points\nint\nNumber of Sobol points to generate (power of two recommended).\nrequired\n\n\nbounds\nsequence of tuple of float\nList of (min, max) for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nSobol sequence points scaled to the given bounds.\n\n\n\n\n\n\n&gt;&gt;&gt; sobol_pts = generate_sobol(2, 8, [(0,1), (0,5)])\n\n\n\n\nutils.old.rom_utils_old.latin_hypercube_train_test_split(\n    N_snap,\n    train_percentage=0.8,\n)\nSplit snapshots using Latin Hypercube Sampling (LHS) indices.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nMask of training snapshots selected via LHS ordering.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nMask of testing snapshots.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = latin_hypercube_train_test_split(50, 0.6)\n\n\n\n\nutils.old.rom_utils_old.load_rom_data(self=None, rom_data_dir=None)\nLoad ROM data from disk into memory or object attributes.\nSearches for fos_solutions.npy and ROM_simulation_data.npz under the given directory (or infers from self.problem_name), loads arrays, and returns or assigns them.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf None, function returns data; otherwise assigns to self attributes.\nNone\n\n\nrom_data_dir\nstr or Path\nDirectory containing ROM_data; if None, inferred from self.problem_name.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n(fos_solutions, sim_data) if self is None\nTuple of the full-order solutions array and dict of other data.\n\n\n\nNone if self is not None\nData assigned as attributes on self.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf expected data files are missing.\n\n\n\n\n\n\n&gt;&gt;&gt; sols, data = load_rom_data(None, '/path/ROM_data')\n&gt;&gt;&gt; load_rom_data(problem_instance, rom_data_dir)\n\n\n\n\nutils.old.rom_utils_old.newton_rom_solver(\n    instance,\n    u,\n    tol=0.01,\n    maxit=50,\n    params=None,\n)\nSolve ROM equations via Newton’s method.\nIteratively updates the reduced coefficients u to converge to the full-order solution based on provided reduced operators and interpolation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nROM object with attributes T_ref, U, basis, and method reduced_operators.\nrequired\n\n\nu\nndarray\nInitial reduced coefficients vector.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the change norm (default is 1e-2).\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations (default is 50).\n50\n\n\nparams\ndict or None\nOptional parameters to pass to reduced_operators.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_sol\nndarray\nReconstructed full-order solution upon convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n&gt;&gt;&gt; u0 = np.zeros(instance.U.shape[1])\n&gt;&gt;&gt; u_sol = newton_rom_solver(instance, u0, tol=1e-5)\n\n\n\n\nutils.old.rom_utils_old.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\nExtracts full-order solutions and other simulation outputs into a dedicated ROM_data folder under problem_path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nKeyword-data mapping containing at least the key ‘fos_solutions’ for full-order snapshots and other arrays to save.\nrequired\n\n\nproblem_path\nstr or Path\nBase directory for the ROM_data subfolder.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n&gt;&gt;&gt; rom_data_gen({'fos_solutions': sols, 'U': U, 'basis': basis}, '/path/to/problem')\n\n\n\n\nutils.old.rom_utils_old.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots according to a Sobol quasi-random sequence.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nNumber of snapshots to split.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots assigned to training. Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered training mask.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nSobol-ordered testing mask.\n\n\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = sobol_train_test_split(32)\n\n\n\n\nutils.old.rom_utils_old.train_test_split(\n    N_snap,\n    N_sel=None,\n    train_percentage=0.8,\n)\nRandomly split snapshots into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots available.\nrequired\n\n\nN_sel\nint\nNumber of snapshots to select for splitting. If provided, samples are randomly chosen without replacement from the full set before splitting. Default is None (use all snapshots).\nNone\n\n\ntrain_percentage\nfloat\nFraction of snapshots to assign to the training set (between 0 and 1). Default is 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training samples.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing samples.\n\n\n\n\n\n\n\nIf N_sel is given, train_percentage is still applied relative to N_snap.\nMasks are built by first permuting or selecting indices, then assigning the first int(N_snap * train_percentage) to training, the rest to testing.\n\n\n\n\n&gt;&gt;&gt; train_mask, test_mask = train_test_split(100, train_percentage=0.75)\n&gt;&gt;&gt; np.sum(train_mask), np.sum(test_mask)\n(75, 25)",
    "crumbs": [
      "Utilities",
      "utils.old.rom_utils_old"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html",
    "href": "reference/rom.bilinear_form_rom.html",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "rom.bilinear_form_rom\nImplements reduced-order bilinear form assembly for full-order to reduced-order transformations.\nThis module provides: - BilinearFormROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that projects full-order element stiffness matrices onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced stiffness matrix with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.bilinear_form_rom.html#classes",
    "href": "reference/rom.bilinear_form_rom.html#classes",
    "title": "rom.bilinear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormROM\nBilinearFormROM\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM(\n    form,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nBilinearFormROM\nBilinear form that projects element stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\n(ndarray, shape(N_free, r) or (N, r))\nLeft (test) reduced basis.\n\n\nrob\n(ndarray, shape(N_free, r) or (N, r))\nRight (trial) reduced basis.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for trial functions.\n\n\nvbasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced stiffness matrix.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.assemble(vbasis=None, **kwargs)\nAssemble the global reduced stiffness matrix.\nProjects element stiffness matrices onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvbasis\nBasis\nFinite element basis for test functions. Defaults to ubasis.\nNone\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nReduced stiffness matrix.\n\n\n\n\n\n\n\nrom.bilinear_form_rom.BilinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.bilinear_form_rom"
    ]
  },
  {
    "objectID": "reference/utils.old.html",
    "href": "reference/utils.old.html",
    "title": "utils.old",
    "section": "",
    "text": "utils.old\n\n\nLegacy utility functions and experimental prototypes retained for reference and backward compatibility.\nThis subpackage contains all “old” or deprecated utility routines that have since been superseded by newer, more robust implementations in the main utils package. It allows you to review earlier approaches and compare behavior against current methods.\nAvailable modules (non-exhaustive):\n\nsvd_mode_selectors_old.py : Original SVD mode selection routines using basic cumulative-energy thresholds.\napproximating_ln.py : Naive series-expansion algorithm for natural logarithm approximation.\nmagnetic_field_utils_old.py: Early SFML-based routines for drawing electric and magnetic field visualizations.\nkotter_change_plan.py : Preliminary Kotter’s Eight-Step Change Management plan generator.\ndehydration_monitor_old.py : Prototype hydration-tracking functions for Alzheimer’s monitoring device.\nwavelet_basics.py : Initial implementations of wavelet transform utilities.\n\n\n\n\n&gt;&gt;&gt; from utils.old import svd_mode_selectors_old\n&gt;&gt;&gt; modes, U = svd_mode_selectors_old.svd_mode_selector(data_matrix, tolerance=1e-2)",
    "crumbs": [
      "Utilities",
      "utils.old"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html",
    "href": "reference/rom.rom_utils.html",
    "title": "rom.rom_utils",
    "section": "",
    "text": "rom.rom_utils\nGeneral-purpose utilities for snapshot splitting, sampling, basis updates, data I/O, and Newton solvers in reduced‐order modeling (ROM) workflows.\nThis module provides:\n\nSnapshot train/test splitting routines:\n\ntrain_test_split, latin_hypercube_train_test_split, sobol_train_test_split\n\nSample generators:\n\ngenerate_sobol, generate_lhs, generate_gaussian_samples\n\nBasis management:\n\nupdate_basis – deflation and augmentation of reduced bases\n\nSolution reconstruction:\n\nreconstruct_solution – expand reduced vectors back to full order\n\nROM data persistence:\n\nrom_data_gen, load_rom_data\n\nNewton solvers for ROM systems:\n\nnewton_hyper_rom_solver, newton_solver_rom\n\n\nTogether, these functions support data preparation, sampling design, basis enrichment, I/O, and nonlinear solves in full‐to‐reduced‐order pipelines.\n\n\n\n\n\nName\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve a nonlinear reduced-order system using Newton’s method with LU refactorization.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    instance,\n    u,\n    tol=0.01,\n    maxit=50,\n    params=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n50\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear reduced-order system using Newton’s method with LU refactorization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction returning (J_rom, RHS_rom). Must accept u_rom as first argument, then *args and **kwargs.\nrequired\n\n\nu_rom\nndarray\nInitial guess for the reduced state; updated in place.\nrequired\n\n\n*args\n\nPositional arguments forwarded to assemble_func (e.g., u_old_rom, bc_data).\n()\n\n\ntol\nfloat\nConvergence threshold on the norm of the Newton step. Default is 1e-6.\n1e-06\n\n\nmaxit\nint\nMaximum number of Newton iterations. Default is 50.\n50\n\n\njac_tol\nfloat\nRelative change threshold to trigger LU refactorization. Default is 1e-1.\n0.1\n\n\n**kwargs\n\nKeyword arguments forwarded to assemble_func (e.g., iteration index).\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_rom\nndarray\nConverged reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf LU factorization fails or no convergence within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/rom.rom_utils.html#functions",
    "href": "reference/rom.rom_utils.html#functions",
    "title": "rom.rom_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ngenerate_gaussian_samples\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\ngenerate_lhs\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\ngenerate_sobol\nGenerate a Sobol sequence scaled to given bounds.\n\n\nlatin_hypercube_train_test_split\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\nload_rom_data\nLoad ROM data from a ROM_data directory or module path.\n\n\nnewton_hyper_rom_solver\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\nnewton_solver_rom\nSolve a nonlinear reduced-order system using Newton’s method with LU refactorization.\n\n\nreconstruct_solution\nReconstruct a full-order solution from a reduced solution vector.\n\n\nrom_data_gen\nSave ROM simulation data to disk.\n\n\nsobol_train_test_split\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\ntrain_test_split\nSplit snapshot indices into training and testing masks.\n\n\nupdate_basis\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\nrom.rom_utils.generate_gaussian_samples(dimensions, num_points, bounds)\nGenerate Gaussian-distributed samples based on bounds-derived statistics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension; means and stds are derived from these.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsamples\n(ndarray, shape(num_points, dimensions))\nGaussian-distributed samples without clipping to the original bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_lhs(dimensions, num_points, bounds)\nGenerate a Latin Hypercube Sample (LHS) scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the sample.\nrequired\n\n\nnum_points\nint\nNumber of points to generate.\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nLHS samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.generate_sobol(dimensions, num_points, bounds)\nGenerate a Sobol sequence scaled to given bounds.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndimensions\nint\nNumber of dimensions in the Sobol sequence.\nrequired\n\n\nnum_points\nint\nNumber of points in the sequence (must be a power of two).\nrequired\n\n\nbounds\nlist of tuple of float\nList of (lower, upper) bounds for each dimension.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nscaled_samples\n(ndarray, shape(num_points, dimensions))\nSobol sequence samples scaled to the provided bounds.\n\n\n\n\n\n\n\nrom.rom_utils.latin_hypercube_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Latin Hypercube Sampling.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.load_rom_data(self, rom_data_dir=None)\nLoad ROM data from a ROM_data directory or module path.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\nobject or None\nIf an instance is provided, data is loaded into attributes; if None, data is returned.\nrequired\n\n\nrom_data_dir\nstr, Path, or None\nDirectory or module path to load ROM_data from. Default is None (auto-detect).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfos_solutions\nndarray\nLoaded full-order solution snapshots.\n\n\nsim_data\ndict\nDictionary of loaded simulation data when self is None; otherwise sets attributes on self.\n\n\n\n\n\n\n\nrom.rom_utils.newton_hyper_rom_solver(\n    instance,\n    u,\n    tol=0.01,\n    maxit=50,\n    params=None,\n)\nSolve a hyper-reduced ROM system via Newton’s method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninstance\nobject\nObject with method assemble_hyper_rom_system(u, params) returning (A, y).\nrequired\n\n\nu\nndarray\nInitial reduced solution vector, updated in place.\nrequired\n\n\ntol\nfloat\nConvergence tolerance on the norm of the update. Defaults to 1e-2.\n0.01\n\n\nmaxit\nint\nMaximum number of Newton iterations. Defaults to 50.\n50\n\n\nparams\nany\nAdditional parameters passed to assemble_hyper_rom_system.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nConverged reduced solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf convergence is not achieved within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.newton_solver_rom(\n    assemble_func,\n    u_rom,\n    *args,\n    tol=1e-06,\n    maxit=50,\n    jac_tol=0.1,\n    **kwargs,\n)\nSolve a nonlinear reduced-order system using Newton’s method with LU refactorization.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_func\ncallable\nFunction returning (J_rom, RHS_rom). Must accept u_rom as first argument, then *args and **kwargs.\nrequired\n\n\nu_rom\nndarray\nInitial guess for the reduced state; updated in place.\nrequired\n\n\n*args\n\nPositional arguments forwarded to assemble_func (e.g., u_old_rom, bc_data).\n()\n\n\ntol\nfloat\nConvergence threshold on the norm of the Newton step. Default is 1e-6.\n1e-06\n\n\nmaxit\nint\nMaximum number of Newton iterations. Default is 50.\n50\n\n\njac_tol\nfloat\nRelative change threshold to trigger LU refactorization. Default is 1e-1.\n0.1\n\n\n**kwargs\n\nKeyword arguments forwarded to assemble_func (e.g., iteration index).\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_rom\nndarray\nConverged reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf LU factorization fails or no convergence within maxit iterations.\n\n\n\n\n\n\n\nrom.rom_utils.reconstruct_solution(u_reduced, V_sel, mean)\nReconstruct a full-order solution from a reduced solution vector.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu_reduced\n(ndarray, shape(r))\nReduced solution vector.\nrequired\n\n\nV_sel\n(ndarray, shape(N_h, r))\nBasis matrix for free degrees of freedom.\nrequired\n\n\nmean\n(ndarray, shape(N_h))\nMean vector that was subtracted during snapshot centering.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu_full\n(ndarray, shape(N_h))\nFull-order solution vector, including mean shift.\n\n\n\n\n\n\n\nrom.rom_utils.rom_data_gen(save_kw, problem_path)\nSave ROM simulation data to disk.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_kw\ndict\nDictionary containing simulation outputs; must include ‘fos_solutions’.\nrequired\n\n\nproblem_path\nstr or Path\nFilesystem path to the problem directory.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nKeyError\nIf ‘fos_solutions’ key is missing in save_kw.\n\n\n\n\n\n\n\nrom.rom_utils.sobol_train_test_split(N_snap, train_percentage=0.8)\nSplit snapshots into training and testing masks via Sobol sequence ordering.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.train_test_split(N_snap, N_sel=None, train_percentage=0.8)\nSplit snapshot indices into training and testing masks.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nN_snap\nint\nTotal number of snapshots.\nrequired\n\n\nN_sel\nint or None\nNumber of snapshots to select before splitting. If None, all snapshots are used. Default is None.\nNone\n\n\ntrain_percentage\nfloat\nProportion of snapshots to include in the training set. Defaults to 0.8.\n0.8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntrain_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating training snapshots.\n\n\ntest_mask\nndarray of bool, shape (N_snap,)\nBoolean mask indicating testing snapshots.\n\n\n\n\n\n\n\nrom.rom_utils.update_basis(V, W_mu, max_modes=5)\nUpdate a reduced basis by appending new modes from deflated snapshots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nV\n(ndarray, shape(N_h, r_old))\nCurrent orthonormal reduced basis.\nrequired\n\n\nW_mu\n(ndarray, shape(N_h, N_t))\nNew high-fidelity snapshots for parameter μ.\nrequired\n\n\nmax_modes\nint\nMaximum number of new modes to append from deflation. Defaults to 5.\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nV_new\n(ndarray, shape(N_h, r_old + k))\nRe-orthonormalized basis combining old and newly added modes.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_utils"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html",
    "href": "reference/utils.reduced_basis.svd.html",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "utils.reduced_basis.svd\n\n\n\n\n\nName\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5",
    "crumbs": [
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.svd.html#functions",
    "href": "reference/utils.reduced_basis.svd.html#functions",
    "title": "utils.reduced_basis.svd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nsvd_mode_selector\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\nsvd_mode_selector_var\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on relative reconstruction-error tolerance and plot the error.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed relative reconstruction error (L2-norm) for the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified reconstruction-error tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nSingular values are flipped to compute residual energy from smallest to largest modes.\nRelative reconstruction error is defined as the square-root of uncaptured energy divided by total energy.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n4\n\n\n\n\nutils.reduced_basis.svd.svd_mode_selector_var(\n    data,\n    tolerance=0.001,\n    modes=False,\n    **kwargs,\n)\nSelect SVD modes based on an uncaptured variance tolerance and plot the uncaptured variance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\n(array_like, shape(n_samples, n_features) or (n_features, n_samples))\nInput data matrix. Columns (or rows) represent snapshots or observations.\nrequired\n\n\ntolerance\nfloat\nMaximum allowed fraction of total variance that remains uncaptured by the selected modes. Defaults to 1e-3.\n0.001\n\n\nmodes\nbool\nIf True, prints the number of selected modes. Defaults to False.\nFalse\n\n\n**kwargs\n\nAdditional keyword arguments passed to the plot (e.g., marker style, line width).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnum_selected_modes\nint\nNumber of SVD modes required to meet the specified uncaptured variance tolerance.\n\n\nU\n(ndarray, shape(n_features, n_features))\nMatrix of left singular vectors from the SVD of the input data.\n\n\n\n\n\n\n\nThe function computes the full SVD of the (transposed) data matrix and calculates the cumulative sum of squared singular values to measure variance content.\nUncaptured variance is defined as one minus the cumulative energy.\nA horizontal line at y = tolerance is drawn on the semilog plot for reference.\n\n\n\n\n&gt;&gt;&gt; num_modes, U = svd_mode_selector_var(data_matrix, tolerance=1e-2)\n&gt;&gt;&gt; print(num_modes)\n5",
    "crumbs": [
      "Utilities",
      "utils.reduced_basis.svd"
    ]
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "hyperreduction.ecsw.custom_nnls\nImplements bounded non-negative least squares (NNLS) for Empirical Cubature Subset Weighting (ECSW).\nThis module provides: - NNLS_termination: enumeration of L2 and L∞ convergence criteria for NNLS. - _verify: internal helper to assert solver invariants. - NNLSSolver: a sequential active-set NNLS solver with per-entry bounds, selectable norms, stall-detection, and verbosity controls.\nThe ecsw folder contains utilities for Empirical Cubature Subset Weighting, including: - Algorithms to compute cubature weights using bounded NNLS. - Selection and pruning of integration points via active-set methods. - Support functions for convergence criteria and solver configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html",
    "href": "reference/rom.rom_error_est.html",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "rom.rom_error_est\nCompute and visualize ROM error metrics for flat data reconstructions.\nThis module provides: - compute_rom_error_metrics_flat: calculates time-dependent and global error measures (L2, L∞, RMSE, MAE, R², explained variance, quantiles, and optional energy norm). - plot_rom_error_diagnostics_flat: diagnostic plots including true vs. ROM scatter, spatial snapshots for selected snapshots, and raincloud plots of error and speed-up. - generate_rom_error_report: prints a structured summary of global and time-dependent ROM error statistics to the console.\nThe rom folder contains core tools for reduced-order modeling, including: - Assembly abstractions for reduced bilinear and linear forms - Error evaluation and reporting utilities (this module) - Hyper-reduction and cubature integration tools\n\n\n\n\n\nName\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/rom.rom_error_est.html#functions",
    "href": "reference/rom.rom_error_est.html#functions",
    "title": "rom.rom_error_est",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncompute_rom_error_metrics_flat\ncompute_rom_error_metrics_flat\n\n\ngenerate_rom_error_report\ngenerate_rom_error_report\n\n\nplot_rom_error_diagnostics_flat\nplot_rom_error_diagnostics_flat\n\n\n\n\n\nrom.rom_error_est.compute_rom_error_metrics_flat(u, u_rom, K=None)\ncompute_rom_error_metrics_flat\nCompute various error metrics between full-order and ROM reconstructions for flat data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field, with each row representing a snapshot.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching the shape of u.\nrequired\n\n\nK\n(array_like, shape(n_space, n_space))\nStiffness matrix for computing the energy-norm error.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmetrics\ndict\nDictionary containing error metrics: time-dependent ————— L2_error_time : ndarray, shape (n_snapshots,) L2 norm of error per snapshot. relative_L2_error_time : ndarray, shape (n_snapshots,) Relative L2 error per snapshot. RMSE_time : ndarray, shape (n_snapshots,) Root mean square error per snapshot. MAE_time : ndarray, shape (n_snapshots,) Mean absolute error per snapshot. time_avg_rel_L2_error : float Average relative L2 error over all snapshots. global —— L2_error : float Global L2 norm of the error. relative_L2_error : float Global relative L2 error. Linf_error : float Maximum absolute error. relative_Linf_error : float Maximum relative error. RMSE : float Global root mean square error. MAE : float Global mean absolute error. R2 : float Coefficient of determination. explained_variance : float Variance explained by the ROM. quantiles : dict median_error : float Median absolute error. p95_error : float 95th percentile of absolute errors. optional ——– energy_norm_error : float Energy-norm error computed if K is provided.\n\n\n\n\n\n\n\nrom.rom_error_est.generate_rom_error_report(metrics, name='ROM Accuracy Report')\ngenerate_rom_error_report\nPrint a structured summary of ROM error metrics.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ndict\nError metrics dictionary from compute_rom_error_metrics_flat.\nrequired\n\n\nname\nstr\nTitle of the report. Defaults to “ROM Accuracy Report”.\n'ROM Accuracy Report'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nrom.rom_error_est.plot_rom_error_diagnostics_flat(\n    u,\n    u_rom,\n    rom_relative_error,\n    rom_speed_up,\n    sim_axis,\n    metrics,\n    spatial_shape=None,\n)\nplot_rom_error_diagnostics_flat\nVisualize ROM error diagnostics including scatter, spatial snapshots, and raincloud plots.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\n(array_like, shape(n_snapshots, n_space))\nFull-order field for diagnostics.\nrequired\n\n\nu_rom\n(array_like, shape(n_snapshots, n_space))\nROM reconstruction matching shape of u.\nrequired\n\n\nrom_relative_error\n(array_like, shape(n_snapshots))\nRelative error per snapshot.\nrequired\n\n\nrom_speed_up\n(array_like, shape(n_snapshots))\nSpeed-up factors per snapshot.\nrequired\n\n\nsim_axis\ntuple of str\nAxis labels for true vs ROM scatter (xlabel, ylabel).\nrequired\n\n\nmetrics\ndict\nDictionary of error metrics from compute_rom_error_metrics_flat.\nrequired\n\n\nspatial_shape\ntuple of int\nShape (nx, ny) to reshape spatial data for pcolormesh plots.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.rom_error_est"
    ]
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html",
    "href": "reference/hyperreduction.linear_form_hyperrom.html",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.linear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.linear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#classes",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormHYPERROM\nReduced-order linear form for hyper-reduction of load vectors.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order linear form for hyper-reduction of load vectors.\nProjects element-level load vectors onto a reduced basis and assembles the global reduced load vector. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All operations occur only on free DOFs, with Dirichlet and mean field contributions reinserted during reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original linear form function evaluating local load contributions.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nFinite element basis object with full DOF count and element connectivity.\nrequired\n\n\nlob\nndarray\nReduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise, where r is the reduced dimension.\nrequired\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, basis is defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for parallel element-wise evaluation. Default is 0 (serial).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled vectors and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the weighted reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for full-order linear forms.\n\n\nextract_element_vector_rom\nExtract local element load vectors in the reduced setting.\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the weighted reduced load vector.\nEach element load vector is multiplied by its weight and projected onto the reduced basis (restricted to free DOFs), then summed into a single vector of length r.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters forwarded to extract_element_vector_rom, such as previous states or material parameters.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nAssembled reduced load vector.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local element load vectors for full-order linear forms.\nAssembles the linear form on each element of a full-order basis, returning an array of shape (n_elem, Nbfun) of load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis for test functions.\nrequired\n\n\n**kwargs\n\nAdditional parameters for assembly (e.g., boundary data).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each element.\n\n\n\n\n\n\n\nhyperreduction.linear_form_hyperrom.LinearFormHYPERROM.extract_element_vector_rom(\n    basis,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local element load vectors in the reduced setting.\nEvaluates the original linear form on each specified element and returns an array of shape (n_elem, Nbfun), where Nbfun is the number of local basis functions per element.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nBasis\nBasis restricted via with_elements for trial functions.\nrequired\n\n\nelem_indices\nndarray of int\nSubset of elements to include; passed to with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to low-level form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elem, Nbfun))\nLocal load vectors for each (restricted) element.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf basis is None or improperly configured.",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.linear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/utils.visualization.html",
    "href": "reference/utils.visualization.html",
    "title": "utils.visualization",
    "section": "",
    "text": "utils.visualization\nutils.visualization",
    "crumbs": [
      "Visualization",
      "utils.visualization"
    ]
  },
  {
    "objectID": "reference/hyperreduction.ecsw.html",
    "href": "reference/hyperreduction.ecsw.html",
    "title": "hyperreduction.ecsw",
    "section": "",
    "text": "hyperreduction.ecsw\nhyperreduction.ecsw",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.ecsw"
    ]
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "hyperreduction.bilinear_form_hyperrom\n\n\nImplements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element.",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.bilinear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#classes",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBilinearFormHYPERROM\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM(\n    form,\n    elem_weight,\n    ubasis,\n    lob,\n    rob,\n    vbasis=None,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nReduced-order bilinear form for hyper-reduction of stiffness matrices.\nProjects element-level stiffness matrices onto reduced bases and assembles the global reduced stiffness matrix. Handles Dirichlet boundary conditions via mapping from full degrees of freedom (DOFs) to free (non-Dirichlet) DOFs. All reduced bases and operations are performed only on free DOFs, with Dirichlet and mean field contributions reinserted during solution reconstruction.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nform\ncallable\nThe original bilinear form function taking test and trial basis functions and assembly parameters.\nrequired\n\n\nelem_weight\nscalar or ndarray\nElement-wise weights (e.g., quadrature or sampling weights). Can be a single scalar or an array of length equal to the number of elements.\nrequired\n\n\nubasis\nBasis\nTrial-space reduced basis object containing full DOF count and element connectivity data.\nrequired\n\n\nlob\nndarray\nLeft (test) reduced basis matrix of shape (N_free, r) if free_dofs is provided, or (N, r) otherwise.\nrequired\n\n\nrob\nndarray\nRight (trial) reduced basis matrix, with same shape requirements as lob.\nrequired\n\n\nvbasis\nBasis\nReduced basis for test functions; if None, defaults to ubasis.\nNone\n\n\nfree_dofs\nndarray of int\nIndices of global DOFs that are free (non-Dirichlet). If provided, bases are defined only on these DOFs.\nNone\n\n\nmean\nndarray\nMean snapshot vector of length N_full DOFs, subtracted during basis computation and reinserted during reconstruction.\nNone\n\n\nnthreads\nint\nNumber of threads for element-wise assembly operations. Default 0 (serial execution).\n0\n\n\ndtype\ndata - type\nNumPy data type for assembled matrices and intermediate arrays.\nnp.float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nlob\nndarray\nLeft reduced basis (possibly restricted to free DOFs).\n\n\nrob\nndarray\nRight reduced basis (possibly restricted to free DOFs).\n\n\nfree_dofs\nndarray or None\nIndices of free DOFs if Dirichlet conditions are present.\n\n\nmean\nndarray or None\nMean snapshot vector for solution centering.\n\n\nr\nint\nReduced dimension (number of basis vectors).\n\n\nmapping\nndarray of int\nMapping from full DOF indices to reduced free-DOF indices.\n\n\ncluster_idx\nlist of ndarray\nIndices of elements grouped by number of free DOFs per element.\n\n\norder_cluster\nlist of ndarray\nLocal ordering for extracting free DOF positions within each cluster.\n\n\nw_cluster\nlist of ndarray\nElement weights corresponding to each cluster.\n\n\nR_test_free\nlist of ndarray\nTest-basis rows restricted to free DOFs per element cluster.\n\n\nR_trial_free\nlist of ndarray\nTrial-basis rows restricted to free DOFs per element cluster.\n\n\n\n\n\n\n\nClustering by element free DOF count enables vectorized extraction of submatrices for each element group, reducing Python looping.\nUses Einstein summation (np.einsum) to contract element-level contributions into the reduced global stiffness matrix.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble_weighted\nAssemble the globally weighted reduced stiffness matrix.\n\n\nextract_element_matrices_rom\nExtract local stiffness matrices in the reduced basis for specified elements.\n\n\nextract_element_vector\nExtract local load vectors for a linear form in the ROM.\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.assemble_weighted(\n    **kwargs,\n)\nAssemble the globally weighted reduced stiffness matrix.\nEach element stiffness block is weighted, projected onto reduced test/trial bases restricted to free DOFs, and summed into a reduced r-by-r matrix.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional options passed to the low-level form assembly routines (e.g., quadrature settings).\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nK_reduced\n(ndarray, shape(r, r))\nAssembled reduced stiffness matrix.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_matrices_rom(\n    ubasis,\n    vbasis=None,\n    elem_indices=None,\n    **kwargs,\n)\nExtract local stiffness matrices in the reduced basis for specified elements.\nThis routine assembles the original bilinear form on each element and returns an array of shape (n_elems, Nbfun, Nbfun), where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nubasis\nBasis\nTrial-space finite element basis (with restricted elements if elem_indices is provided).\nrequired\n\n\nvbasis\nBasis\nTest-space finite element basis; defaults to ubasis.\nNone\n\n\nelem_indices\nndarray of int\nSubset of element indices to restrict the basis via with_elements.\nNone\n\n\n**kwargs\n\nExtra keyword arguments forwarded to the form assembly.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_matrices\n(ndarray, shape(n_elems, Nbfun, Nbfun))\nLocal element stiffness matrices for each (restricted) element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trial/test bases have mismatched quadrature dimensions.\n\n\n\n\n\n\n\nhyperreduction.bilinear_form_hyperrom.BilinearFormHYPERROM.extract_element_vector(\n    basis,\n    **kwargs,\n)\nExtract local load vectors for a linear form in the ROM.\nAssembles the linear form on each element, returning an array of shape (n_elems, Nbfun) of local load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nTest-space finite element basis.\nrequired\n\n\n**kwargs\n\nExtra parameters forwarded to the form evaluation.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elems, Nbfun))\nLocal element load vectors for each element.",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.bilinear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html",
    "href": "reference/rom.linear_form_rom.html",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "rom.linear_form_rom\nImplements reduced-order linear form assembly for full-order to reduced-order transformations.\nThis module provides: - LinearFormROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects full-order element load vectors onto reduced bases, groups elements by Dirichlet-free and mixed-Dirichlet sets for memory-efficient handling, and assembles the global reduced load vector with optional chunked computation.\nThe rom folder contains core tools for reduced-order modeling (ROM), including: - Classes for projecting and assembling reduced-order bilinear and linear forms - Utilities for handling Dirichlet boundary conditions in reduced spaces - Chunked and clustered assembly routines to manage large-scale stiffness/load data - Mapping utilities between full-order and reduced-order degrees of freedom\n\n\n\n\n\nName\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/rom.linear_form_rom.html#classes",
    "href": "reference/rom.linear_form_rom.html#classes",
    "title": "rom.linear_form_rom",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nLinearFormROM\nLinearFormROM\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM(\n    form,\n    ubasis,\n    lob,\n    free_dofs=None,\n    mean=None,\n    nthreads=0,\n    dtype=np.float64,\n)\nLinearFormROM\nLinear form that projects element load vectors onto reduced bases and assembles the global reduced load vector, handling Dirichlet boundary conditions via mappings from full to free DOFs.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nr_basis\n(ndarray, shape(N_free, r) or (N, r))\nReduced basis for load vectors.\n\n\nfree_dofs\nndarray or None\nIndices of global free (non-Dirichlet) DOFs.\n\n\nmean\nndarray or None\nMean snapshot vector subtracted before basis computation.\n\n\nnthreads\nint\nNumber of threads for parallel computation.\n\n\ndtype\ndata - type\nNumeric type for computations.\n\n\nubasis\nBasis\nFull-order finite element basis for test functions.\n\n\nmapping\n(ndarray, shape(N_full))\nMaps global DOF indices to reduced DOF indices or -1 for Dirichlet DOFs.\n\n\nelement_dofs\nndarray\nLocal-to-global DOF mapping for each element.\n\n\nfree_indices\nndarray\nReduced DOF indices for each element and basis function.\n\n\nmask\nndarray of bool\nIndicates free DOFs per element.\n\n\nr\nint\nDimension of the reduced basis.\n\n\ngroupA\nndarray\nIndices of elements with all free DOFs.\n\n\ngroupB\nndarray\nIndices of elements with some Dirichlet DOFs.\n\n\nchunk_size\nint\nNumber of elements per chunk in groupA.\n\n\nn_full_chunks\nint\nNumber of full-sized chunks in groupA.\n\n\nremainder\nint\nNumber of leftover elements in groupA.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nassemble\nAssemble the global reduced load vector.\n\n\nextract_element_vector\nExtract local element load vectors for a linear form.\n\n\nhyperreduction\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.assemble(**kwargs)\nAssemble the global reduced load vector.\nProjects element load vectors onto reduced bases and sums contributions over free DOFs only.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during assembly.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(r))\nReduced load vector.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.extract_element_vector(basis, **kwargs)\nExtract local element load vectors for a linear form.\nComputes per-element load contributions for each local basis function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbasis\nAbstractBasis\nFinite element basis associated with the test function.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to the form.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_vectors\n(ndarray, shape(n_elements, Nbfun))\nLocal load vectors for each element, where Nbfun is the number of local basis functions.\n\n\n\n\n\n\n\nrom.linear_form_rom.LinearFormROM.hyperreduction(**kwargs)\nPerform hyperreduction to assemble per-element reduced load contributions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\n\nAdditional parameters passed to the form during hyperreduction.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nf_reduced\n(ndarray, shape(n_contribs, r))\nConcatenated reduced load contributions for hyperreduction.",
    "crumbs": [
      "Reduced-Order Model (ROM)",
      "rom.linear_form_rom"
    ]
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "hyperreduction.ecsw.hyperreduce\nImplements the end-to-end hyper-reduction pipeline combining randomized SVD and bounded NNLS.\nThis module provides: - hyperreduce: function to perform hyper-reduction on a QoI matrix by: 1. Optionally applying randomized SVD for dimensionality reduction 2. Constructing bounded constraints for NNLS from projected data 3. Solving a bounded NNLS problem via NNLSSolver 4. Optionally visualizing singular value decay and NNLS coefficients\nThe hyperreduce folder contains utilities to reduce full-order models, including: - Randomized SVD preprocessing routines - Bounded NNLS solve integrations (custom_nnls) - Plotting helpers for diagnostic visualization of reduction errors\nDependencies: - NumPy for array operations - scikit-learn’s randomized_svd for fast SVD - Matplotlib for plotting diagnostics - Custom NNLSSolver implementation in custom_nnls\nUsage example:\nfrom hyperreduce.hyperreduce import hyperreduce\nx, flag = hyperreduce(qoi_data, n_components=100, svd=True)\n\n\n\n\n\nName\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "href": "reference/hyperreduction.ecsw.hyperreduce.html#functions",
    "title": "hyperreduction.ecsw.hyperreduce",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nhyperreduce\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\n\n\n\n\n\nhyperreduction.ecsw.hyperreduce.hyperreduce(\n    qoi,\n    n_components=500,\n    verbosity=2,\n    plot=True,\n    const_tol=1e-10,\n    zero_tol=1e-14,\n    svd=False,\n)\nPerform hyper-reduction via randomized SVD followed by a bounded NNLS solve.\nThe hyper-reduction pipeline includes:\n\n(Optional) Randomized SVD of the quantity of interest (QoI) matrix to reduce its dimensionality.\nConstruction of lower and upper bound constraints around the projected right-hand side vector.\nBounded Non-Negative Least Squares (NNLS) solve using the NNLSSolver.\n(Optional) Visualization of singular value decay and NNLS solution coefficients.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nqoi\n(array_like, shape(n_samples, n_features))\nQuantity of interest matrix on which hyper-reduction is performed.\nrequired\n\n\nn_components\nint\nNumber of singular value decomposition components to retain when svd=True. Must be less than or equal to (n_samples, n_features). Default is 500.\n500\n\n\nverbosity\nint\nVerbosity level for the NNLS solver. Higher values yield more diagnostic output. Default is 2.\n2\n\n\nplot\nbool\nWhether to display plots for singular value decay and the NNLS solution vector. Default is True.\nTrue\n\n\nconst_tol\nfloat\nTolerance used to define the half-gap around the average right-hand side vector for bounded constraints. Default is 1e-10.\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which NNLS solution coefficients are considered zero. Default is 1e-14.\n1e-14\n\n\nsvd\nbool\nIf True, apply randomized SVD preprocessing to qoi, otherwise solve NNLS directly on the original data. Default is False.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nx\n(ndarray, shape(n_features) or (n_components,))\nCoefficients from the bounded NNLS solve representing the hyper-reduction weights.\n\n\nflag\nint\nExit status flag returned by the NNLS solver (e.g., 0 indicates successful convergence).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf n_components is greater than the minimum dimension of qoi when svd=True.\n\n\n\n\n\n\n\nThe randomized_svd step (when enabled) uses oversampling and power iterations for stability and accuracy.\nBounds for the NNLS solve are constructed as:\n.. math:: b_{} = d_q - , b_{} = d_q + ,\nwhere\n.. math:: d_q = V_q^{} \nis the projected right-hand side vector.\nThe final hyper-reduced error is computed internally as\n.. math:: \nand printed for diagnostic purposes.\n\n\n\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from hyperreduce_module import hyperreduce\n&gt;&gt;&gt; data = np.random.rand(100, 200)\n&gt;&gt;&gt; x, flag = hyperreduce(data, n_components=50, svd=True, plot=False)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n&gt;&gt;&gt; print(\"Active basis vectors:\", np.sum(x &gt; 0))",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.ecsw.hyperreduce"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html",
    "href": "reference/fom.fem_utils.html",
    "title": "fom.fem_utils",
    "section": "",
    "text": "fom.fem_utils\nProvides functions for building algebraic multigrid smoothed aggregation preconditioners, mapping mesh elements to their spatial coordinates, and solving nonlinear systems using the Newton–Raphson method with optional Dirichlet boundary conditions.\nThis module includes: - build_pc_amgsa: construct AMG smoothed aggregation preconditioner. - element2location: generate element-to-coordinate mappings from mesh data. - newton_solver and its helpers: perform Newton–Raphson solves with or without Dirichlet BC.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/fom.fem_utils.html#functions",
    "href": "reference/fom.fem_utils.html#functions",
    "title": "fom.fem_utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_pc_amgsa\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\nelement2location\nMap mesh elements to their spatial coordinates.\n\n\nnewton_solver\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\nfom.fem_utils.build_pc_amgsa(A, **kwargs)\nBuild an algebraic multigrid smoothed aggregation preconditioner.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nscipy.sparse matrix or array_like\nThe system matrix for which the preconditioner is constructed.\nrequired\n\n\n**kwargs\n\nAdditional keyword arguments passed to pyamg.smoothed_aggregation_solver.\n{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nM\nscipy.sparse.linalg.LinearOperator\nThe preconditioner as a linear operator suitable for use in iterative solvers.\n\n\n\n\n\n\n\nfom.fem_utils.element2location(mesh)\nMap mesh elements to their spatial coordinates.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmesh\nobject\nMesh object with attributes p (node coordinates) and t (element connectivity).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nelement_coords\nndarray of shape (n_elements, n_local_nodes)\nArray of element coordinates, where each row corresponds to an element and each column corresponds to a local node within the element.\n\n\n\n\n\n\n\nfom.fem_utils.newton_solver(\n    assemble_fn,\n    u0,\n    dirichlet_dofs=None,\n    dirichlet_vals=None,\n    *assemble_args,\n    tol=0.01,\n    maxit=50,\n)\nSolve a nonlinear system using the Newton–Raphson method with optional Dirichlet boundary conditions.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nassemble_fn\ncallable\nFunction that assembles the system. Should return either (RHS, J) for functions with dirichlet BC or (J, RHS) for no-dirichlet variant.\nrequired\n\n\nu0\nndarray\nInitial guess for the solution vector.\nrequired\n\n\ndirichlet_dofs\narray_like of int\nIndices of degrees of freedom with prescribed Dirichlet boundary conditions. If None or empty, no Dirichlet BC are applied.\nNone\n\n\ndirichlet_vals\nndarray\nValues at the Dirichlet DOFs.\nNone\n\n\n*assemble_args\n\nAdditional positional arguments passed to assemble_fn.\n()\n\n\ntol\nfloat\nTolerance for convergence based on the norm of the update.\n1e-2\n\n\nmaxit\nint\nMaximum number of Newton iterations.\n50\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nu\nndarray\nApproximate solution vector after convergence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf the solver fails to converge within maxit iterations.",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom.fem_utils"
    ]
  },
  {
    "objectID": "reference/utils.reduced_basis.html",
    "href": "reference/utils.reduced_basis.html",
    "title": "utils.reduced_basis",
    "section": "",
    "text": "utils.reduced_basis\nutils.reduced_basis",
    "crumbs": [
      "Utilities",
      "utils.reduced_basis"
    ]
  },
  {
    "objectID": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "href": "reference/hyperreduction.ecsw.custom_nnls.html#classes",
    "title": "hyperreduction.ecsw.custom_nnls",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nNNLSSolver\nSequential bounded NNLS (non-negative least squares) solver.\n\n\nNNLS_termination\nTermination criteria for the NNLS solver.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver(\n    const_tol=1e-06,\n    min_nnz=1,\n    max_nnz=0,\n    verbosity=1,\n    res_change_termination_tol=1e-10,\n    zero_tol=1e-15,\n    n_outer=1000,\n    n_inner=400,\n    criterion=NNLS_termination.LINF,\n)\nSequential bounded NNLS (non-negative least squares) solver.\nImplements an active-set method for finding x ≥ 0 that approximately satisfies A x ≈ b, with per-entry bounds on b and two convergence tests (L₂‐ and L∞‐norm).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconst_tol\nfloat\nTolerance for constraint violation in the L∞‐criterion (default: 1e-6).\n1e-06\n\n\nmin_nnz\nint\nMinimum number of nonzeros required in the solution before stopping (default: 1).\n1\n\n\nmax_nnz\nint\nMaximum allowed number of nonzeros in the solution. A value of 0 means “no limit” and will be set to the number of columns of A on the first solve call (default: 0).\n0\n\n\nverbosity\nint\nPrint level (0: silent, 1: summary only, ≥2: detailed per‐iteration logging) (default: 1).\n1\n\n\nres_change_termination_tol\nfloat\nIf the relative change in the mean residual over 50 iterations falls below this threshold, the solver will deem itself stalled (default: 1e-10).\n1e-10\n\n\nzero_tol\nfloat\nThreshold below which computed subproblem entries are considered zero (default: 1e-15).\n1e-15\n\n\nn_outer\nint\nMaximum number of outer (active‐set) iterations (default: 1000).\n1000\n\n\nn_inner\nint\nMaximum number of inner (subproblem) iterations per active set (default: 400).\n400\n\n\ncriterion\n(NNLS_termination.L2, NNLS_termination.LINF)\nWhich norm to use for stopping test: L2 uses ‖r‖₂ ≤ ‖gap‖₂, L∞ uses max_violation ≤ const_tol (default: L∞).\nNNLS_termination.L2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconst_tol_\nfloat\nAs given by const_tol.\n\n\nmin_nnz_\nint\nAs given by min_nnz.\n\n\nmax_nnz_\nint\nAs given by max_nnz or set at solve‐time.\n\n\nverbosity_\nint\nAs given by verbosity.\n\n\nres_change_termination_tol_\nfloat\nAs given by res_change_termination_tol.\n\n\nzero_tol_\nfloat\nAs given by zero_tol.\n\n\nn_outer_\nint\nAs given by n_outer.\n\n\nn_inner_\nint\nAs given by n_inner.\n\n\nd_criterion\nNNLS_termination\nAs given by criterion.\n\n\n\n\n\n\n&gt;&gt;&gt; from nnls_solver import NNLSSolver, NNLS_termination\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A = np.random.rand(20, 10)\n&gt;&gt;&gt; const_tol_ = 1e-3\n&gt;&gt;&gt; lb = b - const_tol_\n&gt;&gt;&gt; ub = b + const_tol_\n&gt;&gt;&gt; solver = NNLSSolver(const_tol=const_tol_, verbosity=2)\n&gt;&gt;&gt; x, flag = solver.solve(A, lb, ub)\n&gt;&gt;&gt; print(\"Exit flag:\", flag)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_verbosity\nSet the verbosity level.\n\n\nsolve\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.set_verbosity(verbosity_in)\nSet the verbosity level.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nverbosity_in\nint\nNew verbosity level (0: silent, larger for more output).\nrequired\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLSSolver.solve(mat, rhs_lb, rhs_ub)\nSolve A x ≈ b with 0 ≤ x and b∈[rhs_lb, rhs_ub] by active‐set NNLS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmat\n(array_like, shape(m, n))\nLeft‐hand‐side matrix A.\nrequired\n\n\nrhs_lb\n(array_like, shape(m))\nPer‐entry lower bounds on b.\nrequired\n\n\nrhs_ub\n(array_like, shape(m))\nPer‐entry upper bounds on b.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfinal_soln\n(ndarray, shape(n))\nComputed nonnegative solution.\n\n\nexit_flag\nint\nStatus code: - 0: converged successfully - 1: maximum outer iterations reached - 2: stalled (no significant residual change) - 3: other failure (e.g., subproblem failure or M≤N).\n\n\n\n\n\n\n\n\n\nhyperreduction.ecsw.custom_nnls.NNLS_termination()\nTermination criteria for the NNLS solver.\nEnumeration of the two supported norms used to decide convergence.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nL2\nint\nUse the L₂-norm of the residual (‖r‖₂) compared against the half-gap norm threshold (‖(rhs_ub – rhs_lb)/2‖₂).\n\n\nLINF\nint\nUse the L∞-norm criterion, i.e. the maximum per-entry violation must be no greater than the absolute tolerance (const_tol).",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.ecsw.custom_nnls"
    ]
  },
  {
    "objectID": "reference/utils.visualization.vtuwriter.html#classes",
    "href": "reference/utils.visualization.vtuwriter.html#classes",
    "title": "utils.visualization.vtuwriter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nVTUSeriesWriter\nCollect and export simulation snapshots as VTU and PVD files.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter(\n    mesh,\n    output_dir,\n    *,\n    prefix='step',\n    skip=2,\n    cell_type='tetra',\n)\nCollect and export simulation snapshots as VTU and PVD files.\nManages writing of individual VTU files at specified time steps and generates a PVD index file for seamless time-series playback.\n\n\n\n\n\nName\nDescription\n\n\n\n\nwrite_pvd\nGenerate a PVD collection file for all written VTU snapshots.\n\n\nwrite_step\nWrite a VTU file for a simulation snapshot.\n\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_pvd(\n    pvd_name='collection.pvd',\n)\nGenerate a PVD collection file for all written VTU snapshots.\nIterates over recorded entries and constructs an XML-based PVD file that ParaView can use to load time-series data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npvd_name\nstr\nFilename for the PVD output (default is “collection.pvd”).\n'collection.pvd'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_pvd(\"simulation.pvd\")\n\n\n\n\nutils.visualization.vtuwriter.VTUSeriesWriter.write_step(u, t, idx)\nWrite a VTU file for a simulation snapshot.\nCreates a meshio.Mesh with updated point_data and writes it to disk if the snapshot index matches the skip interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nu\narray_like\nPoint-wise scalar data array (e.g., temperature) of length equal to the number of mesh points.\nrequired\n\n\nt\nfloat or int\nSimulation time corresponding to this snapshot.\nrequired\n\n\nidx\nint\nSnapshot index; only written if idx % skip == 0.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n&gt;&gt;&gt; writer.write_step(temp_array, time, step_index)",
    "crumbs": [
      "Visualization",
      "utils.visualization.vtuwriter"
    ]
  },
  {
    "objectID": "reference/utils.old.html#utils.old",
    "href": "reference/utils.old.html#utils.old",
    "title": "utils.old",
    "section": "",
    "text": "Legacy utility functions and experimental prototypes retained for reference and backward compatibility.\nThis subpackage contains all “old” or deprecated utility routines that have since been superseded by newer, more robust implementations in the main utils package. It allows you to review earlier approaches and compare behavior against current methods.\nAvailable modules (non-exhaustive):\n\nsvd_mode_selectors_old.py : Original SVD mode selection routines using basic cumulative-energy thresholds.\napproximating_ln.py : Naive series-expansion algorithm for natural logarithm approximation.\nmagnetic_field_utils_old.py: Early SFML-based routines for drawing electric and magnetic field visualizations.\nkotter_change_plan.py : Preliminary Kotter’s Eight-Step Change Management plan generator.\ndehydration_monitor_old.py : Prototype hydration-tracking functions for Alzheimer’s monitoring device.\nwavelet_basics.py : Initial implementations of wavelet transform utilities.",
    "crumbs": [
      "Utilities",
      "utils.old"
    ]
  },
  {
    "objectID": "reference/utils.old.html#examples",
    "href": "reference/utils.old.html#examples",
    "title": "utils.old",
    "section": "",
    "text": "&gt;&gt;&gt; from utils.old import svd_mode_selectors_old\n&gt;&gt;&gt; modes, U = svd_mode_selectors_old.svd_mode_selector(data_matrix, tolerance=1e-2)",
    "crumbs": [
      "Utilities",
      "utils.old"
    ]
  },
  {
    "objectID": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "href": "reference/hyperreduction.bilinear_form_hyperrom.html#hyperreducebilinear_form_hyperrom.py",
    "title": "hyperreduction.bilinear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order stiffness assembly.\nThis module provides:\n\nBilinearFormHYPERROM: a subclass of skfem.assembly.form.bilinear_form.BilinearForm that\n\nclusters elements by number of free DOFs after Dirichlet condensation\nextracts and projects element stiffness blocks onto test/trial reduced bases\nassembles the global reduced stiffness matrix via vectorized contractions\n\n\nThe hyperreduce folder contains all tools for hyper-reduction, including: - Classes for reduced‐order bilinear and linear forms with element clustering - Routines to extract local element matrices/vectors in the ROM basis - Utilities for efficient handling of Dirichlet conditions in reduced spaces - Support for element‐wise parallelization and weighted assembly",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.bilinear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "href": "reference/hyperreduction.linear_form_hyperrom.html#hyperreducelinear_form_hyperrom.py",
    "title": "hyperreduction.linear_form_hyperrom",
    "section": "",
    "text": "Implements Hyper-Reduction (HYPERROM) for reduced-order load vector assembly.\nThis module provides: - LinearFormHYPERROM: a subclass of skfem.assembly.form.linear_form.LinearForm that projects element-wise load contributions onto a reduced basis, clusters elements by free-DOF count after Dirichlet condensation, and assembles the global reduced load vector via vectorized weighted projections.\nThe hyperreduce folder contains all tools to perform hyper-reduction, including: - Reduced-order bilinear forms (BilinearFormHYPERROM) and linear forms (LinearFormHYPERROM) - Routines for extracting element stiffness matrices and load vectors in a reduced basis - Utilities for efficient handling of Dirichlet conditions and element clustering - Support for weights, parallelization, and reconstruction of full-order data",
    "crumbs": [
      "hyperreduction",
      "hyperreduction.linear_form_hyperrom"
    ]
  },
  {
    "objectID": "reference/fom.html#fem_utils.py",
    "href": "reference/fom.html#fem_utils.py",
    "title": "fom",
    "section": "",
    "text": "Finite‐element utilities for full‐order model (FOM) workflows.\nThis module provides helpers for: - Mesh‐ and basis‐related operations - Assembly of stiffness/mass matrices and load vectors - Application of boundary conditions and integration routines\nThe fom folder contains everything needed to build and solve full‐order PDE models, including: - Mesh management and basis function definitions - System assembly routines (matrices, RHS) - Solver interfaces and preconditioners - Diagnostic and post‐processing tools",
    "crumbs": [
      "Full-Order Model (FOM)",
      "fom"
    ]
  }
]